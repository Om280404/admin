
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CustomerOtp
 * 
 */
export type CustomerOtp = $Result.DefaultSelection<Prisma.$CustomerOtpPayload>
/**
 * Model Seller
 * =========================
 * SELLER (ACCOUNT)
 * =========================
 */
export type Seller = $Result.DefaultSelection<Prisma.$SellerPayload>
/**
 * Model SellerOtp
 * SELLER OTP
 */
export type SellerOtp = $Result.DefaultSelection<Prisma.$SellerOtpPayload>
/**
 * Model SellerBusinessDetails
 * =========================
 * SELLER BUSINESS DETAILS
 * =========================
 */
export type SellerBusinessDetails = $Result.DefaultSelection<Prisma.$SellerBusinessDetailsPayload>
/**
 * Model SellerDeliveryDetails
 * =========================
 * SELLER DELIVERY DETAILS
 * =========================
 */
export type SellerDeliveryDetails = $Result.DefaultSelection<Prisma.$SellerDeliveryDetailsPayload>
/**
 * Model SellerBankDetails
 * =========================
 * SELLER BANK DETAILS
 * =========================
 */
export type SellerBankDetails = $Result.DefaultSelection<Prisma.$SellerBankDetailsPayload>
/**
 * Model Product
 * =========================
 * PRODUCT
 * =========================
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * =========================
 * ORDER (CUSTOMER LEVEL)
 * =========================
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * =========================
 * ORDER ITEM (SELLER LEVEL)
 * =========================
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Designer
 * 
 */
export type Designer = $Result.DefaultSelection<Prisma.$DesignerPayload>
/**
 * Model DesignerOtp
 * 
 */
export type DesignerOtp = $Result.DefaultSelection<Prisma.$DesignerOtpPayload>
/**
 * Model DesignerProfile
 * 
 */
export type DesignerProfile = $Result.DefaultSelection<Prisma.$DesignerProfilePayload>
/**
 * Model DesignerWork
 * 
 */
export type DesignerWork = $Result.DefaultSelection<Prisma.$DesignerWorkPayload>
/**
 * Model DesignerHireRequest
 * 
 */
export type DesignerHireRequest = $Result.DefaultSelection<Prisma.$DesignerHireRequestPayload>
/**
 * Model DesignerRating
 * 
 */
export type DesignerRating = $Result.DefaultSelection<Prisma.$DesignerRatingPayload>
/**
 * Model UserRating
 * 
 */
export type UserRating = $Result.DefaultSelection<Prisma.$UserRatingPayload>
/**
 * Model ReturnRequest
 * 
 */
export type ReturnRequest = $Result.DefaultSelection<Prisma.$ReturnRequestPayload>
/**
 * Model ContactMessage
 * 
 */
export type ContactMessage = $Result.DefaultSelection<Prisma.$ContactMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ReturnStatus: {
  NONE: 'NONE',
  REQUESTED: 'REQUESTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type ReturnStatus = (typeof ReturnStatus)[keyof typeof ReturnStatus]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const RefundStatus: {
  NONE: 'NONE',
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const RefundMethod: {
  STORE_CREDIT: 'STORE_CREDIT',
  ORIGINAL_PAYMENT: 'ORIGINAL_PAYMENT'
};

export type RefundMethod = (typeof RefundMethod)[keyof typeof RefundMethod]

}

export type ReturnStatus = $Enums.ReturnStatus

export const ReturnStatus: typeof $Enums.ReturnStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type RefundMethod = $Enums.RefundMethod

export const RefundMethod: typeof $Enums.RefundMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerOtp`: Exposes CRUD operations for the **CustomerOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerOtps
    * const customerOtps = await prisma.customerOtp.findMany()
    * ```
    */
  get customerOtp(): Prisma.CustomerOtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seller`: Exposes CRUD operations for the **Seller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sellers
    * const sellers = await prisma.seller.findMany()
    * ```
    */
  get seller(): Prisma.SellerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerOtp`: Exposes CRUD operations for the **SellerOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerOtps
    * const sellerOtps = await prisma.sellerOtp.findMany()
    * ```
    */
  get sellerOtp(): Prisma.SellerOtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerBusinessDetails`: Exposes CRUD operations for the **SellerBusinessDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerBusinessDetails
    * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findMany()
    * ```
    */
  get sellerBusinessDetails(): Prisma.SellerBusinessDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerDeliveryDetails`: Exposes CRUD operations for the **SellerDeliveryDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerDeliveryDetails
    * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findMany()
    * ```
    */
  get sellerDeliveryDetails(): Prisma.SellerDeliveryDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerBankDetails`: Exposes CRUD operations for the **SellerBankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerBankDetails
    * const sellerBankDetails = await prisma.sellerBankDetails.findMany()
    * ```
    */
  get sellerBankDetails(): Prisma.SellerBankDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designer`: Exposes CRUD operations for the **Designer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designers
    * const designers = await prisma.designer.findMany()
    * ```
    */
  get designer(): Prisma.DesignerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designerOtp`: Exposes CRUD operations for the **DesignerOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignerOtps
    * const designerOtps = await prisma.designerOtp.findMany()
    * ```
    */
  get designerOtp(): Prisma.DesignerOtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designerProfile`: Exposes CRUD operations for the **DesignerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignerProfiles
    * const designerProfiles = await prisma.designerProfile.findMany()
    * ```
    */
  get designerProfile(): Prisma.DesignerProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designerWork`: Exposes CRUD operations for the **DesignerWork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignerWorks
    * const designerWorks = await prisma.designerWork.findMany()
    * ```
    */
  get designerWork(): Prisma.DesignerWorkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designerHireRequest`: Exposes CRUD operations for the **DesignerHireRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignerHireRequests
    * const designerHireRequests = await prisma.designerHireRequest.findMany()
    * ```
    */
  get designerHireRequest(): Prisma.DesignerHireRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designerRating`: Exposes CRUD operations for the **DesignerRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignerRatings
    * const designerRatings = await prisma.designerRating.findMany()
    * ```
    */
  get designerRating(): Prisma.DesignerRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRating`: Exposes CRUD operations for the **UserRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRatings
    * const userRatings = await prisma.userRating.findMany()
    * ```
    */
  get userRating(): Prisma.UserRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnRequest`: Exposes CRUD operations for the **ReturnRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnRequests
    * const returnRequests = await prisma.returnRequest.findMany()
    * ```
    */
  get returnRequest(): Prisma.ReturnRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactMessage`: Exposes CRUD operations for the **ContactMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactMessages
    * const contactMessages = await prisma.contactMessage.findMany()
    * ```
    */
  get contactMessage(): Prisma.ContactMessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    CustomerOtp: 'CustomerOtp',
    Seller: 'Seller',
    SellerOtp: 'SellerOtp',
    SellerBusinessDetails: 'SellerBusinessDetails',
    SellerDeliveryDetails: 'SellerDeliveryDetails',
    SellerBankDetails: 'SellerBankDetails',
    Product: 'Product',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Rating: 'Rating',
    Designer: 'Designer',
    DesignerOtp: 'DesignerOtp',
    DesignerProfile: 'DesignerProfile',
    DesignerWork: 'DesignerWork',
    DesignerHireRequest: 'DesignerHireRequest',
    DesignerRating: 'DesignerRating',
    UserRating: 'UserRating',
    ReturnRequest: 'ReturnRequest',
    ContactMessage: 'ContactMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customerOtp" | "seller" | "sellerOtp" | "sellerBusinessDetails" | "sellerDeliveryDetails" | "sellerBankDetails" | "product" | "order" | "orderItem" | "rating" | "designer" | "designerOtp" | "designerProfile" | "designerWork" | "designerHireRequest" | "designerRating" | "userRating" | "returnRequest" | "contactMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CustomerOtp: {
        payload: Prisma.$CustomerOtpPayload<ExtArgs>
        fields: Prisma.CustomerOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          findFirst: {
            args: Prisma.CustomerOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          findMany: {
            args: Prisma.CustomerOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>[]
          }
          create: {
            args: Prisma.CustomerOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          createMany: {
            args: Prisma.CustomerOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>[]
          }
          delete: {
            args: Prisma.CustomerOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          update: {
            args: Prisma.CustomerOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          deleteMany: {
            args: Prisma.CustomerOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerOtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>[]
          }
          upsert: {
            args: Prisma.CustomerOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerOtpPayload>
          }
          aggregate: {
            args: Prisma.CustomerOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerOtp>
          }
          groupBy: {
            args: Prisma.CustomerOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerOtpCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerOtpCountAggregateOutputType> | number
          }
        }
      }
      Seller: {
        payload: Prisma.$SellerPayload<ExtArgs>
        fields: Prisma.SellerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findFirst: {
            args: Prisma.SellerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findMany: {
            args: Prisma.SellerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>[]
          }
          create: {
            args: Prisma.SellerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          createMany: {
            args: Prisma.SellerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>[]
          }
          delete: {
            args: Prisma.SellerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          update: {
            args: Prisma.SellerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          deleteMany: {
            args: Prisma.SellerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>[]
          }
          upsert: {
            args: Prisma.SellerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          aggregate: {
            args: Prisma.SellerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeller>
          }
          groupBy: {
            args: Prisma.SellerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerCountArgs<ExtArgs>
            result: $Utils.Optional<SellerCountAggregateOutputType> | number
          }
        }
      }
      SellerOtp: {
        payload: Prisma.$SellerOtpPayload<ExtArgs>
        fields: Prisma.SellerOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          findFirst: {
            args: Prisma.SellerOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          findMany: {
            args: Prisma.SellerOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>[]
          }
          create: {
            args: Prisma.SellerOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          createMany: {
            args: Prisma.SellerOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>[]
          }
          delete: {
            args: Prisma.SellerOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          update: {
            args: Prisma.SellerOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          deleteMany: {
            args: Prisma.SellerOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerOtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>[]
          }
          upsert: {
            args: Prisma.SellerOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerOtpPayload>
          }
          aggregate: {
            args: Prisma.SellerOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerOtp>
          }
          groupBy: {
            args: Prisma.SellerOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerOtpCountArgs<ExtArgs>
            result: $Utils.Optional<SellerOtpCountAggregateOutputType> | number
          }
        }
      }
      SellerBusinessDetails: {
        payload: Prisma.$SellerBusinessDetailsPayload<ExtArgs>
        fields: Prisma.SellerBusinessDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerBusinessDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerBusinessDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          findFirst: {
            args: Prisma.SellerBusinessDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerBusinessDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          findMany: {
            args: Prisma.SellerBusinessDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>[]
          }
          create: {
            args: Prisma.SellerBusinessDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          createMany: {
            args: Prisma.SellerBusinessDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerBusinessDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>[]
          }
          delete: {
            args: Prisma.SellerBusinessDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          update: {
            args: Prisma.SellerBusinessDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          deleteMany: {
            args: Prisma.SellerBusinessDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerBusinessDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerBusinessDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>[]
          }
          upsert: {
            args: Prisma.SellerBusinessDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBusinessDetailsPayload>
          }
          aggregate: {
            args: Prisma.SellerBusinessDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerBusinessDetails>
          }
          groupBy: {
            args: Prisma.SellerBusinessDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerBusinessDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerBusinessDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<SellerBusinessDetailsCountAggregateOutputType> | number
          }
        }
      }
      SellerDeliveryDetails: {
        payload: Prisma.$SellerDeliveryDetailsPayload<ExtArgs>
        fields: Prisma.SellerDeliveryDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerDeliveryDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerDeliveryDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          findFirst: {
            args: Prisma.SellerDeliveryDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerDeliveryDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          findMany: {
            args: Prisma.SellerDeliveryDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>[]
          }
          create: {
            args: Prisma.SellerDeliveryDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          createMany: {
            args: Prisma.SellerDeliveryDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerDeliveryDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>[]
          }
          delete: {
            args: Prisma.SellerDeliveryDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          update: {
            args: Prisma.SellerDeliveryDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          deleteMany: {
            args: Prisma.SellerDeliveryDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerDeliveryDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerDeliveryDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>[]
          }
          upsert: {
            args: Prisma.SellerDeliveryDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerDeliveryDetailsPayload>
          }
          aggregate: {
            args: Prisma.SellerDeliveryDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerDeliveryDetails>
          }
          groupBy: {
            args: Prisma.SellerDeliveryDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerDeliveryDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerDeliveryDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<SellerDeliveryDetailsCountAggregateOutputType> | number
          }
        }
      }
      SellerBankDetails: {
        payload: Prisma.$SellerBankDetailsPayload<ExtArgs>
        fields: Prisma.SellerBankDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerBankDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerBankDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          findFirst: {
            args: Prisma.SellerBankDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerBankDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          findMany: {
            args: Prisma.SellerBankDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>[]
          }
          create: {
            args: Prisma.SellerBankDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          createMany: {
            args: Prisma.SellerBankDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerBankDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>[]
          }
          delete: {
            args: Prisma.SellerBankDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          update: {
            args: Prisma.SellerBankDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.SellerBankDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerBankDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerBankDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>[]
          }
          upsert: {
            args: Prisma.SellerBankDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerBankDetailsPayload>
          }
          aggregate: {
            args: Prisma.SellerBankDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerBankDetails>
          }
          groupBy: {
            args: Prisma.SellerBankDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerBankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerBankDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<SellerBankDetailsCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Designer: {
        payload: Prisma.$DesignerPayload<ExtArgs>
        fields: Prisma.DesignerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          findFirst: {
            args: Prisma.DesignerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          findMany: {
            args: Prisma.DesignerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>[]
          }
          create: {
            args: Prisma.DesignerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          createMany: {
            args: Prisma.DesignerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>[]
          }
          delete: {
            args: Prisma.DesignerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          update: {
            args: Prisma.DesignerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          deleteMany: {
            args: Prisma.DesignerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>[]
          }
          upsert: {
            args: Prisma.DesignerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerPayload>
          }
          aggregate: {
            args: Prisma.DesignerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesigner>
          }
          groupBy: {
            args: Prisma.DesignerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerCountAggregateOutputType> | number
          }
        }
      }
      DesignerOtp: {
        payload: Prisma.$DesignerOtpPayload<ExtArgs>
        fields: Prisma.DesignerOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          findFirst: {
            args: Prisma.DesignerOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          findMany: {
            args: Prisma.DesignerOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>[]
          }
          create: {
            args: Prisma.DesignerOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          createMany: {
            args: Prisma.DesignerOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>[]
          }
          delete: {
            args: Prisma.DesignerOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          update: {
            args: Prisma.DesignerOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          deleteMany: {
            args: Prisma.DesignerOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerOtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>[]
          }
          upsert: {
            args: Prisma.DesignerOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerOtpPayload>
          }
          aggregate: {
            args: Prisma.DesignerOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignerOtp>
          }
          groupBy: {
            args: Prisma.DesignerOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerOtpCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerOtpCountAggregateOutputType> | number
          }
        }
      }
      DesignerProfile: {
        payload: Prisma.$DesignerProfilePayload<ExtArgs>
        fields: Prisma.DesignerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          findFirst: {
            args: Prisma.DesignerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          findMany: {
            args: Prisma.DesignerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>[]
          }
          create: {
            args: Prisma.DesignerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          createMany: {
            args: Prisma.DesignerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>[]
          }
          delete: {
            args: Prisma.DesignerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          update: {
            args: Prisma.DesignerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          deleteMany: {
            args: Prisma.DesignerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>[]
          }
          upsert: {
            args: Prisma.DesignerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerProfilePayload>
          }
          aggregate: {
            args: Prisma.DesignerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignerProfile>
          }
          groupBy: {
            args: Prisma.DesignerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerProfileCountAggregateOutputType> | number
          }
        }
      }
      DesignerWork: {
        payload: Prisma.$DesignerWorkPayload<ExtArgs>
        fields: Prisma.DesignerWorkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerWorkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerWorkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          findFirst: {
            args: Prisma.DesignerWorkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerWorkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          findMany: {
            args: Prisma.DesignerWorkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>[]
          }
          create: {
            args: Prisma.DesignerWorkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          createMany: {
            args: Prisma.DesignerWorkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerWorkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>[]
          }
          delete: {
            args: Prisma.DesignerWorkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          update: {
            args: Prisma.DesignerWorkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          deleteMany: {
            args: Prisma.DesignerWorkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerWorkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerWorkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>[]
          }
          upsert: {
            args: Prisma.DesignerWorkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerWorkPayload>
          }
          aggregate: {
            args: Prisma.DesignerWorkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignerWork>
          }
          groupBy: {
            args: Prisma.DesignerWorkGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerWorkGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerWorkCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerWorkCountAggregateOutputType> | number
          }
        }
      }
      DesignerHireRequest: {
        payload: Prisma.$DesignerHireRequestPayload<ExtArgs>
        fields: Prisma.DesignerHireRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerHireRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerHireRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          findFirst: {
            args: Prisma.DesignerHireRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerHireRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          findMany: {
            args: Prisma.DesignerHireRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>[]
          }
          create: {
            args: Prisma.DesignerHireRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          createMany: {
            args: Prisma.DesignerHireRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerHireRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>[]
          }
          delete: {
            args: Prisma.DesignerHireRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          update: {
            args: Prisma.DesignerHireRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          deleteMany: {
            args: Prisma.DesignerHireRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerHireRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerHireRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>[]
          }
          upsert: {
            args: Prisma.DesignerHireRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerHireRequestPayload>
          }
          aggregate: {
            args: Prisma.DesignerHireRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignerHireRequest>
          }
          groupBy: {
            args: Prisma.DesignerHireRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerHireRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerHireRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerHireRequestCountAggregateOutputType> | number
          }
        }
      }
      DesignerRating: {
        payload: Prisma.$DesignerRatingPayload<ExtArgs>
        fields: Prisma.DesignerRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignerRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignerRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          findFirst: {
            args: Prisma.DesignerRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignerRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          findMany: {
            args: Prisma.DesignerRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>[]
          }
          create: {
            args: Prisma.DesignerRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          createMany: {
            args: Prisma.DesignerRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignerRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>[]
          }
          delete: {
            args: Prisma.DesignerRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          update: {
            args: Prisma.DesignerRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          deleteMany: {
            args: Prisma.DesignerRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignerRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignerRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>[]
          }
          upsert: {
            args: Prisma.DesignerRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignerRatingPayload>
          }
          aggregate: {
            args: Prisma.DesignerRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignerRating>
          }
          groupBy: {
            args: Prisma.DesignerRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignerRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignerRatingCountArgs<ExtArgs>
            result: $Utils.Optional<DesignerRatingCountAggregateOutputType> | number
          }
        }
      }
      UserRating: {
        payload: Prisma.$UserRatingPayload<ExtArgs>
        fields: Prisma.UserRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          findFirst: {
            args: Prisma.UserRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          findMany: {
            args: Prisma.UserRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>[]
          }
          create: {
            args: Prisma.UserRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          createMany: {
            args: Prisma.UserRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>[]
          }
          delete: {
            args: Prisma.UserRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          update: {
            args: Prisma.UserRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          deleteMany: {
            args: Prisma.UserRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>[]
          }
          upsert: {
            args: Prisma.UserRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          aggregate: {
            args: Prisma.UserRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRating>
          }
          groupBy: {
            args: Prisma.UserRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRatingCountArgs<ExtArgs>
            result: $Utils.Optional<UserRatingCountAggregateOutputType> | number
          }
        }
      }
      ReturnRequest: {
        payload: Prisma.$ReturnRequestPayload<ExtArgs>
        fields: Prisma.ReturnRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          findFirst: {
            args: Prisma.ReturnRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          findMany: {
            args: Prisma.ReturnRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[]
          }
          create: {
            args: Prisma.ReturnRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          createMany: {
            args: Prisma.ReturnRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[]
          }
          delete: {
            args: Prisma.ReturnRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          update: {
            args: Prisma.ReturnRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          deleteMany: {
            args: Prisma.ReturnRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[]
          }
          upsert: {
            args: Prisma.ReturnRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          aggregate: {
            args: Prisma.ReturnRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnRequest>
          }
          groupBy: {
            args: Prisma.ReturnRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnRequestCountAggregateOutputType> | number
          }
        }
      }
      ContactMessage: {
        payload: Prisma.$ContactMessagePayload<ExtArgs>
        fields: Prisma.ContactMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findFirst: {
            args: Prisma.ContactMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findMany: {
            args: Prisma.ContactMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          create: {
            args: Prisma.ContactMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          createMany: {
            args: Prisma.ContactMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          delete: {
            args: Prisma.ContactMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          update: {
            args: Prisma.ContactMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          deleteMany: {
            args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          upsert: {
            args: Prisma.ContactMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          aggregate: {
            args: Prisma.ContactMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactMessage>
          }
          groupBy: {
            args: Prisma.ContactMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customerOtp?: CustomerOtpOmit
    seller?: SellerOmit
    sellerOtp?: SellerOtpOmit
    sellerBusinessDetails?: SellerBusinessDetailsOmit
    sellerDeliveryDetails?: SellerDeliveryDetailsOmit
    sellerBankDetails?: SellerBankDetailsOmit
    product?: ProductOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    rating?: RatingOmit
    designer?: DesignerOmit
    designerOtp?: DesignerOtpOmit
    designerProfile?: DesignerProfileOmit
    designerWork?: DesignerWorkOmit
    designerHireRequest?: DesignerHireRequestOmit
    designerRating?: DesignerRatingOmit
    userRating?: UserRatingOmit
    returnRequest?: ReturnRequestOmit
    contactMessage?: ContactMessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    ratings: number
    hireRequests: number
    returnRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    hireRequests?: boolean | UserCountOutputTypeCountHireRequestsArgs
    returnRequests?: boolean | UserCountOutputTypeCountReturnRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHireRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerHireRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReturnRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnRequestWhereInput
  }


  /**
   * Count Type SellerCountOutputType
   */

  export type SellerCountOutputType = {
    orderItems: number
    products: number
  }

  export type SellerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | SellerCountOutputTypeCountOrderItemsArgs
    products?: boolean | SellerCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SellerCountOutputType without action
   */
  export type SellerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerCountOutputType
     */
    select?: SellerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellerCountOutputType without action
   */
  export type SellerCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * SellerCountOutputType without action
   */
  export type SellerCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    ratings: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | ProductCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type DesignerCountOutputType
   */

  export type DesignerCountOutputType = {
    works: number
    hireRequests: number
    ratings: number
    userRatings: number
  }

  export type DesignerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    works?: boolean | DesignerCountOutputTypeCountWorksArgs
    hireRequests?: boolean | DesignerCountOutputTypeCountHireRequestsArgs
    ratings?: boolean | DesignerCountOutputTypeCountRatingsArgs
    userRatings?: boolean | DesignerCountOutputTypeCountUserRatingsArgs
  }

  // Custom InputTypes
  /**
   * DesignerCountOutputType without action
   */
  export type DesignerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerCountOutputType
     */
    select?: DesignerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DesignerCountOutputType without action
   */
  export type DesignerCountOutputTypeCountWorksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerWorkWhereInput
  }

  /**
   * DesignerCountOutputType without action
   */
  export type DesignerCountOutputTypeCountHireRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerHireRequestWhereInput
  }

  /**
   * DesignerCountOutputType without action
   */
  export type DesignerCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerRatingWhereInput
  }

  /**
   * DesignerCountOutputType without action
   */
  export type DesignerCountOutputTypeCountUserRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    credit: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    credit: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    credit: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    credit: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    phone: number
    address: number
    createdAt: number
    credit: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    credit?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    credit?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    address?: true
    createdAt?: true
    credit?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    address?: true
    createdAt?: true
    credit?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    address?: true
    createdAt?: true
    credit?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    phone: string | null
    address: string | null
    createdAt: Date
    credit: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    credit?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    hireRequests?: boolean | User$hireRequestsArgs<ExtArgs>
    returnRequests?: boolean | User$returnRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    credit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    credit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    credit?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "phone" | "address" | "createdAt" | "credit", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    hireRequests?: boolean | User$hireRequestsArgs<ExtArgs>
    returnRequests?: boolean | User$returnRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      hireRequests: Prisma.$DesignerHireRequestPayload<ExtArgs>[]
      returnRequests: Prisma.$ReturnRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      phone: string | null
      address: string | null
      createdAt: Date
      credit: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hireRequests<T extends User$hireRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$hireRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnRequests<T extends User$returnRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$returnRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly credit: FieldRef<"User", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * User.hireRequests
   */
  export type User$hireRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    where?: DesignerHireRequestWhereInput
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    cursor?: DesignerHireRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignerHireRequestScalarFieldEnum | DesignerHireRequestScalarFieldEnum[]
  }

  /**
   * User.returnRequests
   */
  export type User$returnRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    where?: ReturnRequestWhereInput
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    cursor?: ReturnRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CustomerOtp
   */

  export type AggregateCustomerOtp = {
    _count: CustomerOtpCountAggregateOutputType | null
    _min: CustomerOtpMinAggregateOutputType | null
    _max: CustomerOtpMaxAggregateOutputType | null
  }

  export type CustomerOtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type CustomerOtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type CustomerOtpCountAggregateOutputType = {
    id: number
    email: number
    otpHash: number
    expiresAt: number
    verified: number
    createdAt: number
    _all: number
  }


  export type CustomerOtpMinAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type CustomerOtpMaxAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type CustomerOtpCountAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerOtp to aggregate.
     */
    where?: CustomerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOtps to fetch.
     */
    orderBy?: CustomerOtpOrderByWithRelationInput | CustomerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerOtps
    **/
    _count?: true | CustomerOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerOtpMaxAggregateInputType
  }

  export type GetCustomerOtpAggregateType<T extends CustomerOtpAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerOtp[P]>
      : GetScalarType<T[P], AggregateCustomerOtp[P]>
  }




  export type CustomerOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerOtpWhereInput
    orderBy?: CustomerOtpOrderByWithAggregationInput | CustomerOtpOrderByWithAggregationInput[]
    by: CustomerOtpScalarFieldEnum[] | CustomerOtpScalarFieldEnum
    having?: CustomerOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerOtpCountAggregateInputType | true
    _min?: CustomerOtpMinAggregateInputType
    _max?: CustomerOtpMaxAggregateInputType
  }

  export type CustomerOtpGroupByOutputType = {
    id: string
    email: string
    otpHash: string
    expiresAt: Date
    verified: boolean
    createdAt: Date
    _count: CustomerOtpCountAggregateOutputType | null
    _min: CustomerOtpMinAggregateOutputType | null
    _max: CustomerOtpMaxAggregateOutputType | null
  }

  type GetCustomerOtpGroupByPayload<T extends CustomerOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerOtpGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerOtpGroupByOutputType[P]>
        }
      >
    >


  export type CustomerOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customerOtp"]>

  export type CustomerOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customerOtp"]>

  export type CustomerOtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customerOtp"]>

  export type CustomerOtpSelectScalar = {
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type CustomerOtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otpHash" | "expiresAt" | "verified" | "createdAt", ExtArgs["result"]["customerOtp"]>

  export type $CustomerOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerOtp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otpHash: string
      expiresAt: Date
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["customerOtp"]>
    composites: {}
  }

  type CustomerOtpGetPayload<S extends boolean | null | undefined | CustomerOtpDefaultArgs> = $Result.GetResult<Prisma.$CustomerOtpPayload, S>

  type CustomerOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerOtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerOtpCountAggregateInputType | true
    }

  export interface CustomerOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerOtp'], meta: { name: 'CustomerOtp' } }
    /**
     * Find zero or one CustomerOtp that matches the filter.
     * @param {CustomerOtpFindUniqueArgs} args - Arguments to find a CustomerOtp
     * @example
     * // Get one CustomerOtp
     * const customerOtp = await prisma.customerOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerOtpFindUniqueArgs>(args: SelectSubset<T, CustomerOtpFindUniqueArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerOtp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerOtpFindUniqueOrThrowArgs} args - Arguments to find a CustomerOtp
     * @example
     * // Get one CustomerOtp
     * const customerOtp = await prisma.customerOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpFindFirstArgs} args - Arguments to find a CustomerOtp
     * @example
     * // Get one CustomerOtp
     * const customerOtp = await prisma.customerOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerOtpFindFirstArgs>(args?: SelectSubset<T, CustomerOtpFindFirstArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpFindFirstOrThrowArgs} args - Arguments to find a CustomerOtp
     * @example
     * // Get one CustomerOtp
     * const customerOtp = await prisma.customerOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerOtps
     * const customerOtps = await prisma.customerOtp.findMany()
     * 
     * // Get first 10 CustomerOtps
     * const customerOtps = await prisma.customerOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerOtpWithIdOnly = await prisma.customerOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerOtpFindManyArgs>(args?: SelectSubset<T, CustomerOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerOtp.
     * @param {CustomerOtpCreateArgs} args - Arguments to create a CustomerOtp.
     * @example
     * // Create one CustomerOtp
     * const CustomerOtp = await prisma.customerOtp.create({
     *   data: {
     *     // ... data to create a CustomerOtp
     *   }
     * })
     * 
     */
    create<T extends CustomerOtpCreateArgs>(args: SelectSubset<T, CustomerOtpCreateArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerOtps.
     * @param {CustomerOtpCreateManyArgs} args - Arguments to create many CustomerOtps.
     * @example
     * // Create many CustomerOtps
     * const customerOtp = await prisma.customerOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerOtpCreateManyArgs>(args?: SelectSubset<T, CustomerOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerOtps and returns the data saved in the database.
     * @param {CustomerOtpCreateManyAndReturnArgs} args - Arguments to create many CustomerOtps.
     * @example
     * // Create many CustomerOtps
     * const customerOtp = await prisma.customerOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerOtps and only return the `id`
     * const customerOtpWithIdOnly = await prisma.customerOtp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerOtp.
     * @param {CustomerOtpDeleteArgs} args - Arguments to delete one CustomerOtp.
     * @example
     * // Delete one CustomerOtp
     * const CustomerOtp = await prisma.customerOtp.delete({
     *   where: {
     *     // ... filter to delete one CustomerOtp
     *   }
     * })
     * 
     */
    delete<T extends CustomerOtpDeleteArgs>(args: SelectSubset<T, CustomerOtpDeleteArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerOtp.
     * @param {CustomerOtpUpdateArgs} args - Arguments to update one CustomerOtp.
     * @example
     * // Update one CustomerOtp
     * const customerOtp = await prisma.customerOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerOtpUpdateArgs>(args: SelectSubset<T, CustomerOtpUpdateArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerOtps.
     * @param {CustomerOtpDeleteManyArgs} args - Arguments to filter CustomerOtps to delete.
     * @example
     * // Delete a few CustomerOtps
     * const { count } = await prisma.customerOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerOtpDeleteManyArgs>(args?: SelectSubset<T, CustomerOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerOtps
     * const customerOtp = await prisma.customerOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerOtpUpdateManyArgs>(args: SelectSubset<T, CustomerOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerOtps and returns the data updated in the database.
     * @param {CustomerOtpUpdateManyAndReturnArgs} args - Arguments to update many CustomerOtps.
     * @example
     * // Update many CustomerOtps
     * const customerOtp = await prisma.customerOtp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerOtps and only return the `id`
     * const customerOtpWithIdOnly = await prisma.customerOtp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerOtpUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerOtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerOtp.
     * @param {CustomerOtpUpsertArgs} args - Arguments to update or create a CustomerOtp.
     * @example
     * // Update or create a CustomerOtp
     * const customerOtp = await prisma.customerOtp.upsert({
     *   create: {
     *     // ... data to create a CustomerOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerOtp we want to update
     *   }
     * })
     */
    upsert<T extends CustomerOtpUpsertArgs>(args: SelectSubset<T, CustomerOtpUpsertArgs<ExtArgs>>): Prisma__CustomerOtpClient<$Result.GetResult<Prisma.$CustomerOtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpCountArgs} args - Arguments to filter CustomerOtps to count.
     * @example
     * // Count the number of CustomerOtps
     * const count = await prisma.customerOtp.count({
     *   where: {
     *     // ... the filter for the CustomerOtps we want to count
     *   }
     * })
    **/
    count<T extends CustomerOtpCountArgs>(
      args?: Subset<T, CustomerOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerOtpAggregateArgs>(args: Subset<T, CustomerOtpAggregateArgs>): Prisma.PrismaPromise<GetCustomerOtpAggregateType<T>>

    /**
     * Group by CustomerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerOtpGroupByArgs['orderBy'] }
        : { orderBy?: CustomerOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerOtp model
   */
  readonly fields: CustomerOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerOtp model
   */
  interface CustomerOtpFieldRefs {
    readonly id: FieldRef<"CustomerOtp", 'String'>
    readonly email: FieldRef<"CustomerOtp", 'String'>
    readonly otpHash: FieldRef<"CustomerOtp", 'String'>
    readonly expiresAt: FieldRef<"CustomerOtp", 'DateTime'>
    readonly verified: FieldRef<"CustomerOtp", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerOtp findUnique
   */
  export type CustomerOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter, which CustomerOtp to fetch.
     */
    where: CustomerOtpWhereUniqueInput
  }

  /**
   * CustomerOtp findUniqueOrThrow
   */
  export type CustomerOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter, which CustomerOtp to fetch.
     */
    where: CustomerOtpWhereUniqueInput
  }

  /**
   * CustomerOtp findFirst
   */
  export type CustomerOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter, which CustomerOtp to fetch.
     */
    where?: CustomerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOtps to fetch.
     */
    orderBy?: CustomerOtpOrderByWithRelationInput | CustomerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerOtps.
     */
    cursor?: CustomerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerOtps.
     */
    distinct?: CustomerOtpScalarFieldEnum | CustomerOtpScalarFieldEnum[]
  }

  /**
   * CustomerOtp findFirstOrThrow
   */
  export type CustomerOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter, which CustomerOtp to fetch.
     */
    where?: CustomerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOtps to fetch.
     */
    orderBy?: CustomerOtpOrderByWithRelationInput | CustomerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerOtps.
     */
    cursor?: CustomerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerOtps.
     */
    distinct?: CustomerOtpScalarFieldEnum | CustomerOtpScalarFieldEnum[]
  }

  /**
   * CustomerOtp findMany
   */
  export type CustomerOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter, which CustomerOtps to fetch.
     */
    where?: CustomerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerOtps to fetch.
     */
    orderBy?: CustomerOtpOrderByWithRelationInput | CustomerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerOtps.
     */
    cursor?: CustomerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerOtps.
     */
    skip?: number
    distinct?: CustomerOtpScalarFieldEnum | CustomerOtpScalarFieldEnum[]
  }

  /**
   * CustomerOtp create
   */
  export type CustomerOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * The data needed to create a CustomerOtp.
     */
    data: XOR<CustomerOtpCreateInput, CustomerOtpUncheckedCreateInput>
  }

  /**
   * CustomerOtp createMany
   */
  export type CustomerOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerOtps.
     */
    data: CustomerOtpCreateManyInput | CustomerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerOtp createManyAndReturn
   */
  export type CustomerOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerOtps.
     */
    data: CustomerOtpCreateManyInput | CustomerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerOtp update
   */
  export type CustomerOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * The data needed to update a CustomerOtp.
     */
    data: XOR<CustomerOtpUpdateInput, CustomerOtpUncheckedUpdateInput>
    /**
     * Choose, which CustomerOtp to update.
     */
    where: CustomerOtpWhereUniqueInput
  }

  /**
   * CustomerOtp updateMany
   */
  export type CustomerOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerOtps.
     */
    data: XOR<CustomerOtpUpdateManyMutationInput, CustomerOtpUncheckedUpdateManyInput>
    /**
     * Filter which CustomerOtps to update
     */
    where?: CustomerOtpWhereInput
    /**
     * Limit how many CustomerOtps to update.
     */
    limit?: number
  }

  /**
   * CustomerOtp updateManyAndReturn
   */
  export type CustomerOtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * The data used to update CustomerOtps.
     */
    data: XOR<CustomerOtpUpdateManyMutationInput, CustomerOtpUncheckedUpdateManyInput>
    /**
     * Filter which CustomerOtps to update
     */
    where?: CustomerOtpWhereInput
    /**
     * Limit how many CustomerOtps to update.
     */
    limit?: number
  }

  /**
   * CustomerOtp upsert
   */
  export type CustomerOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * The filter to search for the CustomerOtp to update in case it exists.
     */
    where: CustomerOtpWhereUniqueInput
    /**
     * In case the CustomerOtp found by the `where` argument doesn't exist, create a new CustomerOtp with this data.
     */
    create: XOR<CustomerOtpCreateInput, CustomerOtpUncheckedCreateInput>
    /**
     * In case the CustomerOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerOtpUpdateInput, CustomerOtpUncheckedUpdateInput>
  }

  /**
   * CustomerOtp delete
   */
  export type CustomerOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
    /**
     * Filter which CustomerOtp to delete.
     */
    where: CustomerOtpWhereUniqueInput
  }

  /**
   * CustomerOtp deleteMany
   */
  export type CustomerOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerOtps to delete
     */
    where?: CustomerOtpWhereInput
    /**
     * Limit how many CustomerOtps to delete.
     */
    limit?: number
  }

  /**
   * CustomerOtp without action
   */
  export type CustomerOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerOtp
     */
    select?: CustomerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerOtp
     */
    omit?: CustomerOtpOmit<ExtArgs> | null
  }


  /**
   * Model Seller
   */

  export type AggregateSeller = {
    _count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  export type SellerAvgAggregateOutputType = {
    id: number | null
  }

  export type SellerSumAggregateOutputType = {
    id: number | null
  }

  export type SellerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    phoneVerified: boolean | null
    createdAt: Date | null
  }

  export type SellerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    phoneVerified: boolean | null
    createdAt: Date | null
  }

  export type SellerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    phoneVerified: number
    createdAt: number
    _all: number
  }


  export type SellerAvgAggregateInputType = {
    id?: true
  }

  export type SellerSumAggregateInputType = {
    id?: true
  }

  export type SellerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    phoneVerified?: true
    createdAt?: true
  }

  export type SellerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    phoneVerified?: true
    createdAt?: true
  }

  export type SellerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    phoneVerified?: true
    createdAt?: true
    _all?: true
  }

  export type SellerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seller to aggregate.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sellers
    **/
    _count?: true | SellerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerMaxAggregateInputType
  }

  export type GetSellerAggregateType<T extends SellerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeller[P]>
      : GetScalarType<T[P], AggregateSeller[P]>
  }




  export type SellerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerWhereInput
    orderBy?: SellerOrderByWithAggregationInput | SellerOrderByWithAggregationInput[]
    by: SellerScalarFieldEnum[] | SellerScalarFieldEnum
    having?: SellerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerCountAggregateInputType | true
    _avg?: SellerAvgAggregateInputType
    _sum?: SellerSumAggregateInputType
    _min?: SellerMinAggregateInputType
    _max?: SellerMaxAggregateInputType
  }

  export type SellerGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified: boolean
    createdAt: Date
    _count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  type GetSellerGroupByPayload<T extends SellerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerGroupByOutputType[P]>
            : GetScalarType<T[P], SellerGroupByOutputType[P]>
        }
      >
    >


  export type SellerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phoneVerified?: boolean
    createdAt?: boolean
    orderItems?: boolean | Seller$orderItemsArgs<ExtArgs>
    products?: boolean | Seller$productsArgs<ExtArgs>
    business?: boolean | Seller$businessArgs<ExtArgs>
    delivery?: boolean | Seller$deliveryArgs<ExtArgs>
    bank?: boolean | Seller$bankArgs<ExtArgs>
    _count?: boolean | SellerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seller"]>

  export type SellerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phoneVerified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["seller"]>

  export type SellerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phoneVerified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["seller"]>

  export type SellerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    phoneVerified?: boolean
    createdAt?: boolean
  }

  export type SellerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "phoneVerified" | "createdAt", ExtArgs["result"]["seller"]>
  export type SellerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Seller$orderItemsArgs<ExtArgs>
    products?: boolean | Seller$productsArgs<ExtArgs>
    business?: boolean | Seller$businessArgs<ExtArgs>
    delivery?: boolean | Seller$deliveryArgs<ExtArgs>
    bank?: boolean | Seller$bankArgs<ExtArgs>
    _count?: boolean | SellerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SellerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SellerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SellerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seller"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      business: Prisma.$SellerBusinessDetailsPayload<ExtArgs> | null
      delivery: Prisma.$SellerDeliveryDetailsPayload<ExtArgs> | null
      bank: Prisma.$SellerBankDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      password: string
      phoneVerified: boolean
      createdAt: Date
    }, ExtArgs["result"]["seller"]>
    composites: {}
  }

  type SellerGetPayload<S extends boolean | null | undefined | SellerDefaultArgs> = $Result.GetResult<Prisma.$SellerPayload, S>

  type SellerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerCountAggregateInputType | true
    }

  export interface SellerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seller'], meta: { name: 'Seller' } }
    /**
     * Find zero or one Seller that matches the filter.
     * @param {SellerFindUniqueArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerFindUniqueArgs>(args: SelectSubset<T, SellerFindUniqueArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seller that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerFindUniqueOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerFindFirstArgs>(args?: SelectSubset<T, SellerFindFirstArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sellers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sellers
     * const sellers = await prisma.seller.findMany()
     * 
     * // Get first 10 Sellers
     * const sellers = await prisma.seller.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerWithIdOnly = await prisma.seller.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerFindManyArgs>(args?: SelectSubset<T, SellerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seller.
     * @param {SellerCreateArgs} args - Arguments to create a Seller.
     * @example
     * // Create one Seller
     * const Seller = await prisma.seller.create({
     *   data: {
     *     // ... data to create a Seller
     *   }
     * })
     * 
     */
    create<T extends SellerCreateArgs>(args: SelectSubset<T, SellerCreateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sellers.
     * @param {SellerCreateManyArgs} args - Arguments to create many Sellers.
     * @example
     * // Create many Sellers
     * const seller = await prisma.seller.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerCreateManyArgs>(args?: SelectSubset<T, SellerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sellers and returns the data saved in the database.
     * @param {SellerCreateManyAndReturnArgs} args - Arguments to create many Sellers.
     * @example
     * // Create many Sellers
     * const seller = await prisma.seller.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sellers and only return the `id`
     * const sellerWithIdOnly = await prisma.seller.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Seller.
     * @param {SellerDeleteArgs} args - Arguments to delete one Seller.
     * @example
     * // Delete one Seller
     * const Seller = await prisma.seller.delete({
     *   where: {
     *     // ... filter to delete one Seller
     *   }
     * })
     * 
     */
    delete<T extends SellerDeleteArgs>(args: SelectSubset<T, SellerDeleteArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seller.
     * @param {SellerUpdateArgs} args - Arguments to update one Seller.
     * @example
     * // Update one Seller
     * const seller = await prisma.seller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerUpdateArgs>(args: SelectSubset<T, SellerUpdateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sellers.
     * @param {SellerDeleteManyArgs} args - Arguments to filter Sellers to delete.
     * @example
     * // Delete a few Sellers
     * const { count } = await prisma.seller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerDeleteManyArgs>(args?: SelectSubset<T, SellerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sellers
     * const seller = await prisma.seller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerUpdateManyArgs>(args: SelectSubset<T, SellerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sellers and returns the data updated in the database.
     * @param {SellerUpdateManyAndReturnArgs} args - Arguments to update many Sellers.
     * @example
     * // Update many Sellers
     * const seller = await prisma.seller.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sellers and only return the `id`
     * const sellerWithIdOnly = await prisma.seller.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Seller.
     * @param {SellerUpsertArgs} args - Arguments to update or create a Seller.
     * @example
     * // Update or create a Seller
     * const seller = await prisma.seller.upsert({
     *   create: {
     *     // ... data to create a Seller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seller we want to update
     *   }
     * })
     */
    upsert<T extends SellerUpsertArgs>(args: SelectSubset<T, SellerUpsertArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerCountArgs} args - Arguments to filter Sellers to count.
     * @example
     * // Count the number of Sellers
     * const count = await prisma.seller.count({
     *   where: {
     *     // ... the filter for the Sellers we want to count
     *   }
     * })
    **/
    count<T extends SellerCountArgs>(
      args?: Subset<T, SellerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerAggregateArgs>(args: Subset<T, SellerAggregateArgs>): Prisma.PrismaPromise<GetSellerAggregateType<T>>

    /**
     * Group by Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerGroupByArgs['orderBy'] }
        : { orderBy?: SellerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seller model
   */
  readonly fields: SellerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Seller$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Seller$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Seller$productsArgs<ExtArgs> = {}>(args?: Subset<T, Seller$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business<T extends Seller$businessArgs<ExtArgs> = {}>(args?: Subset<T, Seller$businessArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    delivery<T extends Seller$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, Seller$deliveryArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bank<T extends Seller$bankArgs<ExtArgs> = {}>(args?: Subset<T, Seller$bankArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seller model
   */
  interface SellerFieldRefs {
    readonly id: FieldRef<"Seller", 'Int'>
    readonly name: FieldRef<"Seller", 'String'>
    readonly email: FieldRef<"Seller", 'String'>
    readonly phone: FieldRef<"Seller", 'String'>
    readonly password: FieldRef<"Seller", 'String'>
    readonly phoneVerified: FieldRef<"Seller", 'Boolean'>
    readonly createdAt: FieldRef<"Seller", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Seller findUnique
   */
  export type SellerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findUniqueOrThrow
   */
  export type SellerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findFirst
   */
  export type SellerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findFirstOrThrow
   */
  export type SellerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findMany
   */
  export type SellerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Sellers to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller create
   */
  export type SellerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to create a Seller.
     */
    data: XOR<SellerCreateInput, SellerUncheckedCreateInput>
  }

  /**
   * Seller createMany
   */
  export type SellerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sellers.
     */
    data: SellerCreateManyInput | SellerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seller createManyAndReturn
   */
  export type SellerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * The data used to create many Sellers.
     */
    data: SellerCreateManyInput | SellerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seller update
   */
  export type SellerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to update a Seller.
     */
    data: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
    /**
     * Choose, which Seller to update.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller updateMany
   */
  export type SellerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sellers.
     */
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyInput>
    /**
     * Filter which Sellers to update
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to update.
     */
    limit?: number
  }

  /**
   * Seller updateManyAndReturn
   */
  export type SellerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * The data used to update Sellers.
     */
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyInput>
    /**
     * Filter which Sellers to update
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to update.
     */
    limit?: number
  }

  /**
   * Seller upsert
   */
  export type SellerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The filter to search for the Seller to update in case it exists.
     */
    where: SellerWhereUniqueInput
    /**
     * In case the Seller found by the `where` argument doesn't exist, create a new Seller with this data.
     */
    create: XOR<SellerCreateInput, SellerUncheckedCreateInput>
    /**
     * In case the Seller was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
  }

  /**
   * Seller delete
   */
  export type SellerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter which Seller to delete.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller deleteMany
   */
  export type SellerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sellers to delete
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to delete.
     */
    limit?: number
  }

  /**
   * Seller.orderItems
   */
  export type Seller$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Seller.products
   */
  export type Seller$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Seller.business
   */
  export type Seller$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    where?: SellerBusinessDetailsWhereInput
  }

  /**
   * Seller.delivery
   */
  export type Seller$deliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    where?: SellerDeliveryDetailsWhereInput
  }

  /**
   * Seller.bank
   */
  export type Seller$bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    where?: SellerBankDetailsWhereInput
  }

  /**
   * Seller without action
   */
  export type SellerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
  }


  /**
   * Model SellerOtp
   */

  export type AggregateSellerOtp = {
    _count: SellerOtpCountAggregateOutputType | null
    _min: SellerOtpMinAggregateOutputType | null
    _max: SellerOtpMaxAggregateOutputType | null
  }

  export type SellerOtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type SellerOtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type SellerOtpCountAggregateOutputType = {
    id: number
    email: number
    otpHash: number
    expiresAt: number
    verified: number
    createdAt: number
    _all: number
  }


  export type SellerOtpMinAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type SellerOtpMaxAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type SellerOtpCountAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type SellerOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerOtp to aggregate.
     */
    where?: SellerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerOtps to fetch.
     */
    orderBy?: SellerOtpOrderByWithRelationInput | SellerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerOtps
    **/
    _count?: true | SellerOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerOtpMaxAggregateInputType
  }

  export type GetSellerOtpAggregateType<T extends SellerOtpAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerOtp[P]>
      : GetScalarType<T[P], AggregateSellerOtp[P]>
  }




  export type SellerOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerOtpWhereInput
    orderBy?: SellerOtpOrderByWithAggregationInput | SellerOtpOrderByWithAggregationInput[]
    by: SellerOtpScalarFieldEnum[] | SellerOtpScalarFieldEnum
    having?: SellerOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerOtpCountAggregateInputType | true
    _min?: SellerOtpMinAggregateInputType
    _max?: SellerOtpMaxAggregateInputType
  }

  export type SellerOtpGroupByOutputType = {
    id: string
    email: string
    otpHash: string
    expiresAt: Date
    verified: boolean
    createdAt: Date
    _count: SellerOtpCountAggregateOutputType | null
    _min: SellerOtpMinAggregateOutputType | null
    _max: SellerOtpMaxAggregateOutputType | null
  }

  type GetSellerOtpGroupByPayload<T extends SellerOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerOtpGroupByOutputType[P]>
            : GetScalarType<T[P], SellerOtpGroupByOutputType[P]>
        }
      >
    >


  export type SellerOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellerOtp"]>

  export type SellerOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellerOtp"]>

  export type SellerOtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellerOtp"]>

  export type SellerOtpSelectScalar = {
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type SellerOtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otpHash" | "expiresAt" | "verified" | "createdAt", ExtArgs["result"]["sellerOtp"]>

  export type $SellerOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerOtp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otpHash: string
      expiresAt: Date
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["sellerOtp"]>
    composites: {}
  }

  type SellerOtpGetPayload<S extends boolean | null | undefined | SellerOtpDefaultArgs> = $Result.GetResult<Prisma.$SellerOtpPayload, S>

  type SellerOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerOtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerOtpCountAggregateInputType | true
    }

  export interface SellerOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerOtp'], meta: { name: 'SellerOtp' } }
    /**
     * Find zero or one SellerOtp that matches the filter.
     * @param {SellerOtpFindUniqueArgs} args - Arguments to find a SellerOtp
     * @example
     * // Get one SellerOtp
     * const sellerOtp = await prisma.sellerOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerOtpFindUniqueArgs>(args: SelectSubset<T, SellerOtpFindUniqueArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerOtp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerOtpFindUniqueOrThrowArgs} args - Arguments to find a SellerOtp
     * @example
     * // Get one SellerOtp
     * const sellerOtp = await prisma.sellerOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpFindFirstArgs} args - Arguments to find a SellerOtp
     * @example
     * // Get one SellerOtp
     * const sellerOtp = await prisma.sellerOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerOtpFindFirstArgs>(args?: SelectSubset<T, SellerOtpFindFirstArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpFindFirstOrThrowArgs} args - Arguments to find a SellerOtp
     * @example
     * // Get one SellerOtp
     * const sellerOtp = await prisma.sellerOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerOtps
     * const sellerOtps = await prisma.sellerOtp.findMany()
     * 
     * // Get first 10 SellerOtps
     * const sellerOtps = await prisma.sellerOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerOtpWithIdOnly = await prisma.sellerOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerOtpFindManyArgs>(args?: SelectSubset<T, SellerOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerOtp.
     * @param {SellerOtpCreateArgs} args - Arguments to create a SellerOtp.
     * @example
     * // Create one SellerOtp
     * const SellerOtp = await prisma.sellerOtp.create({
     *   data: {
     *     // ... data to create a SellerOtp
     *   }
     * })
     * 
     */
    create<T extends SellerOtpCreateArgs>(args: SelectSubset<T, SellerOtpCreateArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerOtps.
     * @param {SellerOtpCreateManyArgs} args - Arguments to create many SellerOtps.
     * @example
     * // Create many SellerOtps
     * const sellerOtp = await prisma.sellerOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerOtpCreateManyArgs>(args?: SelectSubset<T, SellerOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerOtps and returns the data saved in the database.
     * @param {SellerOtpCreateManyAndReturnArgs} args - Arguments to create many SellerOtps.
     * @example
     * // Create many SellerOtps
     * const sellerOtp = await prisma.sellerOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerOtps and only return the `id`
     * const sellerOtpWithIdOnly = await prisma.sellerOtp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerOtp.
     * @param {SellerOtpDeleteArgs} args - Arguments to delete one SellerOtp.
     * @example
     * // Delete one SellerOtp
     * const SellerOtp = await prisma.sellerOtp.delete({
     *   where: {
     *     // ... filter to delete one SellerOtp
     *   }
     * })
     * 
     */
    delete<T extends SellerOtpDeleteArgs>(args: SelectSubset<T, SellerOtpDeleteArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerOtp.
     * @param {SellerOtpUpdateArgs} args - Arguments to update one SellerOtp.
     * @example
     * // Update one SellerOtp
     * const sellerOtp = await prisma.sellerOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerOtpUpdateArgs>(args: SelectSubset<T, SellerOtpUpdateArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerOtps.
     * @param {SellerOtpDeleteManyArgs} args - Arguments to filter SellerOtps to delete.
     * @example
     * // Delete a few SellerOtps
     * const { count } = await prisma.sellerOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerOtpDeleteManyArgs>(args?: SelectSubset<T, SellerOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerOtps
     * const sellerOtp = await prisma.sellerOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerOtpUpdateManyArgs>(args: SelectSubset<T, SellerOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerOtps and returns the data updated in the database.
     * @param {SellerOtpUpdateManyAndReturnArgs} args - Arguments to update many SellerOtps.
     * @example
     * // Update many SellerOtps
     * const sellerOtp = await prisma.sellerOtp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerOtps and only return the `id`
     * const sellerOtpWithIdOnly = await prisma.sellerOtp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerOtpUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerOtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerOtp.
     * @param {SellerOtpUpsertArgs} args - Arguments to update or create a SellerOtp.
     * @example
     * // Update or create a SellerOtp
     * const sellerOtp = await prisma.sellerOtp.upsert({
     *   create: {
     *     // ... data to create a SellerOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerOtp we want to update
     *   }
     * })
     */
    upsert<T extends SellerOtpUpsertArgs>(args: SelectSubset<T, SellerOtpUpsertArgs<ExtArgs>>): Prisma__SellerOtpClient<$Result.GetResult<Prisma.$SellerOtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpCountArgs} args - Arguments to filter SellerOtps to count.
     * @example
     * // Count the number of SellerOtps
     * const count = await prisma.sellerOtp.count({
     *   where: {
     *     // ... the filter for the SellerOtps we want to count
     *   }
     * })
    **/
    count<T extends SellerOtpCountArgs>(
      args?: Subset<T, SellerOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerOtpAggregateArgs>(args: Subset<T, SellerOtpAggregateArgs>): Prisma.PrismaPromise<GetSellerOtpAggregateType<T>>

    /**
     * Group by SellerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerOtpGroupByArgs['orderBy'] }
        : { orderBy?: SellerOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerOtp model
   */
  readonly fields: SellerOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerOtp model
   */
  interface SellerOtpFieldRefs {
    readonly id: FieldRef<"SellerOtp", 'String'>
    readonly email: FieldRef<"SellerOtp", 'String'>
    readonly otpHash: FieldRef<"SellerOtp", 'String'>
    readonly expiresAt: FieldRef<"SellerOtp", 'DateTime'>
    readonly verified: FieldRef<"SellerOtp", 'Boolean'>
    readonly createdAt: FieldRef<"SellerOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerOtp findUnique
   */
  export type SellerOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter, which SellerOtp to fetch.
     */
    where: SellerOtpWhereUniqueInput
  }

  /**
   * SellerOtp findUniqueOrThrow
   */
  export type SellerOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter, which SellerOtp to fetch.
     */
    where: SellerOtpWhereUniqueInput
  }

  /**
   * SellerOtp findFirst
   */
  export type SellerOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter, which SellerOtp to fetch.
     */
    where?: SellerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerOtps to fetch.
     */
    orderBy?: SellerOtpOrderByWithRelationInput | SellerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerOtps.
     */
    cursor?: SellerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerOtps.
     */
    distinct?: SellerOtpScalarFieldEnum | SellerOtpScalarFieldEnum[]
  }

  /**
   * SellerOtp findFirstOrThrow
   */
  export type SellerOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter, which SellerOtp to fetch.
     */
    where?: SellerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerOtps to fetch.
     */
    orderBy?: SellerOtpOrderByWithRelationInput | SellerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerOtps.
     */
    cursor?: SellerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerOtps.
     */
    distinct?: SellerOtpScalarFieldEnum | SellerOtpScalarFieldEnum[]
  }

  /**
   * SellerOtp findMany
   */
  export type SellerOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter, which SellerOtps to fetch.
     */
    where?: SellerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerOtps to fetch.
     */
    orderBy?: SellerOtpOrderByWithRelationInput | SellerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerOtps.
     */
    cursor?: SellerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerOtps.
     */
    skip?: number
    distinct?: SellerOtpScalarFieldEnum | SellerOtpScalarFieldEnum[]
  }

  /**
   * SellerOtp create
   */
  export type SellerOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * The data needed to create a SellerOtp.
     */
    data: XOR<SellerOtpCreateInput, SellerOtpUncheckedCreateInput>
  }

  /**
   * SellerOtp createMany
   */
  export type SellerOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerOtps.
     */
    data: SellerOtpCreateManyInput | SellerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerOtp createManyAndReturn
   */
  export type SellerOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * The data used to create many SellerOtps.
     */
    data: SellerOtpCreateManyInput | SellerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerOtp update
   */
  export type SellerOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * The data needed to update a SellerOtp.
     */
    data: XOR<SellerOtpUpdateInput, SellerOtpUncheckedUpdateInput>
    /**
     * Choose, which SellerOtp to update.
     */
    where: SellerOtpWhereUniqueInput
  }

  /**
   * SellerOtp updateMany
   */
  export type SellerOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerOtps.
     */
    data: XOR<SellerOtpUpdateManyMutationInput, SellerOtpUncheckedUpdateManyInput>
    /**
     * Filter which SellerOtps to update
     */
    where?: SellerOtpWhereInput
    /**
     * Limit how many SellerOtps to update.
     */
    limit?: number
  }

  /**
   * SellerOtp updateManyAndReturn
   */
  export type SellerOtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * The data used to update SellerOtps.
     */
    data: XOR<SellerOtpUpdateManyMutationInput, SellerOtpUncheckedUpdateManyInput>
    /**
     * Filter which SellerOtps to update
     */
    where?: SellerOtpWhereInput
    /**
     * Limit how many SellerOtps to update.
     */
    limit?: number
  }

  /**
   * SellerOtp upsert
   */
  export type SellerOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * The filter to search for the SellerOtp to update in case it exists.
     */
    where: SellerOtpWhereUniqueInput
    /**
     * In case the SellerOtp found by the `where` argument doesn't exist, create a new SellerOtp with this data.
     */
    create: XOR<SellerOtpCreateInput, SellerOtpUncheckedCreateInput>
    /**
     * In case the SellerOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerOtpUpdateInput, SellerOtpUncheckedUpdateInput>
  }

  /**
   * SellerOtp delete
   */
  export type SellerOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
    /**
     * Filter which SellerOtp to delete.
     */
    where: SellerOtpWhereUniqueInput
  }

  /**
   * SellerOtp deleteMany
   */
  export type SellerOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerOtps to delete
     */
    where?: SellerOtpWhereInput
    /**
     * Limit how many SellerOtps to delete.
     */
    limit?: number
  }

  /**
   * SellerOtp without action
   */
  export type SellerOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerOtp
     */
    select?: SellerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerOtp
     */
    omit?: SellerOtpOmit<ExtArgs> | null
  }


  /**
   * Model SellerBusinessDetails
   */

  export type AggregateSellerBusinessDetails = {
    _count: SellerBusinessDetailsCountAggregateOutputType | null
    _avg: SellerBusinessDetailsAvgAggregateOutputType | null
    _sum: SellerBusinessDetailsSumAggregateOutputType | null
    _min: SellerBusinessDetailsMinAggregateOutputType | null
    _max: SellerBusinessDetailsMaxAggregateOutputType | null
  }

  export type SellerBusinessDetailsAvgAggregateOutputType = {
    id: number | null
    sellerId: number | null
  }

  export type SellerBusinessDetailsSumAggregateOutputType = {
    id: number | null
    sellerId: number | null
  }

  export type SellerBusinessDetailsMinAggregateOutputType = {
    id: number | null
    businessName: string | null
    sellerType: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    gst: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type SellerBusinessDetailsMaxAggregateOutputType = {
    id: number | null
    businessName: string | null
    sellerType: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    gst: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type SellerBusinessDetailsCountAggregateOutputType = {
    id: number
    businessName: number
    sellerType: number
    address: number
    city: number
    state: number
    pincode: number
    gst: number
    sellerId: number
    createdAt: number
    _all: number
  }


  export type SellerBusinessDetailsAvgAggregateInputType = {
    id?: true
    sellerId?: true
  }

  export type SellerBusinessDetailsSumAggregateInputType = {
    id?: true
    sellerId?: true
  }

  export type SellerBusinessDetailsMinAggregateInputType = {
    id?: true
    businessName?: true
    sellerType?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    gst?: true
    sellerId?: true
    createdAt?: true
  }

  export type SellerBusinessDetailsMaxAggregateInputType = {
    id?: true
    businessName?: true
    sellerType?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    gst?: true
    sellerId?: true
    createdAt?: true
  }

  export type SellerBusinessDetailsCountAggregateInputType = {
    id?: true
    businessName?: true
    sellerType?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    gst?: true
    sellerId?: true
    createdAt?: true
    _all?: true
  }

  export type SellerBusinessDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerBusinessDetails to aggregate.
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBusinessDetails to fetch.
     */
    orderBy?: SellerBusinessDetailsOrderByWithRelationInput | SellerBusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerBusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerBusinessDetails
    **/
    _count?: true | SellerBusinessDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerBusinessDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerBusinessDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerBusinessDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerBusinessDetailsMaxAggregateInputType
  }

  export type GetSellerBusinessDetailsAggregateType<T extends SellerBusinessDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerBusinessDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerBusinessDetails[P]>
      : GetScalarType<T[P], AggregateSellerBusinessDetails[P]>
  }




  export type SellerBusinessDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerBusinessDetailsWhereInput
    orderBy?: SellerBusinessDetailsOrderByWithAggregationInput | SellerBusinessDetailsOrderByWithAggregationInput[]
    by: SellerBusinessDetailsScalarFieldEnum[] | SellerBusinessDetailsScalarFieldEnum
    having?: SellerBusinessDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerBusinessDetailsCountAggregateInputType | true
    _avg?: SellerBusinessDetailsAvgAggregateInputType
    _sum?: SellerBusinessDetailsSumAggregateInputType
    _min?: SellerBusinessDetailsMinAggregateInputType
    _max?: SellerBusinessDetailsMaxAggregateInputType
  }

  export type SellerBusinessDetailsGroupByOutputType = {
    id: number
    businessName: string
    sellerType: string
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    gst: string | null
    sellerId: number
    createdAt: Date
    _count: SellerBusinessDetailsCountAggregateOutputType | null
    _avg: SellerBusinessDetailsAvgAggregateOutputType | null
    _sum: SellerBusinessDetailsSumAggregateOutputType | null
    _min: SellerBusinessDetailsMinAggregateOutputType | null
    _max: SellerBusinessDetailsMaxAggregateOutputType | null
  }

  type GetSellerBusinessDetailsGroupByPayload<T extends SellerBusinessDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerBusinessDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerBusinessDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerBusinessDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], SellerBusinessDetailsGroupByOutputType[P]>
        }
      >
    >


  export type SellerBusinessDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    sellerType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    gst?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBusinessDetails"]>

  export type SellerBusinessDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    sellerType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    gst?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBusinessDetails"]>

  export type SellerBusinessDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    sellerType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    gst?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBusinessDetails"]>

  export type SellerBusinessDetailsSelectScalar = {
    id?: boolean
    businessName?: boolean
    sellerType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    gst?: boolean
    sellerId?: boolean
    createdAt?: boolean
  }

  export type SellerBusinessDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessName" | "sellerType" | "address" | "city" | "state" | "pincode" | "gst" | "sellerId" | "createdAt", ExtArgs["result"]["sellerBusinessDetails"]>
  export type SellerBusinessDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerBusinessDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerBusinessDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }

  export type $SellerBusinessDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerBusinessDetails"
    objects: {
      seller: Prisma.$SellerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      businessName: string
      sellerType: string
      address: string | null
      city: string | null
      state: string | null
      pincode: string | null
      gst: string | null
      sellerId: number
      createdAt: Date
    }, ExtArgs["result"]["sellerBusinessDetails"]>
    composites: {}
  }

  type SellerBusinessDetailsGetPayload<S extends boolean | null | undefined | SellerBusinessDetailsDefaultArgs> = $Result.GetResult<Prisma.$SellerBusinessDetailsPayload, S>

  type SellerBusinessDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerBusinessDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerBusinessDetailsCountAggregateInputType | true
    }

  export interface SellerBusinessDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerBusinessDetails'], meta: { name: 'SellerBusinessDetails' } }
    /**
     * Find zero or one SellerBusinessDetails that matches the filter.
     * @param {SellerBusinessDetailsFindUniqueArgs} args - Arguments to find a SellerBusinessDetails
     * @example
     * // Get one SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerBusinessDetailsFindUniqueArgs>(args: SelectSubset<T, SellerBusinessDetailsFindUniqueArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerBusinessDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerBusinessDetailsFindUniqueOrThrowArgs} args - Arguments to find a SellerBusinessDetails
     * @example
     * // Get one SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerBusinessDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerBusinessDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerBusinessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsFindFirstArgs} args - Arguments to find a SellerBusinessDetails
     * @example
     * // Get one SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerBusinessDetailsFindFirstArgs>(args?: SelectSubset<T, SellerBusinessDetailsFindFirstArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerBusinessDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsFindFirstOrThrowArgs} args - Arguments to find a SellerBusinessDetails
     * @example
     * // Get one SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerBusinessDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerBusinessDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerBusinessDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findMany()
     * 
     * // Get first 10 SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerBusinessDetailsWithIdOnly = await prisma.sellerBusinessDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerBusinessDetailsFindManyArgs>(args?: SelectSubset<T, SellerBusinessDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerBusinessDetails.
     * @param {SellerBusinessDetailsCreateArgs} args - Arguments to create a SellerBusinessDetails.
     * @example
     * // Create one SellerBusinessDetails
     * const SellerBusinessDetails = await prisma.sellerBusinessDetails.create({
     *   data: {
     *     // ... data to create a SellerBusinessDetails
     *   }
     * })
     * 
     */
    create<T extends SellerBusinessDetailsCreateArgs>(args: SelectSubset<T, SellerBusinessDetailsCreateArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerBusinessDetails.
     * @param {SellerBusinessDetailsCreateManyArgs} args - Arguments to create many SellerBusinessDetails.
     * @example
     * // Create many SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerBusinessDetailsCreateManyArgs>(args?: SelectSubset<T, SellerBusinessDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerBusinessDetails and returns the data saved in the database.
     * @param {SellerBusinessDetailsCreateManyAndReturnArgs} args - Arguments to create many SellerBusinessDetails.
     * @example
     * // Create many SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerBusinessDetails and only return the `id`
     * const sellerBusinessDetailsWithIdOnly = await prisma.sellerBusinessDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerBusinessDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerBusinessDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerBusinessDetails.
     * @param {SellerBusinessDetailsDeleteArgs} args - Arguments to delete one SellerBusinessDetails.
     * @example
     * // Delete one SellerBusinessDetails
     * const SellerBusinessDetails = await prisma.sellerBusinessDetails.delete({
     *   where: {
     *     // ... filter to delete one SellerBusinessDetails
     *   }
     * })
     * 
     */
    delete<T extends SellerBusinessDetailsDeleteArgs>(args: SelectSubset<T, SellerBusinessDetailsDeleteArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerBusinessDetails.
     * @param {SellerBusinessDetailsUpdateArgs} args - Arguments to update one SellerBusinessDetails.
     * @example
     * // Update one SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerBusinessDetailsUpdateArgs>(args: SelectSubset<T, SellerBusinessDetailsUpdateArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerBusinessDetails.
     * @param {SellerBusinessDetailsDeleteManyArgs} args - Arguments to filter SellerBusinessDetails to delete.
     * @example
     * // Delete a few SellerBusinessDetails
     * const { count } = await prisma.sellerBusinessDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerBusinessDetailsDeleteManyArgs>(args?: SelectSubset<T, SellerBusinessDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerBusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerBusinessDetailsUpdateManyArgs>(args: SelectSubset<T, SellerBusinessDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerBusinessDetails and returns the data updated in the database.
     * @param {SellerBusinessDetailsUpdateManyAndReturnArgs} args - Arguments to update many SellerBusinessDetails.
     * @example
     * // Update many SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerBusinessDetails and only return the `id`
     * const sellerBusinessDetailsWithIdOnly = await prisma.sellerBusinessDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerBusinessDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerBusinessDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerBusinessDetails.
     * @param {SellerBusinessDetailsUpsertArgs} args - Arguments to update or create a SellerBusinessDetails.
     * @example
     * // Update or create a SellerBusinessDetails
     * const sellerBusinessDetails = await prisma.sellerBusinessDetails.upsert({
     *   create: {
     *     // ... data to create a SellerBusinessDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerBusinessDetails we want to update
     *   }
     * })
     */
    upsert<T extends SellerBusinessDetailsUpsertArgs>(args: SelectSubset<T, SellerBusinessDetailsUpsertArgs<ExtArgs>>): Prisma__SellerBusinessDetailsClient<$Result.GetResult<Prisma.$SellerBusinessDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerBusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsCountArgs} args - Arguments to filter SellerBusinessDetails to count.
     * @example
     * // Count the number of SellerBusinessDetails
     * const count = await prisma.sellerBusinessDetails.count({
     *   where: {
     *     // ... the filter for the SellerBusinessDetails we want to count
     *   }
     * })
    **/
    count<T extends SellerBusinessDetailsCountArgs>(
      args?: Subset<T, SellerBusinessDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerBusinessDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerBusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerBusinessDetailsAggregateArgs>(args: Subset<T, SellerBusinessDetailsAggregateArgs>): Prisma.PrismaPromise<GetSellerBusinessDetailsAggregateType<T>>

    /**
     * Group by SellerBusinessDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBusinessDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerBusinessDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerBusinessDetailsGroupByArgs['orderBy'] }
        : { orderBy?: SellerBusinessDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerBusinessDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerBusinessDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerBusinessDetails model
   */
  readonly fields: SellerBusinessDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerBusinessDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerBusinessDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends SellerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerDefaultArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerBusinessDetails model
   */
  interface SellerBusinessDetailsFieldRefs {
    readonly id: FieldRef<"SellerBusinessDetails", 'Int'>
    readonly businessName: FieldRef<"SellerBusinessDetails", 'String'>
    readonly sellerType: FieldRef<"SellerBusinessDetails", 'String'>
    readonly address: FieldRef<"SellerBusinessDetails", 'String'>
    readonly city: FieldRef<"SellerBusinessDetails", 'String'>
    readonly state: FieldRef<"SellerBusinessDetails", 'String'>
    readonly pincode: FieldRef<"SellerBusinessDetails", 'String'>
    readonly gst: FieldRef<"SellerBusinessDetails", 'String'>
    readonly sellerId: FieldRef<"SellerBusinessDetails", 'Int'>
    readonly createdAt: FieldRef<"SellerBusinessDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerBusinessDetails findUnique
   */
  export type SellerBusinessDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBusinessDetails to fetch.
     */
    where: SellerBusinessDetailsWhereUniqueInput
  }

  /**
   * SellerBusinessDetails findUniqueOrThrow
   */
  export type SellerBusinessDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBusinessDetails to fetch.
     */
    where: SellerBusinessDetailsWhereUniqueInput
  }

  /**
   * SellerBusinessDetails findFirst
   */
  export type SellerBusinessDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBusinessDetails to fetch.
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBusinessDetails to fetch.
     */
    orderBy?: SellerBusinessDetailsOrderByWithRelationInput | SellerBusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerBusinessDetails.
     */
    cursor?: SellerBusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerBusinessDetails.
     */
    distinct?: SellerBusinessDetailsScalarFieldEnum | SellerBusinessDetailsScalarFieldEnum[]
  }

  /**
   * SellerBusinessDetails findFirstOrThrow
   */
  export type SellerBusinessDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBusinessDetails to fetch.
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBusinessDetails to fetch.
     */
    orderBy?: SellerBusinessDetailsOrderByWithRelationInput | SellerBusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerBusinessDetails.
     */
    cursor?: SellerBusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBusinessDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerBusinessDetails.
     */
    distinct?: SellerBusinessDetailsScalarFieldEnum | SellerBusinessDetailsScalarFieldEnum[]
  }

  /**
   * SellerBusinessDetails findMany
   */
  export type SellerBusinessDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBusinessDetails to fetch.
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBusinessDetails to fetch.
     */
    orderBy?: SellerBusinessDetailsOrderByWithRelationInput | SellerBusinessDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerBusinessDetails.
     */
    cursor?: SellerBusinessDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBusinessDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBusinessDetails.
     */
    skip?: number
    distinct?: SellerBusinessDetailsScalarFieldEnum | SellerBusinessDetailsScalarFieldEnum[]
  }

  /**
   * SellerBusinessDetails create
   */
  export type SellerBusinessDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerBusinessDetails.
     */
    data: XOR<SellerBusinessDetailsCreateInput, SellerBusinessDetailsUncheckedCreateInput>
  }

  /**
   * SellerBusinessDetails createMany
   */
  export type SellerBusinessDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerBusinessDetails.
     */
    data: SellerBusinessDetailsCreateManyInput | SellerBusinessDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerBusinessDetails createManyAndReturn
   */
  export type SellerBusinessDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many SellerBusinessDetails.
     */
    data: SellerBusinessDetailsCreateManyInput | SellerBusinessDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerBusinessDetails update
   */
  export type SellerBusinessDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerBusinessDetails.
     */
    data: XOR<SellerBusinessDetailsUpdateInput, SellerBusinessDetailsUncheckedUpdateInput>
    /**
     * Choose, which SellerBusinessDetails to update.
     */
    where: SellerBusinessDetailsWhereUniqueInput
  }

  /**
   * SellerBusinessDetails updateMany
   */
  export type SellerBusinessDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerBusinessDetails.
     */
    data: XOR<SellerBusinessDetailsUpdateManyMutationInput, SellerBusinessDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerBusinessDetails to update
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * Limit how many SellerBusinessDetails to update.
     */
    limit?: number
  }

  /**
   * SellerBusinessDetails updateManyAndReturn
   */
  export type SellerBusinessDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * The data used to update SellerBusinessDetails.
     */
    data: XOR<SellerBusinessDetailsUpdateManyMutationInput, SellerBusinessDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerBusinessDetails to update
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * Limit how many SellerBusinessDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerBusinessDetails upsert
   */
  export type SellerBusinessDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerBusinessDetails to update in case it exists.
     */
    where: SellerBusinessDetailsWhereUniqueInput
    /**
     * In case the SellerBusinessDetails found by the `where` argument doesn't exist, create a new SellerBusinessDetails with this data.
     */
    create: XOR<SellerBusinessDetailsCreateInput, SellerBusinessDetailsUncheckedCreateInput>
    /**
     * In case the SellerBusinessDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerBusinessDetailsUpdateInput, SellerBusinessDetailsUncheckedUpdateInput>
  }

  /**
   * SellerBusinessDetails delete
   */
  export type SellerBusinessDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
    /**
     * Filter which SellerBusinessDetails to delete.
     */
    where: SellerBusinessDetailsWhereUniqueInput
  }

  /**
   * SellerBusinessDetails deleteMany
   */
  export type SellerBusinessDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerBusinessDetails to delete
     */
    where?: SellerBusinessDetailsWhereInput
    /**
     * Limit how many SellerBusinessDetails to delete.
     */
    limit?: number
  }

  /**
   * SellerBusinessDetails without action
   */
  export type SellerBusinessDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBusinessDetails
     */
    select?: SellerBusinessDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBusinessDetails
     */
    omit?: SellerBusinessDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBusinessDetailsInclude<ExtArgs> | null
  }


  /**
   * Model SellerDeliveryDetails
   */

  export type AggregateSellerDeliveryDetails = {
    _count: SellerDeliveryDetailsCountAggregateOutputType | null
    _avg: SellerDeliveryDetailsAvgAggregateOutputType | null
    _sum: SellerDeliveryDetailsSumAggregateOutputType | null
    _min: SellerDeliveryDetailsMinAggregateOutputType | null
    _max: SellerDeliveryDetailsMaxAggregateOutputType | null
  }

  export type SellerDeliveryDetailsAvgAggregateOutputType = {
    id: number | null
    sellerId: number | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingCharge: number | null
    installationCharge: number | null
  }

  export type SellerDeliveryDetailsSumAggregateOutputType = {
    id: number | null
    sellerId: number | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingCharge: number | null
    installationCharge: number | null
  }

  export type SellerDeliveryDetailsMinAggregateOutputType = {
    id: number | null
    sellerId: number | null
    deliveryResponsibility: string | null
    deliveryCoverage: string | null
    deliveryType: string | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string | null
    shippingCharge: number | null
    internationalDelivery: boolean | null
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date | null
  }

  export type SellerDeliveryDetailsMaxAggregateOutputType = {
    id: number | null
    sellerId: number | null
    deliveryResponsibility: string | null
    deliveryCoverage: string | null
    deliveryType: string | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string | null
    shippingCharge: number | null
    internationalDelivery: boolean | null
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date | null
  }

  export type SellerDeliveryDetailsCountAggregateOutputType = {
    id: number
    sellerId: number
    deliveryResponsibility: number
    deliveryCoverage: number
    deliveryType: number
    deliveryTimeMin: number
    deliveryTimeMax: number
    shippingChargeType: number
    shippingCharge: number
    internationalDelivery: number
    installationAvailable: number
    installationCharge: number
    createdAt: number
    _all: number
  }


  export type SellerDeliveryDetailsAvgAggregateInputType = {
    id?: true
    sellerId?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingCharge?: true
    installationCharge?: true
  }

  export type SellerDeliveryDetailsSumAggregateInputType = {
    id?: true
    sellerId?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingCharge?: true
    installationCharge?: true
  }

  export type SellerDeliveryDetailsMinAggregateInputType = {
    id?: true
    sellerId?: true
    deliveryResponsibility?: true
    deliveryCoverage?: true
    deliveryType?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    internationalDelivery?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
  }

  export type SellerDeliveryDetailsMaxAggregateInputType = {
    id?: true
    sellerId?: true
    deliveryResponsibility?: true
    deliveryCoverage?: true
    deliveryType?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    internationalDelivery?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
  }

  export type SellerDeliveryDetailsCountAggregateInputType = {
    id?: true
    sellerId?: true
    deliveryResponsibility?: true
    deliveryCoverage?: true
    deliveryType?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    internationalDelivery?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
    _all?: true
  }

  export type SellerDeliveryDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerDeliveryDetails to aggregate.
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerDeliveryDetails to fetch.
     */
    orderBy?: SellerDeliveryDetailsOrderByWithRelationInput | SellerDeliveryDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerDeliveryDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerDeliveryDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerDeliveryDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerDeliveryDetails
    **/
    _count?: true | SellerDeliveryDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerDeliveryDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerDeliveryDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerDeliveryDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerDeliveryDetailsMaxAggregateInputType
  }

  export type GetSellerDeliveryDetailsAggregateType<T extends SellerDeliveryDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerDeliveryDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerDeliveryDetails[P]>
      : GetScalarType<T[P], AggregateSellerDeliveryDetails[P]>
  }




  export type SellerDeliveryDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerDeliveryDetailsWhereInput
    orderBy?: SellerDeliveryDetailsOrderByWithAggregationInput | SellerDeliveryDetailsOrderByWithAggregationInput[]
    by: SellerDeliveryDetailsScalarFieldEnum[] | SellerDeliveryDetailsScalarFieldEnum
    having?: SellerDeliveryDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerDeliveryDetailsCountAggregateInputType | true
    _avg?: SellerDeliveryDetailsAvgAggregateInputType
    _sum?: SellerDeliveryDetailsSumAggregateInputType
    _min?: SellerDeliveryDetailsMinAggregateInputType
    _max?: SellerDeliveryDetailsMaxAggregateInputType
  }

  export type SellerDeliveryDetailsGroupByOutputType = {
    id: number
    sellerId: number
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string
    shippingCharge: number | null
    internationalDelivery: boolean
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date
    _count: SellerDeliveryDetailsCountAggregateOutputType | null
    _avg: SellerDeliveryDetailsAvgAggregateOutputType | null
    _sum: SellerDeliveryDetailsSumAggregateOutputType | null
    _min: SellerDeliveryDetailsMinAggregateOutputType | null
    _max: SellerDeliveryDetailsMaxAggregateOutputType | null
  }

  type GetSellerDeliveryDetailsGroupByPayload<T extends SellerDeliveryDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerDeliveryDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerDeliveryDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerDeliveryDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], SellerDeliveryDetailsGroupByOutputType[P]>
        }
      >
    >


  export type SellerDeliveryDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    deliveryResponsibility?: boolean
    deliveryCoverage?: boolean
    deliveryType?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    internationalDelivery?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerDeliveryDetails"]>

  export type SellerDeliveryDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    deliveryResponsibility?: boolean
    deliveryCoverage?: boolean
    deliveryType?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    internationalDelivery?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerDeliveryDetails"]>

  export type SellerDeliveryDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    deliveryResponsibility?: boolean
    deliveryCoverage?: boolean
    deliveryType?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    internationalDelivery?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerDeliveryDetails"]>

  export type SellerDeliveryDetailsSelectScalar = {
    id?: boolean
    sellerId?: boolean
    deliveryResponsibility?: boolean
    deliveryCoverage?: boolean
    deliveryType?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    internationalDelivery?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
  }

  export type SellerDeliveryDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "deliveryResponsibility" | "deliveryCoverage" | "deliveryType" | "deliveryTimeMin" | "deliveryTimeMax" | "shippingChargeType" | "shippingCharge" | "internationalDelivery" | "installationAvailable" | "installationCharge" | "createdAt", ExtArgs["result"]["sellerDeliveryDetails"]>
  export type SellerDeliveryDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerDeliveryDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerDeliveryDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }

  export type $SellerDeliveryDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerDeliveryDetails"
    objects: {
      seller: Prisma.$SellerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sellerId: number
      deliveryResponsibility: string
      deliveryCoverage: string
      deliveryType: string
      deliveryTimeMin: number | null
      deliveryTimeMax: number | null
      shippingChargeType: string
      shippingCharge: number | null
      internationalDelivery: boolean
      installationAvailable: string | null
      installationCharge: number | null
      createdAt: Date
    }, ExtArgs["result"]["sellerDeliveryDetails"]>
    composites: {}
  }

  type SellerDeliveryDetailsGetPayload<S extends boolean | null | undefined | SellerDeliveryDetailsDefaultArgs> = $Result.GetResult<Prisma.$SellerDeliveryDetailsPayload, S>

  type SellerDeliveryDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerDeliveryDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerDeliveryDetailsCountAggregateInputType | true
    }

  export interface SellerDeliveryDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerDeliveryDetails'], meta: { name: 'SellerDeliveryDetails' } }
    /**
     * Find zero or one SellerDeliveryDetails that matches the filter.
     * @param {SellerDeliveryDetailsFindUniqueArgs} args - Arguments to find a SellerDeliveryDetails
     * @example
     * // Get one SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerDeliveryDetailsFindUniqueArgs>(args: SelectSubset<T, SellerDeliveryDetailsFindUniqueArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerDeliveryDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerDeliveryDetailsFindUniqueOrThrowArgs} args - Arguments to find a SellerDeliveryDetails
     * @example
     * // Get one SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerDeliveryDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerDeliveryDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerDeliveryDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsFindFirstArgs} args - Arguments to find a SellerDeliveryDetails
     * @example
     * // Get one SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerDeliveryDetailsFindFirstArgs>(args?: SelectSubset<T, SellerDeliveryDetailsFindFirstArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerDeliveryDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsFindFirstOrThrowArgs} args - Arguments to find a SellerDeliveryDetails
     * @example
     * // Get one SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerDeliveryDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerDeliveryDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerDeliveryDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findMany()
     * 
     * // Get first 10 SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerDeliveryDetailsWithIdOnly = await prisma.sellerDeliveryDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerDeliveryDetailsFindManyArgs>(args?: SelectSubset<T, SellerDeliveryDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsCreateArgs} args - Arguments to create a SellerDeliveryDetails.
     * @example
     * // Create one SellerDeliveryDetails
     * const SellerDeliveryDetails = await prisma.sellerDeliveryDetails.create({
     *   data: {
     *     // ... data to create a SellerDeliveryDetails
     *   }
     * })
     * 
     */
    create<T extends SellerDeliveryDetailsCreateArgs>(args: SelectSubset<T, SellerDeliveryDetailsCreateArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsCreateManyArgs} args - Arguments to create many SellerDeliveryDetails.
     * @example
     * // Create many SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerDeliveryDetailsCreateManyArgs>(args?: SelectSubset<T, SellerDeliveryDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerDeliveryDetails and returns the data saved in the database.
     * @param {SellerDeliveryDetailsCreateManyAndReturnArgs} args - Arguments to create many SellerDeliveryDetails.
     * @example
     * // Create many SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerDeliveryDetails and only return the `id`
     * const sellerDeliveryDetailsWithIdOnly = await prisma.sellerDeliveryDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerDeliveryDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerDeliveryDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsDeleteArgs} args - Arguments to delete one SellerDeliveryDetails.
     * @example
     * // Delete one SellerDeliveryDetails
     * const SellerDeliveryDetails = await prisma.sellerDeliveryDetails.delete({
     *   where: {
     *     // ... filter to delete one SellerDeliveryDetails
     *   }
     * })
     * 
     */
    delete<T extends SellerDeliveryDetailsDeleteArgs>(args: SelectSubset<T, SellerDeliveryDetailsDeleteArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsUpdateArgs} args - Arguments to update one SellerDeliveryDetails.
     * @example
     * // Update one SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerDeliveryDetailsUpdateArgs>(args: SelectSubset<T, SellerDeliveryDetailsUpdateArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsDeleteManyArgs} args - Arguments to filter SellerDeliveryDetails to delete.
     * @example
     * // Delete a few SellerDeliveryDetails
     * const { count } = await prisma.sellerDeliveryDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerDeliveryDetailsDeleteManyArgs>(args?: SelectSubset<T, SellerDeliveryDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerDeliveryDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerDeliveryDetailsUpdateManyArgs>(args: SelectSubset<T, SellerDeliveryDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerDeliveryDetails and returns the data updated in the database.
     * @param {SellerDeliveryDetailsUpdateManyAndReturnArgs} args - Arguments to update many SellerDeliveryDetails.
     * @example
     * // Update many SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerDeliveryDetails and only return the `id`
     * const sellerDeliveryDetailsWithIdOnly = await prisma.sellerDeliveryDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerDeliveryDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerDeliveryDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerDeliveryDetails.
     * @param {SellerDeliveryDetailsUpsertArgs} args - Arguments to update or create a SellerDeliveryDetails.
     * @example
     * // Update or create a SellerDeliveryDetails
     * const sellerDeliveryDetails = await prisma.sellerDeliveryDetails.upsert({
     *   create: {
     *     // ... data to create a SellerDeliveryDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerDeliveryDetails we want to update
     *   }
     * })
     */
    upsert<T extends SellerDeliveryDetailsUpsertArgs>(args: SelectSubset<T, SellerDeliveryDetailsUpsertArgs<ExtArgs>>): Prisma__SellerDeliveryDetailsClient<$Result.GetResult<Prisma.$SellerDeliveryDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerDeliveryDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsCountArgs} args - Arguments to filter SellerDeliveryDetails to count.
     * @example
     * // Count the number of SellerDeliveryDetails
     * const count = await prisma.sellerDeliveryDetails.count({
     *   where: {
     *     // ... the filter for the SellerDeliveryDetails we want to count
     *   }
     * })
    **/
    count<T extends SellerDeliveryDetailsCountArgs>(
      args?: Subset<T, SellerDeliveryDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerDeliveryDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerDeliveryDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerDeliveryDetailsAggregateArgs>(args: Subset<T, SellerDeliveryDetailsAggregateArgs>): Prisma.PrismaPromise<GetSellerDeliveryDetailsAggregateType<T>>

    /**
     * Group by SellerDeliveryDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerDeliveryDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerDeliveryDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerDeliveryDetailsGroupByArgs['orderBy'] }
        : { orderBy?: SellerDeliveryDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerDeliveryDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerDeliveryDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerDeliveryDetails model
   */
  readonly fields: SellerDeliveryDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerDeliveryDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerDeliveryDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends SellerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerDefaultArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerDeliveryDetails model
   */
  interface SellerDeliveryDetailsFieldRefs {
    readonly id: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly sellerId: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly deliveryResponsibility: FieldRef<"SellerDeliveryDetails", 'String'>
    readonly deliveryCoverage: FieldRef<"SellerDeliveryDetails", 'String'>
    readonly deliveryType: FieldRef<"SellerDeliveryDetails", 'String'>
    readonly deliveryTimeMin: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly deliveryTimeMax: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly shippingChargeType: FieldRef<"SellerDeliveryDetails", 'String'>
    readonly shippingCharge: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly internationalDelivery: FieldRef<"SellerDeliveryDetails", 'Boolean'>
    readonly installationAvailable: FieldRef<"SellerDeliveryDetails", 'String'>
    readonly installationCharge: FieldRef<"SellerDeliveryDetails", 'Int'>
    readonly createdAt: FieldRef<"SellerDeliveryDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerDeliveryDetails findUnique
   */
  export type SellerDeliveryDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerDeliveryDetails to fetch.
     */
    where: SellerDeliveryDetailsWhereUniqueInput
  }

  /**
   * SellerDeliveryDetails findUniqueOrThrow
   */
  export type SellerDeliveryDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerDeliveryDetails to fetch.
     */
    where: SellerDeliveryDetailsWhereUniqueInput
  }

  /**
   * SellerDeliveryDetails findFirst
   */
  export type SellerDeliveryDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerDeliveryDetails to fetch.
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerDeliveryDetails to fetch.
     */
    orderBy?: SellerDeliveryDetailsOrderByWithRelationInput | SellerDeliveryDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerDeliveryDetails.
     */
    cursor?: SellerDeliveryDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerDeliveryDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerDeliveryDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerDeliveryDetails.
     */
    distinct?: SellerDeliveryDetailsScalarFieldEnum | SellerDeliveryDetailsScalarFieldEnum[]
  }

  /**
   * SellerDeliveryDetails findFirstOrThrow
   */
  export type SellerDeliveryDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerDeliveryDetails to fetch.
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerDeliveryDetails to fetch.
     */
    orderBy?: SellerDeliveryDetailsOrderByWithRelationInput | SellerDeliveryDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerDeliveryDetails.
     */
    cursor?: SellerDeliveryDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerDeliveryDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerDeliveryDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerDeliveryDetails.
     */
    distinct?: SellerDeliveryDetailsScalarFieldEnum | SellerDeliveryDetailsScalarFieldEnum[]
  }

  /**
   * SellerDeliveryDetails findMany
   */
  export type SellerDeliveryDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerDeliveryDetails to fetch.
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerDeliveryDetails to fetch.
     */
    orderBy?: SellerDeliveryDetailsOrderByWithRelationInput | SellerDeliveryDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerDeliveryDetails.
     */
    cursor?: SellerDeliveryDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerDeliveryDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerDeliveryDetails.
     */
    skip?: number
    distinct?: SellerDeliveryDetailsScalarFieldEnum | SellerDeliveryDetailsScalarFieldEnum[]
  }

  /**
   * SellerDeliveryDetails create
   */
  export type SellerDeliveryDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerDeliveryDetails.
     */
    data: XOR<SellerDeliveryDetailsCreateInput, SellerDeliveryDetailsUncheckedCreateInput>
  }

  /**
   * SellerDeliveryDetails createMany
   */
  export type SellerDeliveryDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerDeliveryDetails.
     */
    data: SellerDeliveryDetailsCreateManyInput | SellerDeliveryDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerDeliveryDetails createManyAndReturn
   */
  export type SellerDeliveryDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many SellerDeliveryDetails.
     */
    data: SellerDeliveryDetailsCreateManyInput | SellerDeliveryDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerDeliveryDetails update
   */
  export type SellerDeliveryDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerDeliveryDetails.
     */
    data: XOR<SellerDeliveryDetailsUpdateInput, SellerDeliveryDetailsUncheckedUpdateInput>
    /**
     * Choose, which SellerDeliveryDetails to update.
     */
    where: SellerDeliveryDetailsWhereUniqueInput
  }

  /**
   * SellerDeliveryDetails updateMany
   */
  export type SellerDeliveryDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerDeliveryDetails.
     */
    data: XOR<SellerDeliveryDetailsUpdateManyMutationInput, SellerDeliveryDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerDeliveryDetails to update
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * Limit how many SellerDeliveryDetails to update.
     */
    limit?: number
  }

  /**
   * SellerDeliveryDetails updateManyAndReturn
   */
  export type SellerDeliveryDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * The data used to update SellerDeliveryDetails.
     */
    data: XOR<SellerDeliveryDetailsUpdateManyMutationInput, SellerDeliveryDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerDeliveryDetails to update
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * Limit how many SellerDeliveryDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerDeliveryDetails upsert
   */
  export type SellerDeliveryDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerDeliveryDetails to update in case it exists.
     */
    where: SellerDeliveryDetailsWhereUniqueInput
    /**
     * In case the SellerDeliveryDetails found by the `where` argument doesn't exist, create a new SellerDeliveryDetails with this data.
     */
    create: XOR<SellerDeliveryDetailsCreateInput, SellerDeliveryDetailsUncheckedCreateInput>
    /**
     * In case the SellerDeliveryDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerDeliveryDetailsUpdateInput, SellerDeliveryDetailsUncheckedUpdateInput>
  }

  /**
   * SellerDeliveryDetails delete
   */
  export type SellerDeliveryDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
    /**
     * Filter which SellerDeliveryDetails to delete.
     */
    where: SellerDeliveryDetailsWhereUniqueInput
  }

  /**
   * SellerDeliveryDetails deleteMany
   */
  export type SellerDeliveryDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerDeliveryDetails to delete
     */
    where?: SellerDeliveryDetailsWhereInput
    /**
     * Limit how many SellerDeliveryDetails to delete.
     */
    limit?: number
  }

  /**
   * SellerDeliveryDetails without action
   */
  export type SellerDeliveryDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerDeliveryDetails
     */
    select?: SellerDeliveryDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerDeliveryDetails
     */
    omit?: SellerDeliveryDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerDeliveryDetailsInclude<ExtArgs> | null
  }


  /**
   * Model SellerBankDetails
   */

  export type AggregateSellerBankDetails = {
    _count: SellerBankDetailsCountAggregateOutputType | null
    _avg: SellerBankDetailsAvgAggregateOutputType | null
    _sum: SellerBankDetailsSumAggregateOutputType | null
    _min: SellerBankDetailsMinAggregateOutputType | null
    _max: SellerBankDetailsMaxAggregateOutputType | null
  }

  export type SellerBankDetailsAvgAggregateOutputType = {
    id: number | null
    sellerId: number | null
  }

  export type SellerBankDetailsSumAggregateOutputType = {
    id: number | null
    sellerId: number | null
  }

  export type SellerBankDetailsMinAggregateOutputType = {
    id: number | null
    accountHolder: string | null
    bankName: string | null
    accountNumber: string | null
    ifsc: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type SellerBankDetailsMaxAggregateOutputType = {
    id: number | null
    accountHolder: string | null
    bankName: string | null
    accountNumber: string | null
    ifsc: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type SellerBankDetailsCountAggregateOutputType = {
    id: number
    accountHolder: number
    bankName: number
    accountNumber: number
    ifsc: number
    sellerId: number
    createdAt: number
    _all: number
  }


  export type SellerBankDetailsAvgAggregateInputType = {
    id?: true
    sellerId?: true
  }

  export type SellerBankDetailsSumAggregateInputType = {
    id?: true
    sellerId?: true
  }

  export type SellerBankDetailsMinAggregateInputType = {
    id?: true
    accountHolder?: true
    bankName?: true
    accountNumber?: true
    ifsc?: true
    sellerId?: true
    createdAt?: true
  }

  export type SellerBankDetailsMaxAggregateInputType = {
    id?: true
    accountHolder?: true
    bankName?: true
    accountNumber?: true
    ifsc?: true
    sellerId?: true
    createdAt?: true
  }

  export type SellerBankDetailsCountAggregateInputType = {
    id?: true
    accountHolder?: true
    bankName?: true
    accountNumber?: true
    ifsc?: true
    sellerId?: true
    createdAt?: true
    _all?: true
  }

  export type SellerBankDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerBankDetails to aggregate.
     */
    where?: SellerBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBankDetails to fetch.
     */
    orderBy?: SellerBankDetailsOrderByWithRelationInput | SellerBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerBankDetails
    **/
    _count?: true | SellerBankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerBankDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerBankDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerBankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerBankDetailsMaxAggregateInputType
  }

  export type GetSellerBankDetailsAggregateType<T extends SellerBankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerBankDetails[P]>
      : GetScalarType<T[P], AggregateSellerBankDetails[P]>
  }




  export type SellerBankDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerBankDetailsWhereInput
    orderBy?: SellerBankDetailsOrderByWithAggregationInput | SellerBankDetailsOrderByWithAggregationInput[]
    by: SellerBankDetailsScalarFieldEnum[] | SellerBankDetailsScalarFieldEnum
    having?: SellerBankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerBankDetailsCountAggregateInputType | true
    _avg?: SellerBankDetailsAvgAggregateInputType
    _sum?: SellerBankDetailsSumAggregateInputType
    _min?: SellerBankDetailsMinAggregateInputType
    _max?: SellerBankDetailsMaxAggregateInputType
  }

  export type SellerBankDetailsGroupByOutputType = {
    id: number
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    sellerId: number
    createdAt: Date
    _count: SellerBankDetailsCountAggregateOutputType | null
    _avg: SellerBankDetailsAvgAggregateOutputType | null
    _sum: SellerBankDetailsSumAggregateOutputType | null
    _min: SellerBankDetailsMinAggregateOutputType | null
    _max: SellerBankDetailsMaxAggregateOutputType | null
  }

  type GetSellerBankDetailsGroupByPayload<T extends SellerBankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerBankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerBankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerBankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], SellerBankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type SellerBankDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountHolder?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBankDetails"]>

  export type SellerBankDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountHolder?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBankDetails"]>

  export type SellerBankDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountHolder?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerBankDetails"]>

  export type SellerBankDetailsSelectScalar = {
    id?: boolean
    accountHolder?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifsc?: boolean
    sellerId?: boolean
    createdAt?: boolean
  }

  export type SellerBankDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountHolder" | "bankName" | "accountNumber" | "ifsc" | "sellerId" | "createdAt", ExtArgs["result"]["sellerBankDetails"]>
  export type SellerBankDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerBankDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type SellerBankDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }

  export type $SellerBankDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerBankDetails"
    objects: {
      seller: Prisma.$SellerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountHolder: string
      bankName: string
      accountNumber: string
      ifsc: string
      sellerId: number
      createdAt: Date
    }, ExtArgs["result"]["sellerBankDetails"]>
    composites: {}
  }

  type SellerBankDetailsGetPayload<S extends boolean | null | undefined | SellerBankDetailsDefaultArgs> = $Result.GetResult<Prisma.$SellerBankDetailsPayload, S>

  type SellerBankDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerBankDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerBankDetailsCountAggregateInputType | true
    }

  export interface SellerBankDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerBankDetails'], meta: { name: 'SellerBankDetails' } }
    /**
     * Find zero or one SellerBankDetails that matches the filter.
     * @param {SellerBankDetailsFindUniqueArgs} args - Arguments to find a SellerBankDetails
     * @example
     * // Get one SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerBankDetailsFindUniqueArgs>(args: SelectSubset<T, SellerBankDetailsFindUniqueArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerBankDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerBankDetailsFindUniqueOrThrowArgs} args - Arguments to find a SellerBankDetails
     * @example
     * // Get one SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerBankDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerBankDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsFindFirstArgs} args - Arguments to find a SellerBankDetails
     * @example
     * // Get one SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerBankDetailsFindFirstArgs>(args?: SelectSubset<T, SellerBankDetailsFindFirstArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerBankDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsFindFirstOrThrowArgs} args - Arguments to find a SellerBankDetails
     * @example
     * // Get one SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerBankDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerBankDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findMany()
     * 
     * // Get first 10 SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerBankDetailsWithIdOnly = await prisma.sellerBankDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerBankDetailsFindManyArgs>(args?: SelectSubset<T, SellerBankDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerBankDetails.
     * @param {SellerBankDetailsCreateArgs} args - Arguments to create a SellerBankDetails.
     * @example
     * // Create one SellerBankDetails
     * const SellerBankDetails = await prisma.sellerBankDetails.create({
     *   data: {
     *     // ... data to create a SellerBankDetails
     *   }
     * })
     * 
     */
    create<T extends SellerBankDetailsCreateArgs>(args: SelectSubset<T, SellerBankDetailsCreateArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerBankDetails.
     * @param {SellerBankDetailsCreateManyArgs} args - Arguments to create many SellerBankDetails.
     * @example
     * // Create many SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerBankDetailsCreateManyArgs>(args?: SelectSubset<T, SellerBankDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerBankDetails and returns the data saved in the database.
     * @param {SellerBankDetailsCreateManyAndReturnArgs} args - Arguments to create many SellerBankDetails.
     * @example
     * // Create many SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerBankDetails and only return the `id`
     * const sellerBankDetailsWithIdOnly = await prisma.sellerBankDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerBankDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerBankDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerBankDetails.
     * @param {SellerBankDetailsDeleteArgs} args - Arguments to delete one SellerBankDetails.
     * @example
     * // Delete one SellerBankDetails
     * const SellerBankDetails = await prisma.sellerBankDetails.delete({
     *   where: {
     *     // ... filter to delete one SellerBankDetails
     *   }
     * })
     * 
     */
    delete<T extends SellerBankDetailsDeleteArgs>(args: SelectSubset<T, SellerBankDetailsDeleteArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerBankDetails.
     * @param {SellerBankDetailsUpdateArgs} args - Arguments to update one SellerBankDetails.
     * @example
     * // Update one SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerBankDetailsUpdateArgs>(args: SelectSubset<T, SellerBankDetailsUpdateArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerBankDetails.
     * @param {SellerBankDetailsDeleteManyArgs} args - Arguments to filter SellerBankDetails to delete.
     * @example
     * // Delete a few SellerBankDetails
     * const { count } = await prisma.sellerBankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerBankDetailsDeleteManyArgs>(args?: SelectSubset<T, SellerBankDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerBankDetailsUpdateManyArgs>(args: SelectSubset<T, SellerBankDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerBankDetails and returns the data updated in the database.
     * @param {SellerBankDetailsUpdateManyAndReturnArgs} args - Arguments to update many SellerBankDetails.
     * @example
     * // Update many SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerBankDetails and only return the `id`
     * const sellerBankDetailsWithIdOnly = await prisma.sellerBankDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerBankDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerBankDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerBankDetails.
     * @param {SellerBankDetailsUpsertArgs} args - Arguments to update or create a SellerBankDetails.
     * @example
     * // Update or create a SellerBankDetails
     * const sellerBankDetails = await prisma.sellerBankDetails.upsert({
     *   create: {
     *     // ... data to create a SellerBankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerBankDetails we want to update
     *   }
     * })
     */
    upsert<T extends SellerBankDetailsUpsertArgs>(args: SelectSubset<T, SellerBankDetailsUpsertArgs<ExtArgs>>): Prisma__SellerBankDetailsClient<$Result.GetResult<Prisma.$SellerBankDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsCountArgs} args - Arguments to filter SellerBankDetails to count.
     * @example
     * // Count the number of SellerBankDetails
     * const count = await prisma.sellerBankDetails.count({
     *   where: {
     *     // ... the filter for the SellerBankDetails we want to count
     *   }
     * })
    **/
    count<T extends SellerBankDetailsCountArgs>(
      args?: Subset<T, SellerBankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerBankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerBankDetailsAggregateArgs>(args: Subset<T, SellerBankDetailsAggregateArgs>): Prisma.PrismaPromise<GetSellerBankDetailsAggregateType<T>>

    /**
     * Group by SellerBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerBankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerBankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerBankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: SellerBankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerBankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerBankDetails model
   */
  readonly fields: SellerBankDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerBankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerBankDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends SellerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerDefaultArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerBankDetails model
   */
  interface SellerBankDetailsFieldRefs {
    readonly id: FieldRef<"SellerBankDetails", 'Int'>
    readonly accountHolder: FieldRef<"SellerBankDetails", 'String'>
    readonly bankName: FieldRef<"SellerBankDetails", 'String'>
    readonly accountNumber: FieldRef<"SellerBankDetails", 'String'>
    readonly ifsc: FieldRef<"SellerBankDetails", 'String'>
    readonly sellerId: FieldRef<"SellerBankDetails", 'Int'>
    readonly createdAt: FieldRef<"SellerBankDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerBankDetails findUnique
   */
  export type SellerBankDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBankDetails to fetch.
     */
    where: SellerBankDetailsWhereUniqueInput
  }

  /**
   * SellerBankDetails findUniqueOrThrow
   */
  export type SellerBankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBankDetails to fetch.
     */
    where: SellerBankDetailsWhereUniqueInput
  }

  /**
   * SellerBankDetails findFirst
   */
  export type SellerBankDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBankDetails to fetch.
     */
    where?: SellerBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBankDetails to fetch.
     */
    orderBy?: SellerBankDetailsOrderByWithRelationInput | SellerBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerBankDetails.
     */
    cursor?: SellerBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerBankDetails.
     */
    distinct?: SellerBankDetailsScalarFieldEnum | SellerBankDetailsScalarFieldEnum[]
  }

  /**
   * SellerBankDetails findFirstOrThrow
   */
  export type SellerBankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBankDetails to fetch.
     */
    where?: SellerBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBankDetails to fetch.
     */
    orderBy?: SellerBankDetailsOrderByWithRelationInput | SellerBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerBankDetails.
     */
    cursor?: SellerBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerBankDetails.
     */
    distinct?: SellerBankDetailsScalarFieldEnum | SellerBankDetailsScalarFieldEnum[]
  }

  /**
   * SellerBankDetails findMany
   */
  export type SellerBankDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which SellerBankDetails to fetch.
     */
    where?: SellerBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerBankDetails to fetch.
     */
    orderBy?: SellerBankDetailsOrderByWithRelationInput | SellerBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerBankDetails.
     */
    cursor?: SellerBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerBankDetails.
     */
    skip?: number
    distinct?: SellerBankDetailsScalarFieldEnum | SellerBankDetailsScalarFieldEnum[]
  }

  /**
   * SellerBankDetails create
   */
  export type SellerBankDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerBankDetails.
     */
    data: XOR<SellerBankDetailsCreateInput, SellerBankDetailsUncheckedCreateInput>
  }

  /**
   * SellerBankDetails createMany
   */
  export type SellerBankDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerBankDetails.
     */
    data: SellerBankDetailsCreateManyInput | SellerBankDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerBankDetails createManyAndReturn
   */
  export type SellerBankDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many SellerBankDetails.
     */
    data: SellerBankDetailsCreateManyInput | SellerBankDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerBankDetails update
   */
  export type SellerBankDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerBankDetails.
     */
    data: XOR<SellerBankDetailsUpdateInput, SellerBankDetailsUncheckedUpdateInput>
    /**
     * Choose, which SellerBankDetails to update.
     */
    where: SellerBankDetailsWhereUniqueInput
  }

  /**
   * SellerBankDetails updateMany
   */
  export type SellerBankDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerBankDetails.
     */
    data: XOR<SellerBankDetailsUpdateManyMutationInput, SellerBankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerBankDetails to update
     */
    where?: SellerBankDetailsWhereInput
    /**
     * Limit how many SellerBankDetails to update.
     */
    limit?: number
  }

  /**
   * SellerBankDetails updateManyAndReturn
   */
  export type SellerBankDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * The data used to update SellerBankDetails.
     */
    data: XOR<SellerBankDetailsUpdateManyMutationInput, SellerBankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SellerBankDetails to update
     */
    where?: SellerBankDetailsWhereInput
    /**
     * Limit how many SellerBankDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerBankDetails upsert
   */
  export type SellerBankDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerBankDetails to update in case it exists.
     */
    where: SellerBankDetailsWhereUniqueInput
    /**
     * In case the SellerBankDetails found by the `where` argument doesn't exist, create a new SellerBankDetails with this data.
     */
    create: XOR<SellerBankDetailsCreateInput, SellerBankDetailsUncheckedCreateInput>
    /**
     * In case the SellerBankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerBankDetailsUpdateInput, SellerBankDetailsUncheckedUpdateInput>
  }

  /**
   * SellerBankDetails delete
   */
  export type SellerBankDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
    /**
     * Filter which SellerBankDetails to delete.
     */
    where: SellerBankDetailsWhereUniqueInput
  }

  /**
   * SellerBankDetails deleteMany
   */
  export type SellerBankDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerBankDetails to delete
     */
    where?: SellerBankDetailsWhereInput
    /**
     * Limit how many SellerBankDetails to delete.
     */
    limit?: number
  }

  /**
   * SellerBankDetails without action
   */
  export type SellerBankDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerBankDetails
     */
    select?: SellerBankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerBankDetails
     */
    omit?: SellerBankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerBankDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    sellerId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    sellerId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    productType: string | null
    category: string | null
    description: string | null
    video: string | null
    availability: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    productType: string | null
    category: string | null
    description: string | null
    video: string | null
    availability: string | null
    sellerId: number | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    price: number
    productType: number
    category: number
    description: number
    images: number
    video: number
    availability: number
    sellerId: number
    createdAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    sellerId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    sellerId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    productType?: true
    category?: true
    description?: true
    video?: true
    availability?: true
    sellerId?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    productType?: true
    category?: true
    description?: true
    video?: true
    availability?: true
    sellerId?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    productType?: true
    category?: true
    description?: true
    images?: true
    video?: true
    availability?: true
    sellerId?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    price: number
    productType: string
    category: string
    description: string | null
    images: string[]
    video: string | null
    availability: string
    sellerId: number
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    productType?: boolean
    category?: boolean
    description?: boolean
    images?: boolean
    video?: boolean
    availability?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    productType?: boolean
    category?: boolean
    description?: boolean
    images?: boolean
    video?: boolean
    availability?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    productType?: boolean
    category?: boolean
    description?: boolean
    images?: boolean
    video?: boolean
    availability?: boolean
    sellerId?: boolean
    createdAt?: boolean
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    productType?: boolean
    category?: boolean
    description?: boolean
    images?: boolean
    video?: boolean
    availability?: boolean
    sellerId?: boolean
    createdAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "productType" | "category" | "description" | "images" | "video" | "availability" | "sellerId" | "createdAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      seller: Prisma.$SellerPayload<ExtArgs>
      ratings: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number
      productType: string
      category: string
      description: string | null
      images: string[]
      video: string | null
      availability: string
      sellerId: number
      createdAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends SellerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerDefaultArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ratings<T extends Product$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Product$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly productType: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly video: FieldRef<"Product", 'String'>
    readonly availability: FieldRef<"Product", 'String'>
    readonly sellerId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.ratings
   */
  export type Product$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    subtotal: number | null
    casaCharge: number | null
    deliveryCharge: number | null
    grandTotal: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    subtotal: number | null
    casaCharge: number | null
    deliveryCharge: number | null
    grandTotal: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    customerEmail: string | null
    customerName: string | null
    address: string | null
    paymentMethod: string | null
    subtotal: number | null
    casaCharge: number | null
    deliveryCharge: number | null
    grandTotal: number | null
    createdAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    customerEmail: string | null
    customerName: string | null
    address: string | null
    paymentMethod: string | null
    subtotal: number | null
    casaCharge: number | null
    deliveryCharge: number | null
    grandTotal: number | null
    createdAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    customerEmail: number
    customerName: number
    address: number
    paymentMethod: number
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    subtotal?: true
    casaCharge?: true
    deliveryCharge?: true
    grandTotal?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    subtotal?: true
    casaCharge?: true
    deliveryCharge?: true
    grandTotal?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    customerEmail?: true
    customerName?: true
    address?: true
    paymentMethod?: true
    subtotal?: true
    casaCharge?: true
    deliveryCharge?: true
    grandTotal?: true
    createdAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    customerEmail?: true
    customerName?: true
    address?: true
    paymentMethod?: true
    subtotal?: true
    casaCharge?: true
    deliveryCharge?: true
    grandTotal?: true
    createdAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    customerEmail?: true
    customerName?: true
    address?: true
    paymentMethod?: true
    subtotal?: true
    casaCharge?: true
    deliveryCharge?: true
    grandTotal?: true
    createdAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    userId: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerEmail?: boolean
    customerName?: boolean
    address?: boolean
    paymentMethod?: boolean
    subtotal?: boolean
    casaCharge?: boolean
    deliveryCharge?: boolean
    grandTotal?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerEmail?: boolean
    customerName?: boolean
    address?: boolean
    paymentMethod?: boolean
    subtotal?: boolean
    casaCharge?: boolean
    deliveryCharge?: boolean
    grandTotal?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    customerEmail?: boolean
    customerName?: boolean
    address?: boolean
    paymentMethod?: boolean
    subtotal?: boolean
    casaCharge?: boolean
    deliveryCharge?: boolean
    grandTotal?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    customerEmail?: boolean
    customerName?: boolean
    address?: boolean
    paymentMethod?: boolean
    subtotal?: boolean
    casaCharge?: boolean
    deliveryCharge?: boolean
    grandTotal?: boolean
    createdAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "customerEmail" | "customerName" | "address" | "paymentMethod" | "subtotal" | "casaCharge" | "deliveryCharge" | "grandTotal" | "createdAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      customerEmail: string
      customerName: string
      address: string
      paymentMethod: string
      subtotal: number
      casaCharge: number
      deliveryCharge: number
      grandTotal: number
      createdAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly address: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly subtotal: FieldRef<"Order", 'Float'>
    readonly casaCharge: FieldRef<"Order", 'Float'>
    readonly deliveryCharge: FieldRef<"Order", 'Float'>
    readonly grandTotal: FieldRef<"Order", 'Float'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    sellerId: number | null
    materialId: number | null
    quantity: number | null
    pricePerUnit: number | null
    totalAmount: number | null
    refundAmount: number | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingCharge: number | null
    installationCharge: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    sellerId: number | null
    materialId: number | null
    quantity: number | null
    pricePerUnit: number | null
    totalAmount: number | null
    refundAmount: number | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingCharge: number | null
    installationCharge: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    sellerId: number | null
    materialId: number | null
    materialName: string | null
    supplierName: string | null
    imageUrl: string | null
    quantity: number | null
    pricePerUnit: number | null
    totalAmount: number | null
    status: string | null
    returnStatus: $Enums.ReturnStatus | null
    returnReason: string | null
    returnRequestedAt: Date | null
    returnResolvedAt: Date | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus | null
    refundProcessedAt: Date | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string | null
    shippingCharge: number | null
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    sellerId: number | null
    materialId: number | null
    materialName: string | null
    supplierName: string | null
    imageUrl: string | null
    quantity: number | null
    pricePerUnit: number | null
    totalAmount: number | null
    status: string | null
    returnStatus: $Enums.ReturnStatus | null
    returnReason: string | null
    returnRequestedAt: Date | null
    returnResolvedAt: Date | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus | null
    refundProcessedAt: Date | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string | null
    shippingCharge: number | null
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: number
    supplierName: number
    imageUrl: number
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status: number
    returnStatus: number
    returnReason: number
    returnRequestedAt: number
    returnResolvedAt: number
    refundAmount: number
    refundStatus: number
    refundProcessedAt: number
    deliveryTimeMin: number
    deliveryTimeMax: number
    shippingChargeType: number
    shippingCharge: number
    installationAvailable: number
    installationCharge: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    sellerId?: true
    materialId?: true
    quantity?: true
    pricePerUnit?: true
    totalAmount?: true
    refundAmount?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingCharge?: true
    installationCharge?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    sellerId?: true
    materialId?: true
    quantity?: true
    pricePerUnit?: true
    totalAmount?: true
    refundAmount?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingCharge?: true
    installationCharge?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    sellerId?: true
    materialId?: true
    materialName?: true
    supplierName?: true
    imageUrl?: true
    quantity?: true
    pricePerUnit?: true
    totalAmount?: true
    status?: true
    returnStatus?: true
    returnReason?: true
    returnRequestedAt?: true
    returnResolvedAt?: true
    refundAmount?: true
    refundStatus?: true
    refundProcessedAt?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    sellerId?: true
    materialId?: true
    materialName?: true
    supplierName?: true
    imageUrl?: true
    quantity?: true
    pricePerUnit?: true
    totalAmount?: true
    status?: true
    returnStatus?: true
    returnReason?: true
    returnRequestedAt?: true
    returnResolvedAt?: true
    refundAmount?: true
    refundStatus?: true
    refundProcessedAt?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    sellerId?: true
    materialId?: true
    materialName?: true
    supplierName?: true
    imageUrl?: true
    quantity?: true
    pricePerUnit?: true
    totalAmount?: true
    status?: true
    returnStatus?: true
    returnReason?: true
    returnRequestedAt?: true
    returnResolvedAt?: true
    refundAmount?: true
    refundStatus?: true
    refundProcessedAt?: true
    deliveryTimeMin?: true
    deliveryTimeMax?: true
    shippingChargeType?: true
    shippingCharge?: true
    installationAvailable?: true
    installationCharge?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status: string
    returnStatus: $Enums.ReturnStatus
    returnReason: string | null
    returnRequestedAt: Date | null
    returnResolvedAt: Date | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus
    refundProcessedAt: Date | null
    deliveryTimeMin: number | null
    deliveryTimeMax: number | null
    shippingChargeType: string | null
    shippingCharge: number | null
    installationAvailable: string | null
    installationCharge: number | null
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    sellerId?: boolean
    materialId?: boolean
    materialName?: boolean
    supplierName?: boolean
    imageUrl?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalAmount?: boolean
    status?: boolean
    returnStatus?: boolean
    returnReason?: boolean
    returnRequestedAt?: boolean
    returnResolvedAt?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundProcessedAt?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
    rating?: boolean | OrderItem$ratingArgs<ExtArgs>
    returnRequest?: boolean | OrderItem$returnRequestArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    sellerId?: boolean
    materialId?: boolean
    materialName?: boolean
    supplierName?: boolean
    imageUrl?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalAmount?: boolean
    status?: boolean
    returnStatus?: boolean
    returnReason?: boolean
    returnRequestedAt?: boolean
    returnResolvedAt?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundProcessedAt?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    sellerId?: boolean
    materialId?: boolean
    materialName?: boolean
    supplierName?: boolean
    imageUrl?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalAmount?: boolean
    status?: boolean
    returnStatus?: boolean
    returnReason?: boolean
    returnRequestedAt?: boolean
    returnResolvedAt?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundProcessedAt?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    sellerId?: boolean
    materialId?: boolean
    materialName?: boolean
    supplierName?: boolean
    imageUrl?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalAmount?: boolean
    status?: boolean
    returnStatus?: boolean
    returnReason?: boolean
    returnRequestedAt?: boolean
    returnResolvedAt?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundProcessedAt?: boolean
    deliveryTimeMin?: boolean
    deliveryTimeMax?: boolean
    shippingChargeType?: boolean
    shippingCharge?: boolean
    installationAvailable?: boolean
    installationCharge?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "sellerId" | "materialId" | "materialName" | "supplierName" | "imageUrl" | "quantity" | "pricePerUnit" | "totalAmount" | "status" | "returnStatus" | "returnReason" | "returnRequestedAt" | "returnResolvedAt" | "refundAmount" | "refundStatus" | "refundProcessedAt" | "deliveryTimeMin" | "deliveryTimeMax" | "shippingChargeType" | "shippingCharge" | "installationAvailable" | "installationCharge" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
    rating?: boolean | OrderItem$ratingArgs<ExtArgs>
    returnRequest?: boolean | OrderItem$returnRequestArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    seller?: boolean | SellerDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      seller: Prisma.$SellerPayload<ExtArgs>
      rating: Prisma.$RatingPayload<ExtArgs> | null
      returnRequest: Prisma.$ReturnRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      sellerId: number
      materialId: number
      materialName: string
      supplierName: string
      imageUrl: string | null
      quantity: number
      pricePerUnit: number
      totalAmount: number
      status: string
      returnStatus: $Enums.ReturnStatus
      returnReason: string | null
      returnRequestedAt: Date | null
      returnResolvedAt: Date | null
      refundAmount: number | null
      refundStatus: $Enums.RefundStatus
      refundProcessedAt: Date | null
      deliveryTimeMin: number | null
      deliveryTimeMax: number | null
      shippingChargeType: string | null
      shippingCharge: number | null
      installationAvailable: string | null
      installationCharge: number | null
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends SellerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerDefaultArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rating<T extends OrderItem$ratingArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ratingArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    returnRequest<T extends OrderItem$returnRequestArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$returnRequestArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly sellerId: FieldRef<"OrderItem", 'Int'>
    readonly materialId: FieldRef<"OrderItem", 'Int'>
    readonly materialName: FieldRef<"OrderItem", 'String'>
    readonly supplierName: FieldRef<"OrderItem", 'String'>
    readonly imageUrl: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly pricePerUnit: FieldRef<"OrderItem", 'Float'>
    readonly totalAmount: FieldRef<"OrderItem", 'Float'>
    readonly status: FieldRef<"OrderItem", 'String'>
    readonly returnStatus: FieldRef<"OrderItem", 'ReturnStatus'>
    readonly returnReason: FieldRef<"OrderItem", 'String'>
    readonly returnRequestedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly returnResolvedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly refundAmount: FieldRef<"OrderItem", 'Float'>
    readonly refundStatus: FieldRef<"OrderItem", 'RefundStatus'>
    readonly refundProcessedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deliveryTimeMin: FieldRef<"OrderItem", 'Int'>
    readonly deliveryTimeMax: FieldRef<"OrderItem", 'Int'>
    readonly shippingChargeType: FieldRef<"OrderItem", 'String'>
    readonly shippingCharge: FieldRef<"OrderItem", 'Int'>
    readonly installationAvailable: FieldRef<"OrderItem", 'String'>
    readonly installationCharge: FieldRef<"OrderItem", 'Int'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.rating
   */
  export type OrderItem$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
  }

  /**
   * OrderItem.returnRequest
   */
  export type OrderItem$returnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    where?: ReturnRequestWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    stars: number | null
    userId: number | null
    productId: number | null
    orderItemId: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: number | null
    stars: number | null
    userId: number | null
    productId: number | null
    orderItemId: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: number | null
    stars: number | null
    comment: string | null
    createdAt: Date | null
    userId: number | null
    productId: number | null
    orderItemId: number | null
  }

  export type RatingMaxAggregateOutputType = {
    id: number | null
    stars: number | null
    comment: string | null
    createdAt: Date | null
    userId: number | null
    productId: number | null
    orderItemId: number | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    stars: number
    comment: number
    createdAt: number
    userId: number
    productId: number
    orderItemId: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    stars?: true
    userId?: true
    productId?: true
    orderItemId?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    stars?: true
    userId?: true
    productId?: true
    orderItemId?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    stars?: true
    comment?: true
    createdAt?: true
    userId?: true
    productId?: true
    orderItemId?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    stars?: true
    comment?: true
    createdAt?: true
    userId?: true
    productId?: true
    orderItemId?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    stars?: true
    comment?: true
    createdAt?: true
    userId?: true
    productId?: true
    orderItemId?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: number
    stars: number
    comment: string | null
    createdAt: Date
    userId: number
    productId: number
    orderItemId: number
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stars?: boolean
    comment?: boolean
    createdAt?: boolean
    userId?: boolean
    productId?: boolean
    orderItemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stars?: boolean
    comment?: boolean
    createdAt?: boolean
    userId?: boolean
    productId?: boolean
    orderItemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stars?: boolean
    comment?: boolean
    createdAt?: boolean
    userId?: boolean
    productId?: boolean
    orderItemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    stars?: boolean
    comment?: boolean
    createdAt?: boolean
    userId?: boolean
    productId?: boolean
    orderItemId?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stars" | "comment" | "createdAt" | "userId" | "productId" | "orderItemId", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stars: number
      comment: string | null
      createdAt: Date
      userId: number
      productId: number
      orderItemId: number
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'Int'>
    readonly stars: FieldRef<"Rating", 'Int'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly userId: FieldRef<"Rating", 'Int'>
    readonly productId: FieldRef<"Rating", 'Int'>
    readonly orderItemId: FieldRef<"Rating", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model Designer
   */

  export type AggregateDesigner = {
    _count: DesignerCountAggregateOutputType | null
    _avg: DesignerAvgAggregateOutputType | null
    _sum: DesignerSumAggregateOutputType | null
    _min: DesignerMinAggregateOutputType | null
    _max: DesignerMaxAggregateOutputType | null
  }

  export type DesignerAvgAggregateOutputType = {
    id: number | null
  }

  export type DesignerSumAggregateOutputType = {
    id: number | null
  }

  export type DesignerMinAggregateOutputType = {
    id: number | null
    fullname: string | null
    email: string | null
    mobile: string | null
    location: string | null
    passwordHash: string | null
    availability: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignerMaxAggregateOutputType = {
    id: number | null
    fullname: string | null
    email: string | null
    mobile: string | null
    location: string | null
    passwordHash: string | null
    availability: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignerCountAggregateOutputType = {
    id: number
    fullname: number
    email: number
    mobile: number
    location: number
    passwordHash: number
    availability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignerAvgAggregateInputType = {
    id?: true
  }

  export type DesignerSumAggregateInputType = {
    id?: true
  }

  export type DesignerMinAggregateInputType = {
    id?: true
    fullname?: true
    email?: true
    mobile?: true
    location?: true
    passwordHash?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignerMaxAggregateInputType = {
    id?: true
    fullname?: true
    email?: true
    mobile?: true
    location?: true
    passwordHash?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignerCountAggregateInputType = {
    id?: true
    fullname?: true
    email?: true
    mobile?: true
    location?: true
    passwordHash?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designer to aggregate.
     */
    where?: DesignerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designers to fetch.
     */
    orderBy?: DesignerOrderByWithRelationInput | DesignerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designers
    **/
    _count?: true | DesignerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerMaxAggregateInputType
  }

  export type GetDesignerAggregateType<T extends DesignerAggregateArgs> = {
        [P in keyof T & keyof AggregateDesigner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesigner[P]>
      : GetScalarType<T[P], AggregateDesigner[P]>
  }




  export type DesignerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerWhereInput
    orderBy?: DesignerOrderByWithAggregationInput | DesignerOrderByWithAggregationInput[]
    by: DesignerScalarFieldEnum[] | DesignerScalarFieldEnum
    having?: DesignerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerCountAggregateInputType | true
    _avg?: DesignerAvgAggregateInputType
    _sum?: DesignerSumAggregateInputType
    _min?: DesignerMinAggregateInputType
    _max?: DesignerMaxAggregateInputType
  }

  export type DesignerGroupByOutputType = {
    id: number
    fullname: string
    email: string
    mobile: string
    location: string | null
    passwordHash: string
    availability: string
    createdAt: Date
    updatedAt: Date
    _count: DesignerCountAggregateOutputType | null
    _avg: DesignerAvgAggregateOutputType | null
    _sum: DesignerSumAggregateOutputType | null
    _min: DesignerMinAggregateOutputType | null
    _max: DesignerMaxAggregateOutputType | null
  }

  type GetDesignerGroupByPayload<T extends DesignerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerGroupByOutputType[P]>
        }
      >
    >


  export type DesignerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    passwordHash?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | Designer$profileArgs<ExtArgs>
    works?: boolean | Designer$worksArgs<ExtArgs>
    hireRequests?: boolean | Designer$hireRequestsArgs<ExtArgs>
    ratings?: boolean | Designer$ratingsArgs<ExtArgs>
    userRatings?: boolean | Designer$userRatingsArgs<ExtArgs>
    _count?: boolean | DesignerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designer"]>

  export type DesignerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    passwordHash?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["designer"]>

  export type DesignerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    passwordHash?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["designer"]>

  export type DesignerSelectScalar = {
    id?: boolean
    fullname?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    passwordHash?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullname" | "email" | "mobile" | "location" | "passwordHash" | "availability" | "createdAt" | "updatedAt", ExtArgs["result"]["designer"]>
  export type DesignerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | Designer$profileArgs<ExtArgs>
    works?: boolean | Designer$worksArgs<ExtArgs>
    hireRequests?: boolean | Designer$hireRequestsArgs<ExtArgs>
    ratings?: boolean | Designer$ratingsArgs<ExtArgs>
    userRatings?: boolean | Designer$userRatingsArgs<ExtArgs>
    _count?: boolean | DesignerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DesignerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DesignerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DesignerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Designer"
    objects: {
      profile: Prisma.$DesignerProfilePayload<ExtArgs> | null
      works: Prisma.$DesignerWorkPayload<ExtArgs>[]
      hireRequests: Prisma.$DesignerHireRequestPayload<ExtArgs>[]
      ratings: Prisma.$DesignerRatingPayload<ExtArgs>[]
      userRatings: Prisma.$UserRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullname: string
      email: string
      mobile: string
      location: string | null
      passwordHash: string
      availability: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designer"]>
    composites: {}
  }

  type DesignerGetPayload<S extends boolean | null | undefined | DesignerDefaultArgs> = $Result.GetResult<Prisma.$DesignerPayload, S>

  type DesignerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerCountAggregateInputType | true
    }

  export interface DesignerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Designer'], meta: { name: 'Designer' } }
    /**
     * Find zero or one Designer that matches the filter.
     * @param {DesignerFindUniqueArgs} args - Arguments to find a Designer
     * @example
     * // Get one Designer
     * const designer = await prisma.designer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerFindUniqueArgs>(args: SelectSubset<T, DesignerFindUniqueArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Designer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerFindUniqueOrThrowArgs} args - Arguments to find a Designer
     * @example
     * // Get one Designer
     * const designer = await prisma.designer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerFindFirstArgs} args - Arguments to find a Designer
     * @example
     * // Get one Designer
     * const designer = await prisma.designer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerFindFirstArgs>(args?: SelectSubset<T, DesignerFindFirstArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerFindFirstOrThrowArgs} args - Arguments to find a Designer
     * @example
     * // Get one Designer
     * const designer = await prisma.designer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Designers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designers
     * const designers = await prisma.designer.findMany()
     * 
     * // Get first 10 Designers
     * const designers = await prisma.designer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerWithIdOnly = await prisma.designer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerFindManyArgs>(args?: SelectSubset<T, DesignerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Designer.
     * @param {DesignerCreateArgs} args - Arguments to create a Designer.
     * @example
     * // Create one Designer
     * const Designer = await prisma.designer.create({
     *   data: {
     *     // ... data to create a Designer
     *   }
     * })
     * 
     */
    create<T extends DesignerCreateArgs>(args: SelectSubset<T, DesignerCreateArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Designers.
     * @param {DesignerCreateManyArgs} args - Arguments to create many Designers.
     * @example
     * // Create many Designers
     * const designer = await prisma.designer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerCreateManyArgs>(args?: SelectSubset<T, DesignerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Designers and returns the data saved in the database.
     * @param {DesignerCreateManyAndReturnArgs} args - Arguments to create many Designers.
     * @example
     * // Create many Designers
     * const designer = await prisma.designer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Designers and only return the `id`
     * const designerWithIdOnly = await prisma.designer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Designer.
     * @param {DesignerDeleteArgs} args - Arguments to delete one Designer.
     * @example
     * // Delete one Designer
     * const Designer = await prisma.designer.delete({
     *   where: {
     *     // ... filter to delete one Designer
     *   }
     * })
     * 
     */
    delete<T extends DesignerDeleteArgs>(args: SelectSubset<T, DesignerDeleteArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Designer.
     * @param {DesignerUpdateArgs} args - Arguments to update one Designer.
     * @example
     * // Update one Designer
     * const designer = await prisma.designer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerUpdateArgs>(args: SelectSubset<T, DesignerUpdateArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Designers.
     * @param {DesignerDeleteManyArgs} args - Arguments to filter Designers to delete.
     * @example
     * // Delete a few Designers
     * const { count } = await prisma.designer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerDeleteManyArgs>(args?: SelectSubset<T, DesignerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designers
     * const designer = await prisma.designer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerUpdateManyArgs>(args: SelectSubset<T, DesignerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designers and returns the data updated in the database.
     * @param {DesignerUpdateManyAndReturnArgs} args - Arguments to update many Designers.
     * @example
     * // Update many Designers
     * const designer = await prisma.designer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Designers and only return the `id`
     * const designerWithIdOnly = await prisma.designer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Designer.
     * @param {DesignerUpsertArgs} args - Arguments to update or create a Designer.
     * @example
     * // Update or create a Designer
     * const designer = await prisma.designer.upsert({
     *   create: {
     *     // ... data to create a Designer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Designer we want to update
     *   }
     * })
     */
    upsert<T extends DesignerUpsertArgs>(args: SelectSubset<T, DesignerUpsertArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Designers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerCountArgs} args - Arguments to filter Designers to count.
     * @example
     * // Count the number of Designers
     * const count = await prisma.designer.count({
     *   where: {
     *     // ... the filter for the Designers we want to count
     *   }
     * })
    **/
    count<T extends DesignerCountArgs>(
      args?: Subset<T, DesignerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Designer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerAggregateArgs>(args: Subset<T, DesignerAggregateArgs>): Prisma.PrismaPromise<GetDesignerAggregateType<T>>

    /**
     * Group by Designer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerGroupByArgs['orderBy'] }
        : { orderBy?: DesignerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Designer model
   */
  readonly fields: DesignerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Designer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends Designer$profileArgs<ExtArgs> = {}>(args?: Subset<T, Designer$profileArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    works<T extends Designer$worksArgs<ExtArgs> = {}>(args?: Subset<T, Designer$worksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hireRequests<T extends Designer$hireRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Designer$hireRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Designer$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Designer$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRatings<T extends Designer$userRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Designer$userRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Designer model
   */
  interface DesignerFieldRefs {
    readonly id: FieldRef<"Designer", 'Int'>
    readonly fullname: FieldRef<"Designer", 'String'>
    readonly email: FieldRef<"Designer", 'String'>
    readonly mobile: FieldRef<"Designer", 'String'>
    readonly location: FieldRef<"Designer", 'String'>
    readonly passwordHash: FieldRef<"Designer", 'String'>
    readonly availability: FieldRef<"Designer", 'String'>
    readonly createdAt: FieldRef<"Designer", 'DateTime'>
    readonly updatedAt: FieldRef<"Designer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Designer findUnique
   */
  export type DesignerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter, which Designer to fetch.
     */
    where: DesignerWhereUniqueInput
  }

  /**
   * Designer findUniqueOrThrow
   */
  export type DesignerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter, which Designer to fetch.
     */
    where: DesignerWhereUniqueInput
  }

  /**
   * Designer findFirst
   */
  export type DesignerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter, which Designer to fetch.
     */
    where?: DesignerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designers to fetch.
     */
    orderBy?: DesignerOrderByWithRelationInput | DesignerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designers.
     */
    cursor?: DesignerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designers.
     */
    distinct?: DesignerScalarFieldEnum | DesignerScalarFieldEnum[]
  }

  /**
   * Designer findFirstOrThrow
   */
  export type DesignerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter, which Designer to fetch.
     */
    where?: DesignerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designers to fetch.
     */
    orderBy?: DesignerOrderByWithRelationInput | DesignerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designers.
     */
    cursor?: DesignerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designers.
     */
    distinct?: DesignerScalarFieldEnum | DesignerScalarFieldEnum[]
  }

  /**
   * Designer findMany
   */
  export type DesignerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter, which Designers to fetch.
     */
    where?: DesignerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designers to fetch.
     */
    orderBy?: DesignerOrderByWithRelationInput | DesignerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designers.
     */
    cursor?: DesignerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designers.
     */
    skip?: number
    distinct?: DesignerScalarFieldEnum | DesignerScalarFieldEnum[]
  }

  /**
   * Designer create
   */
  export type DesignerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * The data needed to create a Designer.
     */
    data: XOR<DesignerCreateInput, DesignerUncheckedCreateInput>
  }

  /**
   * Designer createMany
   */
  export type DesignerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Designers.
     */
    data: DesignerCreateManyInput | DesignerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Designer createManyAndReturn
   */
  export type DesignerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * The data used to create many Designers.
     */
    data: DesignerCreateManyInput | DesignerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Designer update
   */
  export type DesignerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * The data needed to update a Designer.
     */
    data: XOR<DesignerUpdateInput, DesignerUncheckedUpdateInput>
    /**
     * Choose, which Designer to update.
     */
    where: DesignerWhereUniqueInput
  }

  /**
   * Designer updateMany
   */
  export type DesignerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Designers.
     */
    data: XOR<DesignerUpdateManyMutationInput, DesignerUncheckedUpdateManyInput>
    /**
     * Filter which Designers to update
     */
    where?: DesignerWhereInput
    /**
     * Limit how many Designers to update.
     */
    limit?: number
  }

  /**
   * Designer updateManyAndReturn
   */
  export type DesignerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * The data used to update Designers.
     */
    data: XOR<DesignerUpdateManyMutationInput, DesignerUncheckedUpdateManyInput>
    /**
     * Filter which Designers to update
     */
    where?: DesignerWhereInput
    /**
     * Limit how many Designers to update.
     */
    limit?: number
  }

  /**
   * Designer upsert
   */
  export type DesignerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * The filter to search for the Designer to update in case it exists.
     */
    where: DesignerWhereUniqueInput
    /**
     * In case the Designer found by the `where` argument doesn't exist, create a new Designer with this data.
     */
    create: XOR<DesignerCreateInput, DesignerUncheckedCreateInput>
    /**
     * In case the Designer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerUpdateInput, DesignerUncheckedUpdateInput>
  }

  /**
   * Designer delete
   */
  export type DesignerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    /**
     * Filter which Designer to delete.
     */
    where: DesignerWhereUniqueInput
  }

  /**
   * Designer deleteMany
   */
  export type DesignerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designers to delete
     */
    where?: DesignerWhereInput
    /**
     * Limit how many Designers to delete.
     */
    limit?: number
  }

  /**
   * Designer.profile
   */
  export type Designer$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    where?: DesignerProfileWhereInput
  }

  /**
   * Designer.works
   */
  export type Designer$worksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    where?: DesignerWorkWhereInput
    orderBy?: DesignerWorkOrderByWithRelationInput | DesignerWorkOrderByWithRelationInput[]
    cursor?: DesignerWorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignerWorkScalarFieldEnum | DesignerWorkScalarFieldEnum[]
  }

  /**
   * Designer.hireRequests
   */
  export type Designer$hireRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    where?: DesignerHireRequestWhereInput
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    cursor?: DesignerHireRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignerHireRequestScalarFieldEnum | DesignerHireRequestScalarFieldEnum[]
  }

  /**
   * Designer.ratings
   */
  export type Designer$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    where?: DesignerRatingWhereInput
    orderBy?: DesignerRatingOrderByWithRelationInput | DesignerRatingOrderByWithRelationInput[]
    cursor?: DesignerRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignerRatingScalarFieldEnum | DesignerRatingScalarFieldEnum[]
  }

  /**
   * Designer.userRatings
   */
  export type Designer$userRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    cursor?: UserRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * Designer without action
   */
  export type DesignerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
  }


  /**
   * Model DesignerOtp
   */

  export type AggregateDesignerOtp = {
    _count: DesignerOtpCountAggregateOutputType | null
    _min: DesignerOtpMinAggregateOutputType | null
    _max: DesignerOtpMaxAggregateOutputType | null
  }

  export type DesignerOtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type DesignerOtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otpHash: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type DesignerOtpCountAggregateOutputType = {
    id: number
    email: number
    otpHash: number
    expiresAt: number
    verified: number
    createdAt: number
    _all: number
  }


  export type DesignerOtpMinAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type DesignerOtpMaxAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type DesignerOtpCountAggregateInputType = {
    id?: true
    email?: true
    otpHash?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type DesignerOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerOtp to aggregate.
     */
    where?: DesignerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerOtps to fetch.
     */
    orderBy?: DesignerOtpOrderByWithRelationInput | DesignerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignerOtps
    **/
    _count?: true | DesignerOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerOtpMaxAggregateInputType
  }

  export type GetDesignerOtpAggregateType<T extends DesignerOtpAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignerOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignerOtp[P]>
      : GetScalarType<T[P], AggregateDesignerOtp[P]>
  }




  export type DesignerOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerOtpWhereInput
    orderBy?: DesignerOtpOrderByWithAggregationInput | DesignerOtpOrderByWithAggregationInput[]
    by: DesignerOtpScalarFieldEnum[] | DesignerOtpScalarFieldEnum
    having?: DesignerOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerOtpCountAggregateInputType | true
    _min?: DesignerOtpMinAggregateInputType
    _max?: DesignerOtpMaxAggregateInputType
  }

  export type DesignerOtpGroupByOutputType = {
    id: string
    email: string
    otpHash: string
    expiresAt: Date
    verified: boolean
    createdAt: Date
    _count: DesignerOtpCountAggregateOutputType | null
    _min: DesignerOtpMinAggregateOutputType | null
    _max: DesignerOtpMaxAggregateOutputType | null
  }

  type GetDesignerOtpGroupByPayload<T extends DesignerOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerOtpGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerOtpGroupByOutputType[P]>
        }
      >
    >


  export type DesignerOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["designerOtp"]>

  export type DesignerOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["designerOtp"]>

  export type DesignerOtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["designerOtp"]>

  export type DesignerOtpSelectScalar = {
    id?: boolean
    email?: boolean
    otpHash?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type DesignerOtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otpHash" | "expiresAt" | "verified" | "createdAt", ExtArgs["result"]["designerOtp"]>

  export type $DesignerOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignerOtp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otpHash: string
      expiresAt: Date
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["designerOtp"]>
    composites: {}
  }

  type DesignerOtpGetPayload<S extends boolean | null | undefined | DesignerOtpDefaultArgs> = $Result.GetResult<Prisma.$DesignerOtpPayload, S>

  type DesignerOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerOtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerOtpCountAggregateInputType | true
    }

  export interface DesignerOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignerOtp'], meta: { name: 'DesignerOtp' } }
    /**
     * Find zero or one DesignerOtp that matches the filter.
     * @param {DesignerOtpFindUniqueArgs} args - Arguments to find a DesignerOtp
     * @example
     * // Get one DesignerOtp
     * const designerOtp = await prisma.designerOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerOtpFindUniqueArgs>(args: SelectSubset<T, DesignerOtpFindUniqueArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignerOtp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerOtpFindUniqueOrThrowArgs} args - Arguments to find a DesignerOtp
     * @example
     * // Get one DesignerOtp
     * const designerOtp = await prisma.designerOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpFindFirstArgs} args - Arguments to find a DesignerOtp
     * @example
     * // Get one DesignerOtp
     * const designerOtp = await prisma.designerOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerOtpFindFirstArgs>(args?: SelectSubset<T, DesignerOtpFindFirstArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpFindFirstOrThrowArgs} args - Arguments to find a DesignerOtp
     * @example
     * // Get one DesignerOtp
     * const designerOtp = await prisma.designerOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignerOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignerOtps
     * const designerOtps = await prisma.designerOtp.findMany()
     * 
     * // Get first 10 DesignerOtps
     * const designerOtps = await prisma.designerOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerOtpWithIdOnly = await prisma.designerOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerOtpFindManyArgs>(args?: SelectSubset<T, DesignerOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignerOtp.
     * @param {DesignerOtpCreateArgs} args - Arguments to create a DesignerOtp.
     * @example
     * // Create one DesignerOtp
     * const DesignerOtp = await prisma.designerOtp.create({
     *   data: {
     *     // ... data to create a DesignerOtp
     *   }
     * })
     * 
     */
    create<T extends DesignerOtpCreateArgs>(args: SelectSubset<T, DesignerOtpCreateArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignerOtps.
     * @param {DesignerOtpCreateManyArgs} args - Arguments to create many DesignerOtps.
     * @example
     * // Create many DesignerOtps
     * const designerOtp = await prisma.designerOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerOtpCreateManyArgs>(args?: SelectSubset<T, DesignerOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignerOtps and returns the data saved in the database.
     * @param {DesignerOtpCreateManyAndReturnArgs} args - Arguments to create many DesignerOtps.
     * @example
     * // Create many DesignerOtps
     * const designerOtp = await prisma.designerOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignerOtps and only return the `id`
     * const designerOtpWithIdOnly = await prisma.designerOtp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignerOtp.
     * @param {DesignerOtpDeleteArgs} args - Arguments to delete one DesignerOtp.
     * @example
     * // Delete one DesignerOtp
     * const DesignerOtp = await prisma.designerOtp.delete({
     *   where: {
     *     // ... filter to delete one DesignerOtp
     *   }
     * })
     * 
     */
    delete<T extends DesignerOtpDeleteArgs>(args: SelectSubset<T, DesignerOtpDeleteArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignerOtp.
     * @param {DesignerOtpUpdateArgs} args - Arguments to update one DesignerOtp.
     * @example
     * // Update one DesignerOtp
     * const designerOtp = await prisma.designerOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerOtpUpdateArgs>(args: SelectSubset<T, DesignerOtpUpdateArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignerOtps.
     * @param {DesignerOtpDeleteManyArgs} args - Arguments to filter DesignerOtps to delete.
     * @example
     * // Delete a few DesignerOtps
     * const { count } = await prisma.designerOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerOtpDeleteManyArgs>(args?: SelectSubset<T, DesignerOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignerOtps
     * const designerOtp = await prisma.designerOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerOtpUpdateManyArgs>(args: SelectSubset<T, DesignerOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerOtps and returns the data updated in the database.
     * @param {DesignerOtpUpdateManyAndReturnArgs} args - Arguments to update many DesignerOtps.
     * @example
     * // Update many DesignerOtps
     * const designerOtp = await prisma.designerOtp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignerOtps and only return the `id`
     * const designerOtpWithIdOnly = await prisma.designerOtp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerOtpUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerOtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignerOtp.
     * @param {DesignerOtpUpsertArgs} args - Arguments to update or create a DesignerOtp.
     * @example
     * // Update or create a DesignerOtp
     * const designerOtp = await prisma.designerOtp.upsert({
     *   create: {
     *     // ... data to create a DesignerOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignerOtp we want to update
     *   }
     * })
     */
    upsert<T extends DesignerOtpUpsertArgs>(args: SelectSubset<T, DesignerOtpUpsertArgs<ExtArgs>>): Prisma__DesignerOtpClient<$Result.GetResult<Prisma.$DesignerOtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignerOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpCountArgs} args - Arguments to filter DesignerOtps to count.
     * @example
     * // Count the number of DesignerOtps
     * const count = await prisma.designerOtp.count({
     *   where: {
     *     // ... the filter for the DesignerOtps we want to count
     *   }
     * })
    **/
    count<T extends DesignerOtpCountArgs>(
      args?: Subset<T, DesignerOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerOtpAggregateArgs>(args: Subset<T, DesignerOtpAggregateArgs>): Prisma.PrismaPromise<GetDesignerOtpAggregateType<T>>

    /**
     * Group by DesignerOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerOtpGroupByArgs['orderBy'] }
        : { orderBy?: DesignerOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignerOtp model
   */
  readonly fields: DesignerOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignerOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignerOtp model
   */
  interface DesignerOtpFieldRefs {
    readonly id: FieldRef<"DesignerOtp", 'String'>
    readonly email: FieldRef<"DesignerOtp", 'String'>
    readonly otpHash: FieldRef<"DesignerOtp", 'String'>
    readonly expiresAt: FieldRef<"DesignerOtp", 'DateTime'>
    readonly verified: FieldRef<"DesignerOtp", 'Boolean'>
    readonly createdAt: FieldRef<"DesignerOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignerOtp findUnique
   */
  export type DesignerOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter, which DesignerOtp to fetch.
     */
    where: DesignerOtpWhereUniqueInput
  }

  /**
   * DesignerOtp findUniqueOrThrow
   */
  export type DesignerOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter, which DesignerOtp to fetch.
     */
    where: DesignerOtpWhereUniqueInput
  }

  /**
   * DesignerOtp findFirst
   */
  export type DesignerOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter, which DesignerOtp to fetch.
     */
    where?: DesignerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerOtps to fetch.
     */
    orderBy?: DesignerOtpOrderByWithRelationInput | DesignerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerOtps.
     */
    cursor?: DesignerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerOtps.
     */
    distinct?: DesignerOtpScalarFieldEnum | DesignerOtpScalarFieldEnum[]
  }

  /**
   * DesignerOtp findFirstOrThrow
   */
  export type DesignerOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter, which DesignerOtp to fetch.
     */
    where?: DesignerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerOtps to fetch.
     */
    orderBy?: DesignerOtpOrderByWithRelationInput | DesignerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerOtps.
     */
    cursor?: DesignerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerOtps.
     */
    distinct?: DesignerOtpScalarFieldEnum | DesignerOtpScalarFieldEnum[]
  }

  /**
   * DesignerOtp findMany
   */
  export type DesignerOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter, which DesignerOtps to fetch.
     */
    where?: DesignerOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerOtps to fetch.
     */
    orderBy?: DesignerOtpOrderByWithRelationInput | DesignerOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignerOtps.
     */
    cursor?: DesignerOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerOtps.
     */
    skip?: number
    distinct?: DesignerOtpScalarFieldEnum | DesignerOtpScalarFieldEnum[]
  }

  /**
   * DesignerOtp create
   */
  export type DesignerOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * The data needed to create a DesignerOtp.
     */
    data: XOR<DesignerOtpCreateInput, DesignerOtpUncheckedCreateInput>
  }

  /**
   * DesignerOtp createMany
   */
  export type DesignerOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignerOtps.
     */
    data: DesignerOtpCreateManyInput | DesignerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerOtp createManyAndReturn
   */
  export type DesignerOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * The data used to create many DesignerOtps.
     */
    data: DesignerOtpCreateManyInput | DesignerOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerOtp update
   */
  export type DesignerOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * The data needed to update a DesignerOtp.
     */
    data: XOR<DesignerOtpUpdateInput, DesignerOtpUncheckedUpdateInput>
    /**
     * Choose, which DesignerOtp to update.
     */
    where: DesignerOtpWhereUniqueInput
  }

  /**
   * DesignerOtp updateMany
   */
  export type DesignerOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignerOtps.
     */
    data: XOR<DesignerOtpUpdateManyMutationInput, DesignerOtpUncheckedUpdateManyInput>
    /**
     * Filter which DesignerOtps to update
     */
    where?: DesignerOtpWhereInput
    /**
     * Limit how many DesignerOtps to update.
     */
    limit?: number
  }

  /**
   * DesignerOtp updateManyAndReturn
   */
  export type DesignerOtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * The data used to update DesignerOtps.
     */
    data: XOR<DesignerOtpUpdateManyMutationInput, DesignerOtpUncheckedUpdateManyInput>
    /**
     * Filter which DesignerOtps to update
     */
    where?: DesignerOtpWhereInput
    /**
     * Limit how many DesignerOtps to update.
     */
    limit?: number
  }

  /**
   * DesignerOtp upsert
   */
  export type DesignerOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * The filter to search for the DesignerOtp to update in case it exists.
     */
    where: DesignerOtpWhereUniqueInput
    /**
     * In case the DesignerOtp found by the `where` argument doesn't exist, create a new DesignerOtp with this data.
     */
    create: XOR<DesignerOtpCreateInput, DesignerOtpUncheckedCreateInput>
    /**
     * In case the DesignerOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerOtpUpdateInput, DesignerOtpUncheckedUpdateInput>
  }

  /**
   * DesignerOtp delete
   */
  export type DesignerOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
    /**
     * Filter which DesignerOtp to delete.
     */
    where: DesignerOtpWhereUniqueInput
  }

  /**
   * DesignerOtp deleteMany
   */
  export type DesignerOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerOtps to delete
     */
    where?: DesignerOtpWhereInput
    /**
     * Limit how many DesignerOtps to delete.
     */
    limit?: number
  }

  /**
   * DesignerOtp without action
   */
  export type DesignerOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerOtp
     */
    select?: DesignerOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerOtp
     */
    omit?: DesignerOtpOmit<ExtArgs> | null
  }


  /**
   * Model DesignerProfile
   */

  export type AggregateDesignerProfile = {
    _count: DesignerProfileCountAggregateOutputType | null
    _avg: DesignerProfileAvgAggregateOutputType | null
    _sum: DesignerProfileSumAggregateOutputType | null
    _min: DesignerProfileMinAggregateOutputType | null
    _max: DesignerProfileMaxAggregateOutputType | null
  }

  export type DesignerProfileAvgAggregateOutputType = {
    id: number | null
    designerId: number | null
  }

  export type DesignerProfileSumAggregateOutputType = {
    id: number | null
    designerId: number | null
  }

  export type DesignerProfileMinAggregateOutputType = {
    id: number | null
    designerId: number | null
    experience: string | null
    portfolio: string | null
    designerType: string | null
    bio: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignerProfileMaxAggregateOutputType = {
    id: number | null
    designerId: number | null
    experience: string | null
    portfolio: string | null
    designerType: string | null
    bio: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignerProfileCountAggregateOutputType = {
    id: number
    designerId: number
    experience: number
    portfolio: number
    designerType: number
    bio: number
    profileImage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignerProfileAvgAggregateInputType = {
    id?: true
    designerId?: true
  }

  export type DesignerProfileSumAggregateInputType = {
    id?: true
    designerId?: true
  }

  export type DesignerProfileMinAggregateInputType = {
    id?: true
    designerId?: true
    experience?: true
    portfolio?: true
    designerType?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignerProfileMaxAggregateInputType = {
    id?: true
    designerId?: true
    experience?: true
    portfolio?: true
    designerType?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignerProfileCountAggregateInputType = {
    id?: true
    designerId?: true
    experience?: true
    portfolio?: true
    designerType?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerProfile to aggregate.
     */
    where?: DesignerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerProfiles to fetch.
     */
    orderBy?: DesignerProfileOrderByWithRelationInput | DesignerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignerProfiles
    **/
    _count?: true | DesignerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerProfileMaxAggregateInputType
  }

  export type GetDesignerProfileAggregateType<T extends DesignerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignerProfile[P]>
      : GetScalarType<T[P], AggregateDesignerProfile[P]>
  }




  export type DesignerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerProfileWhereInput
    orderBy?: DesignerProfileOrderByWithAggregationInput | DesignerProfileOrderByWithAggregationInput[]
    by: DesignerProfileScalarFieldEnum[] | DesignerProfileScalarFieldEnum
    having?: DesignerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerProfileCountAggregateInputType | true
    _avg?: DesignerProfileAvgAggregateInputType
    _sum?: DesignerProfileSumAggregateInputType
    _min?: DesignerProfileMinAggregateInputType
    _max?: DesignerProfileMaxAggregateInputType
  }

  export type DesignerProfileGroupByOutputType = {
    id: number
    designerId: number
    experience: string | null
    portfolio: string | null
    designerType: string | null
    bio: string | null
    profileImage: string | null
    createdAt: Date
    updatedAt: Date
    _count: DesignerProfileCountAggregateOutputType | null
    _avg: DesignerProfileAvgAggregateOutputType | null
    _sum: DesignerProfileSumAggregateOutputType | null
    _min: DesignerProfileMinAggregateOutputType | null
    _max: DesignerProfileMaxAggregateOutputType | null
  }

  type GetDesignerProfileGroupByPayload<T extends DesignerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerProfileGroupByOutputType[P]>
        }
      >
    >


  export type DesignerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    experience?: boolean
    portfolio?: boolean
    designerType?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerProfile"]>

  export type DesignerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    experience?: boolean
    portfolio?: boolean
    designerType?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerProfile"]>

  export type DesignerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    experience?: boolean
    portfolio?: boolean
    designerType?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerProfile"]>

  export type DesignerProfileSelectScalar = {
    id?: boolean
    designerId?: boolean
    experience?: boolean
    portfolio?: boolean
    designerType?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designerId" | "experience" | "portfolio" | "designerType" | "bio" | "profileImage" | "createdAt" | "updatedAt", ExtArgs["result"]["designerProfile"]>
  export type DesignerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }
  export type DesignerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }
  export type DesignerProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }

  export type $DesignerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignerProfile"
    objects: {
      designer: Prisma.$DesignerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designerId: number
      experience: string | null
      portfolio: string | null
      designerType: string | null
      bio: string | null
      profileImage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designerProfile"]>
    composites: {}
  }

  type DesignerProfileGetPayload<S extends boolean | null | undefined | DesignerProfileDefaultArgs> = $Result.GetResult<Prisma.$DesignerProfilePayload, S>

  type DesignerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerProfileCountAggregateInputType | true
    }

  export interface DesignerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignerProfile'], meta: { name: 'DesignerProfile' } }
    /**
     * Find zero or one DesignerProfile that matches the filter.
     * @param {DesignerProfileFindUniqueArgs} args - Arguments to find a DesignerProfile
     * @example
     * // Get one DesignerProfile
     * const designerProfile = await prisma.designerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerProfileFindUniqueArgs>(args: SelectSubset<T, DesignerProfileFindUniqueArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerProfileFindUniqueOrThrowArgs} args - Arguments to find a DesignerProfile
     * @example
     * // Get one DesignerProfile
     * const designerProfile = await prisma.designerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileFindFirstArgs} args - Arguments to find a DesignerProfile
     * @example
     * // Get one DesignerProfile
     * const designerProfile = await prisma.designerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerProfileFindFirstArgs>(args?: SelectSubset<T, DesignerProfileFindFirstArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileFindFirstOrThrowArgs} args - Arguments to find a DesignerProfile
     * @example
     * // Get one DesignerProfile
     * const designerProfile = await prisma.designerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignerProfiles
     * const designerProfiles = await prisma.designerProfile.findMany()
     * 
     * // Get first 10 DesignerProfiles
     * const designerProfiles = await prisma.designerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerProfileWithIdOnly = await prisma.designerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerProfileFindManyArgs>(args?: SelectSubset<T, DesignerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignerProfile.
     * @param {DesignerProfileCreateArgs} args - Arguments to create a DesignerProfile.
     * @example
     * // Create one DesignerProfile
     * const DesignerProfile = await prisma.designerProfile.create({
     *   data: {
     *     // ... data to create a DesignerProfile
     *   }
     * })
     * 
     */
    create<T extends DesignerProfileCreateArgs>(args: SelectSubset<T, DesignerProfileCreateArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignerProfiles.
     * @param {DesignerProfileCreateManyArgs} args - Arguments to create many DesignerProfiles.
     * @example
     * // Create many DesignerProfiles
     * const designerProfile = await prisma.designerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerProfileCreateManyArgs>(args?: SelectSubset<T, DesignerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignerProfiles and returns the data saved in the database.
     * @param {DesignerProfileCreateManyAndReturnArgs} args - Arguments to create many DesignerProfiles.
     * @example
     * // Create many DesignerProfiles
     * const designerProfile = await prisma.designerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignerProfiles and only return the `id`
     * const designerProfileWithIdOnly = await prisma.designerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignerProfile.
     * @param {DesignerProfileDeleteArgs} args - Arguments to delete one DesignerProfile.
     * @example
     * // Delete one DesignerProfile
     * const DesignerProfile = await prisma.designerProfile.delete({
     *   where: {
     *     // ... filter to delete one DesignerProfile
     *   }
     * })
     * 
     */
    delete<T extends DesignerProfileDeleteArgs>(args: SelectSubset<T, DesignerProfileDeleteArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignerProfile.
     * @param {DesignerProfileUpdateArgs} args - Arguments to update one DesignerProfile.
     * @example
     * // Update one DesignerProfile
     * const designerProfile = await prisma.designerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerProfileUpdateArgs>(args: SelectSubset<T, DesignerProfileUpdateArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignerProfiles.
     * @param {DesignerProfileDeleteManyArgs} args - Arguments to filter DesignerProfiles to delete.
     * @example
     * // Delete a few DesignerProfiles
     * const { count } = await prisma.designerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerProfileDeleteManyArgs>(args?: SelectSubset<T, DesignerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignerProfiles
     * const designerProfile = await prisma.designerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerProfileUpdateManyArgs>(args: SelectSubset<T, DesignerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerProfiles and returns the data updated in the database.
     * @param {DesignerProfileUpdateManyAndReturnArgs} args - Arguments to update many DesignerProfiles.
     * @example
     * // Update many DesignerProfiles
     * const designerProfile = await prisma.designerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignerProfiles and only return the `id`
     * const designerProfileWithIdOnly = await prisma.designerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignerProfile.
     * @param {DesignerProfileUpsertArgs} args - Arguments to update or create a DesignerProfile.
     * @example
     * // Update or create a DesignerProfile
     * const designerProfile = await prisma.designerProfile.upsert({
     *   create: {
     *     // ... data to create a DesignerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignerProfile we want to update
     *   }
     * })
     */
    upsert<T extends DesignerProfileUpsertArgs>(args: SelectSubset<T, DesignerProfileUpsertArgs<ExtArgs>>): Prisma__DesignerProfileClient<$Result.GetResult<Prisma.$DesignerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileCountArgs} args - Arguments to filter DesignerProfiles to count.
     * @example
     * // Count the number of DesignerProfiles
     * const count = await prisma.designerProfile.count({
     *   where: {
     *     // ... the filter for the DesignerProfiles we want to count
     *   }
     * })
    **/
    count<T extends DesignerProfileCountArgs>(
      args?: Subset<T, DesignerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerProfileAggregateArgs>(args: Subset<T, DesignerProfileAggregateArgs>): Prisma.PrismaPromise<GetDesignerProfileAggregateType<T>>

    /**
     * Group by DesignerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerProfileGroupByArgs['orderBy'] }
        : { orderBy?: DesignerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignerProfile model
   */
  readonly fields: DesignerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    designer<T extends DesignerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerDefaultArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignerProfile model
   */
  interface DesignerProfileFieldRefs {
    readonly id: FieldRef<"DesignerProfile", 'Int'>
    readonly designerId: FieldRef<"DesignerProfile", 'Int'>
    readonly experience: FieldRef<"DesignerProfile", 'String'>
    readonly portfolio: FieldRef<"DesignerProfile", 'String'>
    readonly designerType: FieldRef<"DesignerProfile", 'String'>
    readonly bio: FieldRef<"DesignerProfile", 'String'>
    readonly profileImage: FieldRef<"DesignerProfile", 'String'>
    readonly createdAt: FieldRef<"DesignerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"DesignerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignerProfile findUnique
   */
  export type DesignerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DesignerProfile to fetch.
     */
    where: DesignerProfileWhereUniqueInput
  }

  /**
   * DesignerProfile findUniqueOrThrow
   */
  export type DesignerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DesignerProfile to fetch.
     */
    where: DesignerProfileWhereUniqueInput
  }

  /**
   * DesignerProfile findFirst
   */
  export type DesignerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DesignerProfile to fetch.
     */
    where?: DesignerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerProfiles to fetch.
     */
    orderBy?: DesignerProfileOrderByWithRelationInput | DesignerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerProfiles.
     */
    cursor?: DesignerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerProfiles.
     */
    distinct?: DesignerProfileScalarFieldEnum | DesignerProfileScalarFieldEnum[]
  }

  /**
   * DesignerProfile findFirstOrThrow
   */
  export type DesignerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DesignerProfile to fetch.
     */
    where?: DesignerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerProfiles to fetch.
     */
    orderBy?: DesignerProfileOrderByWithRelationInput | DesignerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerProfiles.
     */
    cursor?: DesignerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerProfiles.
     */
    distinct?: DesignerProfileScalarFieldEnum | DesignerProfileScalarFieldEnum[]
  }

  /**
   * DesignerProfile findMany
   */
  export type DesignerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DesignerProfiles to fetch.
     */
    where?: DesignerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerProfiles to fetch.
     */
    orderBy?: DesignerProfileOrderByWithRelationInput | DesignerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignerProfiles.
     */
    cursor?: DesignerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerProfiles.
     */
    skip?: number
    distinct?: DesignerProfileScalarFieldEnum | DesignerProfileScalarFieldEnum[]
  }

  /**
   * DesignerProfile create
   */
  export type DesignerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignerProfile.
     */
    data: XOR<DesignerProfileCreateInput, DesignerProfileUncheckedCreateInput>
  }

  /**
   * DesignerProfile createMany
   */
  export type DesignerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignerProfiles.
     */
    data: DesignerProfileCreateManyInput | DesignerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerProfile createManyAndReturn
   */
  export type DesignerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many DesignerProfiles.
     */
    data: DesignerProfileCreateManyInput | DesignerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerProfile update
   */
  export type DesignerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignerProfile.
     */
    data: XOR<DesignerProfileUpdateInput, DesignerProfileUncheckedUpdateInput>
    /**
     * Choose, which DesignerProfile to update.
     */
    where: DesignerProfileWhereUniqueInput
  }

  /**
   * DesignerProfile updateMany
   */
  export type DesignerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignerProfiles.
     */
    data: XOR<DesignerProfileUpdateManyMutationInput, DesignerProfileUncheckedUpdateManyInput>
    /**
     * Filter which DesignerProfiles to update
     */
    where?: DesignerProfileWhereInput
    /**
     * Limit how many DesignerProfiles to update.
     */
    limit?: number
  }

  /**
   * DesignerProfile updateManyAndReturn
   */
  export type DesignerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * The data used to update DesignerProfiles.
     */
    data: XOR<DesignerProfileUpdateManyMutationInput, DesignerProfileUncheckedUpdateManyInput>
    /**
     * Filter which DesignerProfiles to update
     */
    where?: DesignerProfileWhereInput
    /**
     * Limit how many DesignerProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerProfile upsert
   */
  export type DesignerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignerProfile to update in case it exists.
     */
    where: DesignerProfileWhereUniqueInput
    /**
     * In case the DesignerProfile found by the `where` argument doesn't exist, create a new DesignerProfile with this data.
     */
    create: XOR<DesignerProfileCreateInput, DesignerProfileUncheckedCreateInput>
    /**
     * In case the DesignerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerProfileUpdateInput, DesignerProfileUncheckedUpdateInput>
  }

  /**
   * DesignerProfile delete
   */
  export type DesignerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
    /**
     * Filter which DesignerProfile to delete.
     */
    where: DesignerProfileWhereUniqueInput
  }

  /**
   * DesignerProfile deleteMany
   */
  export type DesignerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerProfiles to delete
     */
    where?: DesignerProfileWhereInput
    /**
     * Limit how many DesignerProfiles to delete.
     */
    limit?: number
  }

  /**
   * DesignerProfile without action
   */
  export type DesignerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerProfile
     */
    select?: DesignerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerProfile
     */
    omit?: DesignerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerProfileInclude<ExtArgs> | null
  }


  /**
   * Model DesignerWork
   */

  export type AggregateDesignerWork = {
    _count: DesignerWorkCountAggregateOutputType | null
    _avg: DesignerWorkAvgAggregateOutputType | null
    _sum: DesignerWorkSumAggregateOutputType | null
    _min: DesignerWorkMinAggregateOutputType | null
    _max: DesignerWorkMaxAggregateOutputType | null
  }

  export type DesignerWorkAvgAggregateOutputType = {
    id: number | null
    designerId: number | null
  }

  export type DesignerWorkSumAggregateOutputType = {
    id: number | null
    designerId: number | null
  }

  export type DesignerWorkMinAggregateOutputType = {
    id: number | null
    designerId: number | null
    image: string | null
    description: string | null
    createdAt: Date | null
  }

  export type DesignerWorkMaxAggregateOutputType = {
    id: number | null
    designerId: number | null
    image: string | null
    description: string | null
    createdAt: Date | null
  }

  export type DesignerWorkCountAggregateOutputType = {
    id: number
    designerId: number
    image: number
    description: number
    createdAt: number
    _all: number
  }


  export type DesignerWorkAvgAggregateInputType = {
    id?: true
    designerId?: true
  }

  export type DesignerWorkSumAggregateInputType = {
    id?: true
    designerId?: true
  }

  export type DesignerWorkMinAggregateInputType = {
    id?: true
    designerId?: true
    image?: true
    description?: true
    createdAt?: true
  }

  export type DesignerWorkMaxAggregateInputType = {
    id?: true
    designerId?: true
    image?: true
    description?: true
    createdAt?: true
  }

  export type DesignerWorkCountAggregateInputType = {
    id?: true
    designerId?: true
    image?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type DesignerWorkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerWork to aggregate.
     */
    where?: DesignerWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerWorks to fetch.
     */
    orderBy?: DesignerWorkOrderByWithRelationInput | DesignerWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignerWorks
    **/
    _count?: true | DesignerWorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignerWorkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignerWorkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerWorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerWorkMaxAggregateInputType
  }

  export type GetDesignerWorkAggregateType<T extends DesignerWorkAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignerWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignerWork[P]>
      : GetScalarType<T[P], AggregateDesignerWork[P]>
  }




  export type DesignerWorkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerWorkWhereInput
    orderBy?: DesignerWorkOrderByWithAggregationInput | DesignerWorkOrderByWithAggregationInput[]
    by: DesignerWorkScalarFieldEnum[] | DesignerWorkScalarFieldEnum
    having?: DesignerWorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerWorkCountAggregateInputType | true
    _avg?: DesignerWorkAvgAggregateInputType
    _sum?: DesignerWorkSumAggregateInputType
    _min?: DesignerWorkMinAggregateInputType
    _max?: DesignerWorkMaxAggregateInputType
  }

  export type DesignerWorkGroupByOutputType = {
    id: number
    designerId: number
    image: string
    description: string | null
    createdAt: Date
    _count: DesignerWorkCountAggregateOutputType | null
    _avg: DesignerWorkAvgAggregateOutputType | null
    _sum: DesignerWorkSumAggregateOutputType | null
    _min: DesignerWorkMinAggregateOutputType | null
    _max: DesignerWorkMaxAggregateOutputType | null
  }

  type GetDesignerWorkGroupByPayload<T extends DesignerWorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerWorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerWorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerWorkGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerWorkGroupByOutputType[P]>
        }
      >
    >


  export type DesignerWorkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    image?: boolean
    description?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerWork"]>

  export type DesignerWorkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    image?: boolean
    description?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerWork"]>

  export type DesignerWorkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    image?: boolean
    description?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerWork"]>

  export type DesignerWorkSelectScalar = {
    id?: boolean
    designerId?: boolean
    image?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type DesignerWorkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designerId" | "image" | "description" | "createdAt", ExtArgs["result"]["designerWork"]>
  export type DesignerWorkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }
  export type DesignerWorkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }
  export type DesignerWorkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }

  export type $DesignerWorkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignerWork"
    objects: {
      designer: Prisma.$DesignerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designerId: number
      image: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["designerWork"]>
    composites: {}
  }

  type DesignerWorkGetPayload<S extends boolean | null | undefined | DesignerWorkDefaultArgs> = $Result.GetResult<Prisma.$DesignerWorkPayload, S>

  type DesignerWorkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerWorkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerWorkCountAggregateInputType | true
    }

  export interface DesignerWorkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignerWork'], meta: { name: 'DesignerWork' } }
    /**
     * Find zero or one DesignerWork that matches the filter.
     * @param {DesignerWorkFindUniqueArgs} args - Arguments to find a DesignerWork
     * @example
     * // Get one DesignerWork
     * const designerWork = await prisma.designerWork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerWorkFindUniqueArgs>(args: SelectSubset<T, DesignerWorkFindUniqueArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignerWork that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerWorkFindUniqueOrThrowArgs} args - Arguments to find a DesignerWork
     * @example
     * // Get one DesignerWork
     * const designerWork = await prisma.designerWork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerWorkFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerWorkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerWork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkFindFirstArgs} args - Arguments to find a DesignerWork
     * @example
     * // Get one DesignerWork
     * const designerWork = await prisma.designerWork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerWorkFindFirstArgs>(args?: SelectSubset<T, DesignerWorkFindFirstArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerWork that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkFindFirstOrThrowArgs} args - Arguments to find a DesignerWork
     * @example
     * // Get one DesignerWork
     * const designerWork = await prisma.designerWork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerWorkFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerWorkFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignerWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignerWorks
     * const designerWorks = await prisma.designerWork.findMany()
     * 
     * // Get first 10 DesignerWorks
     * const designerWorks = await prisma.designerWork.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerWorkWithIdOnly = await prisma.designerWork.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerWorkFindManyArgs>(args?: SelectSubset<T, DesignerWorkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignerWork.
     * @param {DesignerWorkCreateArgs} args - Arguments to create a DesignerWork.
     * @example
     * // Create one DesignerWork
     * const DesignerWork = await prisma.designerWork.create({
     *   data: {
     *     // ... data to create a DesignerWork
     *   }
     * })
     * 
     */
    create<T extends DesignerWorkCreateArgs>(args: SelectSubset<T, DesignerWorkCreateArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignerWorks.
     * @param {DesignerWorkCreateManyArgs} args - Arguments to create many DesignerWorks.
     * @example
     * // Create many DesignerWorks
     * const designerWork = await prisma.designerWork.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerWorkCreateManyArgs>(args?: SelectSubset<T, DesignerWorkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignerWorks and returns the data saved in the database.
     * @param {DesignerWorkCreateManyAndReturnArgs} args - Arguments to create many DesignerWorks.
     * @example
     * // Create many DesignerWorks
     * const designerWork = await prisma.designerWork.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignerWorks and only return the `id`
     * const designerWorkWithIdOnly = await prisma.designerWork.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerWorkCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerWorkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignerWork.
     * @param {DesignerWorkDeleteArgs} args - Arguments to delete one DesignerWork.
     * @example
     * // Delete one DesignerWork
     * const DesignerWork = await prisma.designerWork.delete({
     *   where: {
     *     // ... filter to delete one DesignerWork
     *   }
     * })
     * 
     */
    delete<T extends DesignerWorkDeleteArgs>(args: SelectSubset<T, DesignerWorkDeleteArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignerWork.
     * @param {DesignerWorkUpdateArgs} args - Arguments to update one DesignerWork.
     * @example
     * // Update one DesignerWork
     * const designerWork = await prisma.designerWork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerWorkUpdateArgs>(args: SelectSubset<T, DesignerWorkUpdateArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignerWorks.
     * @param {DesignerWorkDeleteManyArgs} args - Arguments to filter DesignerWorks to delete.
     * @example
     * // Delete a few DesignerWorks
     * const { count } = await prisma.designerWork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerWorkDeleteManyArgs>(args?: SelectSubset<T, DesignerWorkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignerWorks
     * const designerWork = await prisma.designerWork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerWorkUpdateManyArgs>(args: SelectSubset<T, DesignerWorkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerWorks and returns the data updated in the database.
     * @param {DesignerWorkUpdateManyAndReturnArgs} args - Arguments to update many DesignerWorks.
     * @example
     * // Update many DesignerWorks
     * const designerWork = await prisma.designerWork.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignerWorks and only return the `id`
     * const designerWorkWithIdOnly = await prisma.designerWork.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerWorkUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerWorkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignerWork.
     * @param {DesignerWorkUpsertArgs} args - Arguments to update or create a DesignerWork.
     * @example
     * // Update or create a DesignerWork
     * const designerWork = await prisma.designerWork.upsert({
     *   create: {
     *     // ... data to create a DesignerWork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignerWork we want to update
     *   }
     * })
     */
    upsert<T extends DesignerWorkUpsertArgs>(args: SelectSubset<T, DesignerWorkUpsertArgs<ExtArgs>>): Prisma__DesignerWorkClient<$Result.GetResult<Prisma.$DesignerWorkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignerWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkCountArgs} args - Arguments to filter DesignerWorks to count.
     * @example
     * // Count the number of DesignerWorks
     * const count = await prisma.designerWork.count({
     *   where: {
     *     // ... the filter for the DesignerWorks we want to count
     *   }
     * })
    **/
    count<T extends DesignerWorkCountArgs>(
      args?: Subset<T, DesignerWorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerWorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignerWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerWorkAggregateArgs>(args: Subset<T, DesignerWorkAggregateArgs>): Prisma.PrismaPromise<GetDesignerWorkAggregateType<T>>

    /**
     * Group by DesignerWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerWorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerWorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerWorkGroupByArgs['orderBy'] }
        : { orderBy?: DesignerWorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerWorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignerWork model
   */
  readonly fields: DesignerWorkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignerWork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerWorkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    designer<T extends DesignerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerDefaultArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignerWork model
   */
  interface DesignerWorkFieldRefs {
    readonly id: FieldRef<"DesignerWork", 'Int'>
    readonly designerId: FieldRef<"DesignerWork", 'Int'>
    readonly image: FieldRef<"DesignerWork", 'String'>
    readonly description: FieldRef<"DesignerWork", 'String'>
    readonly createdAt: FieldRef<"DesignerWork", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignerWork findUnique
   */
  export type DesignerWorkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter, which DesignerWork to fetch.
     */
    where: DesignerWorkWhereUniqueInput
  }

  /**
   * DesignerWork findUniqueOrThrow
   */
  export type DesignerWorkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter, which DesignerWork to fetch.
     */
    where: DesignerWorkWhereUniqueInput
  }

  /**
   * DesignerWork findFirst
   */
  export type DesignerWorkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter, which DesignerWork to fetch.
     */
    where?: DesignerWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerWorks to fetch.
     */
    orderBy?: DesignerWorkOrderByWithRelationInput | DesignerWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerWorks.
     */
    cursor?: DesignerWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerWorks.
     */
    distinct?: DesignerWorkScalarFieldEnum | DesignerWorkScalarFieldEnum[]
  }

  /**
   * DesignerWork findFirstOrThrow
   */
  export type DesignerWorkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter, which DesignerWork to fetch.
     */
    where?: DesignerWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerWorks to fetch.
     */
    orderBy?: DesignerWorkOrderByWithRelationInput | DesignerWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerWorks.
     */
    cursor?: DesignerWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerWorks.
     */
    distinct?: DesignerWorkScalarFieldEnum | DesignerWorkScalarFieldEnum[]
  }

  /**
   * DesignerWork findMany
   */
  export type DesignerWorkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter, which DesignerWorks to fetch.
     */
    where?: DesignerWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerWorks to fetch.
     */
    orderBy?: DesignerWorkOrderByWithRelationInput | DesignerWorkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignerWorks.
     */
    cursor?: DesignerWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerWorks.
     */
    skip?: number
    distinct?: DesignerWorkScalarFieldEnum | DesignerWorkScalarFieldEnum[]
  }

  /**
   * DesignerWork create
   */
  export type DesignerWorkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignerWork.
     */
    data: XOR<DesignerWorkCreateInput, DesignerWorkUncheckedCreateInput>
  }

  /**
   * DesignerWork createMany
   */
  export type DesignerWorkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignerWorks.
     */
    data: DesignerWorkCreateManyInput | DesignerWorkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerWork createManyAndReturn
   */
  export type DesignerWorkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * The data used to create many DesignerWorks.
     */
    data: DesignerWorkCreateManyInput | DesignerWorkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerWork update
   */
  export type DesignerWorkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignerWork.
     */
    data: XOR<DesignerWorkUpdateInput, DesignerWorkUncheckedUpdateInput>
    /**
     * Choose, which DesignerWork to update.
     */
    where: DesignerWorkWhereUniqueInput
  }

  /**
   * DesignerWork updateMany
   */
  export type DesignerWorkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignerWorks.
     */
    data: XOR<DesignerWorkUpdateManyMutationInput, DesignerWorkUncheckedUpdateManyInput>
    /**
     * Filter which DesignerWorks to update
     */
    where?: DesignerWorkWhereInput
    /**
     * Limit how many DesignerWorks to update.
     */
    limit?: number
  }

  /**
   * DesignerWork updateManyAndReturn
   */
  export type DesignerWorkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * The data used to update DesignerWorks.
     */
    data: XOR<DesignerWorkUpdateManyMutationInput, DesignerWorkUncheckedUpdateManyInput>
    /**
     * Filter which DesignerWorks to update
     */
    where?: DesignerWorkWhereInput
    /**
     * Limit how many DesignerWorks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerWork upsert
   */
  export type DesignerWorkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignerWork to update in case it exists.
     */
    where: DesignerWorkWhereUniqueInput
    /**
     * In case the DesignerWork found by the `where` argument doesn't exist, create a new DesignerWork with this data.
     */
    create: XOR<DesignerWorkCreateInput, DesignerWorkUncheckedCreateInput>
    /**
     * In case the DesignerWork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerWorkUpdateInput, DesignerWorkUncheckedUpdateInput>
  }

  /**
   * DesignerWork delete
   */
  export type DesignerWorkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
    /**
     * Filter which DesignerWork to delete.
     */
    where: DesignerWorkWhereUniqueInput
  }

  /**
   * DesignerWork deleteMany
   */
  export type DesignerWorkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerWorks to delete
     */
    where?: DesignerWorkWhereInput
    /**
     * Limit how many DesignerWorks to delete.
     */
    limit?: number
  }

  /**
   * DesignerWork without action
   */
  export type DesignerWorkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerWork
     */
    select?: DesignerWorkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerWork
     */
    omit?: DesignerWorkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerWorkInclude<ExtArgs> | null
  }


  /**
   * Model DesignerHireRequest
   */

  export type AggregateDesignerHireRequest = {
    _count: DesignerHireRequestCountAggregateOutputType | null
    _avg: DesignerHireRequestAvgAggregateOutputType | null
    _sum: DesignerHireRequestSumAggregateOutputType | null
    _min: DesignerHireRequestMinAggregateOutputType | null
    _max: DesignerHireRequestMaxAggregateOutputType | null
  }

  export type DesignerHireRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    designerId: number | null
    budget: number | null
  }

  export type DesignerHireRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
    designerId: number | null
    budget: number | null
  }

  export type DesignerHireRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    designerId: number | null
    fullName: string | null
    email: string | null
    mobile: string | null
    location: string | null
    budget: number | null
    workType: string | null
    timelineDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
  }

  export type DesignerHireRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    designerId: number | null
    fullName: string | null
    email: string | null
    mobile: string | null
    location: string | null
    budget: number | null
    workType: string | null
    timelineDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
  }

  export type DesignerHireRequestCountAggregateOutputType = {
    id: number
    userId: number
    designerId: number
    fullName: number
    email: number
    mobile: number
    location: number
    budget: number
    workType: number
    timelineDate: number
    description: number
    status: number
    createdAt: number
    _all: number
  }


  export type DesignerHireRequestAvgAggregateInputType = {
    id?: true
    userId?: true
    designerId?: true
    budget?: true
  }

  export type DesignerHireRequestSumAggregateInputType = {
    id?: true
    userId?: true
    designerId?: true
    budget?: true
  }

  export type DesignerHireRequestMinAggregateInputType = {
    id?: true
    userId?: true
    designerId?: true
    fullName?: true
    email?: true
    mobile?: true
    location?: true
    budget?: true
    workType?: true
    timelineDate?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type DesignerHireRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    designerId?: true
    fullName?: true
    email?: true
    mobile?: true
    location?: true
    budget?: true
    workType?: true
    timelineDate?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type DesignerHireRequestCountAggregateInputType = {
    id?: true
    userId?: true
    designerId?: true
    fullName?: true
    email?: true
    mobile?: true
    location?: true
    budget?: true
    workType?: true
    timelineDate?: true
    description?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type DesignerHireRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerHireRequest to aggregate.
     */
    where?: DesignerHireRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerHireRequests to fetch.
     */
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerHireRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerHireRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerHireRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignerHireRequests
    **/
    _count?: true | DesignerHireRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignerHireRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignerHireRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerHireRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerHireRequestMaxAggregateInputType
  }

  export type GetDesignerHireRequestAggregateType<T extends DesignerHireRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignerHireRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignerHireRequest[P]>
      : GetScalarType<T[P], AggregateDesignerHireRequest[P]>
  }




  export type DesignerHireRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerHireRequestWhereInput
    orderBy?: DesignerHireRequestOrderByWithAggregationInput | DesignerHireRequestOrderByWithAggregationInput[]
    by: DesignerHireRequestScalarFieldEnum[] | DesignerHireRequestScalarFieldEnum
    having?: DesignerHireRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerHireRequestCountAggregateInputType | true
    _avg?: DesignerHireRequestAvgAggregateInputType
    _sum?: DesignerHireRequestSumAggregateInputType
    _min?: DesignerHireRequestMinAggregateInputType
    _max?: DesignerHireRequestMaxAggregateInputType
  }

  export type DesignerHireRequestGroupByOutputType = {
    id: number
    userId: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate: Date | null
    description: string | null
    status: string
    createdAt: Date
    _count: DesignerHireRequestCountAggregateOutputType | null
    _avg: DesignerHireRequestAvgAggregateOutputType | null
    _sum: DesignerHireRequestSumAggregateOutputType | null
    _min: DesignerHireRequestMinAggregateOutputType | null
    _max: DesignerHireRequestMaxAggregateOutputType | null
  }

  type GetDesignerHireRequestGroupByPayload<T extends DesignerHireRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerHireRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerHireRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerHireRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerHireRequestGroupByOutputType[P]>
        }
      >
    >


  export type DesignerHireRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    designerId?: boolean
    fullName?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    budget?: boolean
    workType?: boolean
    timelineDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    rating?: boolean | DesignerHireRequest$ratingArgs<ExtArgs>
    userRating?: boolean | DesignerHireRequest$userRatingArgs<ExtArgs>
  }, ExtArgs["result"]["designerHireRequest"]>

  export type DesignerHireRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    designerId?: boolean
    fullName?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    budget?: boolean
    workType?: boolean
    timelineDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerHireRequest"]>

  export type DesignerHireRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    designerId?: boolean
    fullName?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    budget?: boolean
    workType?: boolean
    timelineDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerHireRequest"]>

  export type DesignerHireRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    designerId?: boolean
    fullName?: boolean
    email?: boolean
    mobile?: boolean
    location?: boolean
    budget?: boolean
    workType?: boolean
    timelineDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type DesignerHireRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "designerId" | "fullName" | "email" | "mobile" | "location" | "budget" | "workType" | "timelineDate" | "description" | "status" | "createdAt", ExtArgs["result"]["designerHireRequest"]>
  export type DesignerHireRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    rating?: boolean | DesignerHireRequest$ratingArgs<ExtArgs>
    userRating?: boolean | DesignerHireRequest$userRatingArgs<ExtArgs>
  }
  export type DesignerHireRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }
  export type DesignerHireRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
  }

  export type $DesignerHireRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignerHireRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      designer: Prisma.$DesignerPayload<ExtArgs>
      rating: Prisma.$DesignerRatingPayload<ExtArgs> | null
      userRating: Prisma.$UserRatingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      designerId: number
      fullName: string
      email: string
      mobile: string
      location: string
      budget: number
      workType: string
      timelineDate: Date | null
      description: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["designerHireRequest"]>
    composites: {}
  }

  type DesignerHireRequestGetPayload<S extends boolean | null | undefined | DesignerHireRequestDefaultArgs> = $Result.GetResult<Prisma.$DesignerHireRequestPayload, S>

  type DesignerHireRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerHireRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerHireRequestCountAggregateInputType | true
    }

  export interface DesignerHireRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignerHireRequest'], meta: { name: 'DesignerHireRequest' } }
    /**
     * Find zero or one DesignerHireRequest that matches the filter.
     * @param {DesignerHireRequestFindUniqueArgs} args - Arguments to find a DesignerHireRequest
     * @example
     * // Get one DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerHireRequestFindUniqueArgs>(args: SelectSubset<T, DesignerHireRequestFindUniqueArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignerHireRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerHireRequestFindUniqueOrThrowArgs} args - Arguments to find a DesignerHireRequest
     * @example
     * // Get one DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerHireRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerHireRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerHireRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestFindFirstArgs} args - Arguments to find a DesignerHireRequest
     * @example
     * // Get one DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerHireRequestFindFirstArgs>(args?: SelectSubset<T, DesignerHireRequestFindFirstArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerHireRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestFindFirstOrThrowArgs} args - Arguments to find a DesignerHireRequest
     * @example
     * // Get one DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerHireRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerHireRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignerHireRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignerHireRequests
     * const designerHireRequests = await prisma.designerHireRequest.findMany()
     * 
     * // Get first 10 DesignerHireRequests
     * const designerHireRequests = await prisma.designerHireRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerHireRequestWithIdOnly = await prisma.designerHireRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerHireRequestFindManyArgs>(args?: SelectSubset<T, DesignerHireRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignerHireRequest.
     * @param {DesignerHireRequestCreateArgs} args - Arguments to create a DesignerHireRequest.
     * @example
     * // Create one DesignerHireRequest
     * const DesignerHireRequest = await prisma.designerHireRequest.create({
     *   data: {
     *     // ... data to create a DesignerHireRequest
     *   }
     * })
     * 
     */
    create<T extends DesignerHireRequestCreateArgs>(args: SelectSubset<T, DesignerHireRequestCreateArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignerHireRequests.
     * @param {DesignerHireRequestCreateManyArgs} args - Arguments to create many DesignerHireRequests.
     * @example
     * // Create many DesignerHireRequests
     * const designerHireRequest = await prisma.designerHireRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerHireRequestCreateManyArgs>(args?: SelectSubset<T, DesignerHireRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignerHireRequests and returns the data saved in the database.
     * @param {DesignerHireRequestCreateManyAndReturnArgs} args - Arguments to create many DesignerHireRequests.
     * @example
     * // Create many DesignerHireRequests
     * const designerHireRequest = await prisma.designerHireRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignerHireRequests and only return the `id`
     * const designerHireRequestWithIdOnly = await prisma.designerHireRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerHireRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerHireRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignerHireRequest.
     * @param {DesignerHireRequestDeleteArgs} args - Arguments to delete one DesignerHireRequest.
     * @example
     * // Delete one DesignerHireRequest
     * const DesignerHireRequest = await prisma.designerHireRequest.delete({
     *   where: {
     *     // ... filter to delete one DesignerHireRequest
     *   }
     * })
     * 
     */
    delete<T extends DesignerHireRequestDeleteArgs>(args: SelectSubset<T, DesignerHireRequestDeleteArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignerHireRequest.
     * @param {DesignerHireRequestUpdateArgs} args - Arguments to update one DesignerHireRequest.
     * @example
     * // Update one DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerHireRequestUpdateArgs>(args: SelectSubset<T, DesignerHireRequestUpdateArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignerHireRequests.
     * @param {DesignerHireRequestDeleteManyArgs} args - Arguments to filter DesignerHireRequests to delete.
     * @example
     * // Delete a few DesignerHireRequests
     * const { count } = await prisma.designerHireRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerHireRequestDeleteManyArgs>(args?: SelectSubset<T, DesignerHireRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerHireRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignerHireRequests
     * const designerHireRequest = await prisma.designerHireRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerHireRequestUpdateManyArgs>(args: SelectSubset<T, DesignerHireRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerHireRequests and returns the data updated in the database.
     * @param {DesignerHireRequestUpdateManyAndReturnArgs} args - Arguments to update many DesignerHireRequests.
     * @example
     * // Update many DesignerHireRequests
     * const designerHireRequest = await prisma.designerHireRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignerHireRequests and only return the `id`
     * const designerHireRequestWithIdOnly = await prisma.designerHireRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerHireRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerHireRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignerHireRequest.
     * @param {DesignerHireRequestUpsertArgs} args - Arguments to update or create a DesignerHireRequest.
     * @example
     * // Update or create a DesignerHireRequest
     * const designerHireRequest = await prisma.designerHireRequest.upsert({
     *   create: {
     *     // ... data to create a DesignerHireRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignerHireRequest we want to update
     *   }
     * })
     */
    upsert<T extends DesignerHireRequestUpsertArgs>(args: SelectSubset<T, DesignerHireRequestUpsertArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignerHireRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestCountArgs} args - Arguments to filter DesignerHireRequests to count.
     * @example
     * // Count the number of DesignerHireRequests
     * const count = await prisma.designerHireRequest.count({
     *   where: {
     *     // ... the filter for the DesignerHireRequests we want to count
     *   }
     * })
    **/
    count<T extends DesignerHireRequestCountArgs>(
      args?: Subset<T, DesignerHireRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerHireRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignerHireRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerHireRequestAggregateArgs>(args: Subset<T, DesignerHireRequestAggregateArgs>): Prisma.PrismaPromise<GetDesignerHireRequestAggregateType<T>>

    /**
     * Group by DesignerHireRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerHireRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerHireRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerHireRequestGroupByArgs['orderBy'] }
        : { orderBy?: DesignerHireRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerHireRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerHireRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignerHireRequest model
   */
  readonly fields: DesignerHireRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignerHireRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerHireRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    designer<T extends DesignerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerDefaultArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rating<T extends DesignerHireRequest$ratingArgs<ExtArgs> = {}>(args?: Subset<T, DesignerHireRequest$ratingArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userRating<T extends DesignerHireRequest$userRatingArgs<ExtArgs> = {}>(args?: Subset<T, DesignerHireRequest$userRatingArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignerHireRequest model
   */
  interface DesignerHireRequestFieldRefs {
    readonly id: FieldRef<"DesignerHireRequest", 'Int'>
    readonly userId: FieldRef<"DesignerHireRequest", 'Int'>
    readonly designerId: FieldRef<"DesignerHireRequest", 'Int'>
    readonly fullName: FieldRef<"DesignerHireRequest", 'String'>
    readonly email: FieldRef<"DesignerHireRequest", 'String'>
    readonly mobile: FieldRef<"DesignerHireRequest", 'String'>
    readonly location: FieldRef<"DesignerHireRequest", 'String'>
    readonly budget: FieldRef<"DesignerHireRequest", 'Int'>
    readonly workType: FieldRef<"DesignerHireRequest", 'String'>
    readonly timelineDate: FieldRef<"DesignerHireRequest", 'DateTime'>
    readonly description: FieldRef<"DesignerHireRequest", 'String'>
    readonly status: FieldRef<"DesignerHireRequest", 'String'>
    readonly createdAt: FieldRef<"DesignerHireRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignerHireRequest findUnique
   */
  export type DesignerHireRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter, which DesignerHireRequest to fetch.
     */
    where: DesignerHireRequestWhereUniqueInput
  }

  /**
   * DesignerHireRequest findUniqueOrThrow
   */
  export type DesignerHireRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter, which DesignerHireRequest to fetch.
     */
    where: DesignerHireRequestWhereUniqueInput
  }

  /**
   * DesignerHireRequest findFirst
   */
  export type DesignerHireRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter, which DesignerHireRequest to fetch.
     */
    where?: DesignerHireRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerHireRequests to fetch.
     */
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerHireRequests.
     */
    cursor?: DesignerHireRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerHireRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerHireRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerHireRequests.
     */
    distinct?: DesignerHireRequestScalarFieldEnum | DesignerHireRequestScalarFieldEnum[]
  }

  /**
   * DesignerHireRequest findFirstOrThrow
   */
  export type DesignerHireRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter, which DesignerHireRequest to fetch.
     */
    where?: DesignerHireRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerHireRequests to fetch.
     */
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerHireRequests.
     */
    cursor?: DesignerHireRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerHireRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerHireRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerHireRequests.
     */
    distinct?: DesignerHireRequestScalarFieldEnum | DesignerHireRequestScalarFieldEnum[]
  }

  /**
   * DesignerHireRequest findMany
   */
  export type DesignerHireRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter, which DesignerHireRequests to fetch.
     */
    where?: DesignerHireRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerHireRequests to fetch.
     */
    orderBy?: DesignerHireRequestOrderByWithRelationInput | DesignerHireRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignerHireRequests.
     */
    cursor?: DesignerHireRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerHireRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerHireRequests.
     */
    skip?: number
    distinct?: DesignerHireRequestScalarFieldEnum | DesignerHireRequestScalarFieldEnum[]
  }

  /**
   * DesignerHireRequest create
   */
  export type DesignerHireRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignerHireRequest.
     */
    data: XOR<DesignerHireRequestCreateInput, DesignerHireRequestUncheckedCreateInput>
  }

  /**
   * DesignerHireRequest createMany
   */
  export type DesignerHireRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignerHireRequests.
     */
    data: DesignerHireRequestCreateManyInput | DesignerHireRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerHireRequest createManyAndReturn
   */
  export type DesignerHireRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DesignerHireRequests.
     */
    data: DesignerHireRequestCreateManyInput | DesignerHireRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerHireRequest update
   */
  export type DesignerHireRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignerHireRequest.
     */
    data: XOR<DesignerHireRequestUpdateInput, DesignerHireRequestUncheckedUpdateInput>
    /**
     * Choose, which DesignerHireRequest to update.
     */
    where: DesignerHireRequestWhereUniqueInput
  }

  /**
   * DesignerHireRequest updateMany
   */
  export type DesignerHireRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignerHireRequests.
     */
    data: XOR<DesignerHireRequestUpdateManyMutationInput, DesignerHireRequestUncheckedUpdateManyInput>
    /**
     * Filter which DesignerHireRequests to update
     */
    where?: DesignerHireRequestWhereInput
    /**
     * Limit how many DesignerHireRequests to update.
     */
    limit?: number
  }

  /**
   * DesignerHireRequest updateManyAndReturn
   */
  export type DesignerHireRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * The data used to update DesignerHireRequests.
     */
    data: XOR<DesignerHireRequestUpdateManyMutationInput, DesignerHireRequestUncheckedUpdateManyInput>
    /**
     * Filter which DesignerHireRequests to update
     */
    where?: DesignerHireRequestWhereInput
    /**
     * Limit how many DesignerHireRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerHireRequest upsert
   */
  export type DesignerHireRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignerHireRequest to update in case it exists.
     */
    where: DesignerHireRequestWhereUniqueInput
    /**
     * In case the DesignerHireRequest found by the `where` argument doesn't exist, create a new DesignerHireRequest with this data.
     */
    create: XOR<DesignerHireRequestCreateInput, DesignerHireRequestUncheckedCreateInput>
    /**
     * In case the DesignerHireRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerHireRequestUpdateInput, DesignerHireRequestUncheckedUpdateInput>
  }

  /**
   * DesignerHireRequest delete
   */
  export type DesignerHireRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
    /**
     * Filter which DesignerHireRequest to delete.
     */
    where: DesignerHireRequestWhereUniqueInput
  }

  /**
   * DesignerHireRequest deleteMany
   */
  export type DesignerHireRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerHireRequests to delete
     */
    where?: DesignerHireRequestWhereInput
    /**
     * Limit how many DesignerHireRequests to delete.
     */
    limit?: number
  }

  /**
   * DesignerHireRequest.rating
   */
  export type DesignerHireRequest$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    where?: DesignerRatingWhereInput
  }

  /**
   * DesignerHireRequest.userRating
   */
  export type DesignerHireRequest$userRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    where?: UserRatingWhereInput
  }

  /**
   * DesignerHireRequest without action
   */
  export type DesignerHireRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerHireRequest
     */
    select?: DesignerHireRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerHireRequest
     */
    omit?: DesignerHireRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerHireRequestInclude<ExtArgs> | null
  }


  /**
   * Model DesignerRating
   */

  export type AggregateDesignerRating = {
    _count: DesignerRatingCountAggregateOutputType | null
    _avg: DesignerRatingAvgAggregateOutputType | null
    _sum: DesignerRatingSumAggregateOutputType | null
    _min: DesignerRatingMinAggregateOutputType | null
    _max: DesignerRatingMaxAggregateOutputType | null
  }

  export type DesignerRatingAvgAggregateOutputType = {
    id: number | null
    designerId: number | null
    hireRequestId: number | null
    stars: number | null
  }

  export type DesignerRatingSumAggregateOutputType = {
    id: number | null
    designerId: number | null
    hireRequestId: number | null
    stars: number | null
  }

  export type DesignerRatingMinAggregateOutputType = {
    id: number | null
    designerId: number | null
    hireRequestId: number | null
    reviewerName: string | null
    stars: number | null
    review: string | null
    createdAt: Date | null
  }

  export type DesignerRatingMaxAggregateOutputType = {
    id: number | null
    designerId: number | null
    hireRequestId: number | null
    reviewerName: string | null
    stars: number | null
    review: string | null
    createdAt: Date | null
  }

  export type DesignerRatingCountAggregateOutputType = {
    id: number
    designerId: number
    hireRequestId: number
    reviewerName: number
    stars: number
    review: number
    createdAt: number
    _all: number
  }


  export type DesignerRatingAvgAggregateInputType = {
    id?: true
    designerId?: true
    hireRequestId?: true
    stars?: true
  }

  export type DesignerRatingSumAggregateInputType = {
    id?: true
    designerId?: true
    hireRequestId?: true
    stars?: true
  }

  export type DesignerRatingMinAggregateInputType = {
    id?: true
    designerId?: true
    hireRequestId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
  }

  export type DesignerRatingMaxAggregateInputType = {
    id?: true
    designerId?: true
    hireRequestId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
  }

  export type DesignerRatingCountAggregateInputType = {
    id?: true
    designerId?: true
    hireRequestId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
    _all?: true
  }

  export type DesignerRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerRating to aggregate.
     */
    where?: DesignerRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerRatings to fetch.
     */
    orderBy?: DesignerRatingOrderByWithRelationInput | DesignerRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignerRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignerRatings
    **/
    _count?: true | DesignerRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignerRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignerRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignerRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignerRatingMaxAggregateInputType
  }

  export type GetDesignerRatingAggregateType<T extends DesignerRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignerRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignerRating[P]>
      : GetScalarType<T[P], AggregateDesignerRating[P]>
  }




  export type DesignerRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignerRatingWhereInput
    orderBy?: DesignerRatingOrderByWithAggregationInput | DesignerRatingOrderByWithAggregationInput[]
    by: DesignerRatingScalarFieldEnum[] | DesignerRatingScalarFieldEnum
    having?: DesignerRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignerRatingCountAggregateInputType | true
    _avg?: DesignerRatingAvgAggregateInputType
    _sum?: DesignerRatingSumAggregateInputType
    _min?: DesignerRatingMinAggregateInputType
    _max?: DesignerRatingMaxAggregateInputType
  }

  export type DesignerRatingGroupByOutputType = {
    id: number
    designerId: number
    hireRequestId: number
    reviewerName: string | null
    stars: number
    review: string | null
    createdAt: Date
    _count: DesignerRatingCountAggregateOutputType | null
    _avg: DesignerRatingAvgAggregateOutputType | null
    _sum: DesignerRatingSumAggregateOutputType | null
    _min: DesignerRatingMinAggregateOutputType | null
    _max: DesignerRatingMaxAggregateOutputType | null
  }

  type GetDesignerRatingGroupByPayload<T extends DesignerRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignerRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignerRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignerRatingGroupByOutputType[P]>
            : GetScalarType<T[P], DesignerRatingGroupByOutputType[P]>
        }
      >
    >


  export type DesignerRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    hireRequestId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerRating"]>

  export type DesignerRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    hireRequestId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerRating"]>

  export type DesignerRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designerId?: boolean
    hireRequestId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designerRating"]>

  export type DesignerRatingSelectScalar = {
    id?: boolean
    designerId?: boolean
    hireRequestId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
  }

  export type DesignerRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designerId" | "hireRequestId" | "reviewerName" | "stars" | "review" | "createdAt", ExtArgs["result"]["designerRating"]>
  export type DesignerRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }
  export type DesignerRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }
  export type DesignerRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designer?: boolean | DesignerDefaultArgs<ExtArgs>
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
  }

  export type $DesignerRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignerRating"
    objects: {
      designer: Prisma.$DesignerPayload<ExtArgs>
      hireRequest: Prisma.$DesignerHireRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designerId: number
      hireRequestId: number
      reviewerName: string | null
      stars: number
      review: string | null
      createdAt: Date
    }, ExtArgs["result"]["designerRating"]>
    composites: {}
  }

  type DesignerRatingGetPayload<S extends boolean | null | undefined | DesignerRatingDefaultArgs> = $Result.GetResult<Prisma.$DesignerRatingPayload, S>

  type DesignerRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignerRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignerRatingCountAggregateInputType | true
    }

  export interface DesignerRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignerRating'], meta: { name: 'DesignerRating' } }
    /**
     * Find zero or one DesignerRating that matches the filter.
     * @param {DesignerRatingFindUniqueArgs} args - Arguments to find a DesignerRating
     * @example
     * // Get one DesignerRating
     * const designerRating = await prisma.designerRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignerRatingFindUniqueArgs>(args: SelectSubset<T, DesignerRatingFindUniqueArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DesignerRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignerRatingFindUniqueOrThrowArgs} args - Arguments to find a DesignerRating
     * @example
     * // Get one DesignerRating
     * const designerRating = await prisma.designerRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignerRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignerRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingFindFirstArgs} args - Arguments to find a DesignerRating
     * @example
     * // Get one DesignerRating
     * const designerRating = await prisma.designerRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignerRatingFindFirstArgs>(args?: SelectSubset<T, DesignerRatingFindFirstArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DesignerRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingFindFirstOrThrowArgs} args - Arguments to find a DesignerRating
     * @example
     * // Get one DesignerRating
     * const designerRating = await prisma.designerRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignerRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignerRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DesignerRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignerRatings
     * const designerRatings = await prisma.designerRating.findMany()
     * 
     * // Get first 10 DesignerRatings
     * const designerRatings = await prisma.designerRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designerRatingWithIdOnly = await prisma.designerRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignerRatingFindManyArgs>(args?: SelectSubset<T, DesignerRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DesignerRating.
     * @param {DesignerRatingCreateArgs} args - Arguments to create a DesignerRating.
     * @example
     * // Create one DesignerRating
     * const DesignerRating = await prisma.designerRating.create({
     *   data: {
     *     // ... data to create a DesignerRating
     *   }
     * })
     * 
     */
    create<T extends DesignerRatingCreateArgs>(args: SelectSubset<T, DesignerRatingCreateArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DesignerRatings.
     * @param {DesignerRatingCreateManyArgs} args - Arguments to create many DesignerRatings.
     * @example
     * // Create many DesignerRatings
     * const designerRating = await prisma.designerRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignerRatingCreateManyArgs>(args?: SelectSubset<T, DesignerRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignerRatings and returns the data saved in the database.
     * @param {DesignerRatingCreateManyAndReturnArgs} args - Arguments to create many DesignerRatings.
     * @example
     * // Create many DesignerRatings
     * const designerRating = await prisma.designerRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignerRatings and only return the `id`
     * const designerRatingWithIdOnly = await prisma.designerRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignerRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignerRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DesignerRating.
     * @param {DesignerRatingDeleteArgs} args - Arguments to delete one DesignerRating.
     * @example
     * // Delete one DesignerRating
     * const DesignerRating = await prisma.designerRating.delete({
     *   where: {
     *     // ... filter to delete one DesignerRating
     *   }
     * })
     * 
     */
    delete<T extends DesignerRatingDeleteArgs>(args: SelectSubset<T, DesignerRatingDeleteArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DesignerRating.
     * @param {DesignerRatingUpdateArgs} args - Arguments to update one DesignerRating.
     * @example
     * // Update one DesignerRating
     * const designerRating = await prisma.designerRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignerRatingUpdateArgs>(args: SelectSubset<T, DesignerRatingUpdateArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DesignerRatings.
     * @param {DesignerRatingDeleteManyArgs} args - Arguments to filter DesignerRatings to delete.
     * @example
     * // Delete a few DesignerRatings
     * const { count } = await prisma.designerRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignerRatingDeleteManyArgs>(args?: SelectSubset<T, DesignerRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignerRatings
     * const designerRating = await prisma.designerRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignerRatingUpdateManyArgs>(args: SelectSubset<T, DesignerRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignerRatings and returns the data updated in the database.
     * @param {DesignerRatingUpdateManyAndReturnArgs} args - Arguments to update many DesignerRatings.
     * @example
     * // Update many DesignerRatings
     * const designerRating = await prisma.designerRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DesignerRatings and only return the `id`
     * const designerRatingWithIdOnly = await prisma.designerRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignerRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignerRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DesignerRating.
     * @param {DesignerRatingUpsertArgs} args - Arguments to update or create a DesignerRating.
     * @example
     * // Update or create a DesignerRating
     * const designerRating = await prisma.designerRating.upsert({
     *   create: {
     *     // ... data to create a DesignerRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignerRating we want to update
     *   }
     * })
     */
    upsert<T extends DesignerRatingUpsertArgs>(args: SelectSubset<T, DesignerRatingUpsertArgs<ExtArgs>>): Prisma__DesignerRatingClient<$Result.GetResult<Prisma.$DesignerRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DesignerRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingCountArgs} args - Arguments to filter DesignerRatings to count.
     * @example
     * // Count the number of DesignerRatings
     * const count = await prisma.designerRating.count({
     *   where: {
     *     // ... the filter for the DesignerRatings we want to count
     *   }
     * })
    **/
    count<T extends DesignerRatingCountArgs>(
      args?: Subset<T, DesignerRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignerRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignerRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignerRatingAggregateArgs>(args: Subset<T, DesignerRatingAggregateArgs>): Prisma.PrismaPromise<GetDesignerRatingAggregateType<T>>

    /**
     * Group by DesignerRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignerRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignerRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignerRatingGroupByArgs['orderBy'] }
        : { orderBy?: DesignerRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignerRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignerRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignerRating model
   */
  readonly fields: DesignerRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignerRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignerRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    designer<T extends DesignerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerDefaultArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hireRequest<T extends DesignerHireRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerHireRequestDefaultArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignerRating model
   */
  interface DesignerRatingFieldRefs {
    readonly id: FieldRef<"DesignerRating", 'Int'>
    readonly designerId: FieldRef<"DesignerRating", 'Int'>
    readonly hireRequestId: FieldRef<"DesignerRating", 'Int'>
    readonly reviewerName: FieldRef<"DesignerRating", 'String'>
    readonly stars: FieldRef<"DesignerRating", 'Int'>
    readonly review: FieldRef<"DesignerRating", 'String'>
    readonly createdAt: FieldRef<"DesignerRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DesignerRating findUnique
   */
  export type DesignerRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter, which DesignerRating to fetch.
     */
    where: DesignerRatingWhereUniqueInput
  }

  /**
   * DesignerRating findUniqueOrThrow
   */
  export type DesignerRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter, which DesignerRating to fetch.
     */
    where: DesignerRatingWhereUniqueInput
  }

  /**
   * DesignerRating findFirst
   */
  export type DesignerRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter, which DesignerRating to fetch.
     */
    where?: DesignerRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerRatings to fetch.
     */
    orderBy?: DesignerRatingOrderByWithRelationInput | DesignerRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerRatings.
     */
    cursor?: DesignerRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerRatings.
     */
    distinct?: DesignerRatingScalarFieldEnum | DesignerRatingScalarFieldEnum[]
  }

  /**
   * DesignerRating findFirstOrThrow
   */
  export type DesignerRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter, which DesignerRating to fetch.
     */
    where?: DesignerRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerRatings to fetch.
     */
    orderBy?: DesignerRatingOrderByWithRelationInput | DesignerRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignerRatings.
     */
    cursor?: DesignerRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignerRatings.
     */
    distinct?: DesignerRatingScalarFieldEnum | DesignerRatingScalarFieldEnum[]
  }

  /**
   * DesignerRating findMany
   */
  export type DesignerRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter, which DesignerRatings to fetch.
     */
    where?: DesignerRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignerRatings to fetch.
     */
    orderBy?: DesignerRatingOrderByWithRelationInput | DesignerRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignerRatings.
     */
    cursor?: DesignerRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignerRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignerRatings.
     */
    skip?: number
    distinct?: DesignerRatingScalarFieldEnum | DesignerRatingScalarFieldEnum[]
  }

  /**
   * DesignerRating create
   */
  export type DesignerRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignerRating.
     */
    data: XOR<DesignerRatingCreateInput, DesignerRatingUncheckedCreateInput>
  }

  /**
   * DesignerRating createMany
   */
  export type DesignerRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignerRatings.
     */
    data: DesignerRatingCreateManyInput | DesignerRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignerRating createManyAndReturn
   */
  export type DesignerRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * The data used to create many DesignerRatings.
     */
    data: DesignerRatingCreateManyInput | DesignerRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerRating update
   */
  export type DesignerRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignerRating.
     */
    data: XOR<DesignerRatingUpdateInput, DesignerRatingUncheckedUpdateInput>
    /**
     * Choose, which DesignerRating to update.
     */
    where: DesignerRatingWhereUniqueInput
  }

  /**
   * DesignerRating updateMany
   */
  export type DesignerRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignerRatings.
     */
    data: XOR<DesignerRatingUpdateManyMutationInput, DesignerRatingUncheckedUpdateManyInput>
    /**
     * Filter which DesignerRatings to update
     */
    where?: DesignerRatingWhereInput
    /**
     * Limit how many DesignerRatings to update.
     */
    limit?: number
  }

  /**
   * DesignerRating updateManyAndReturn
   */
  export type DesignerRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * The data used to update DesignerRatings.
     */
    data: XOR<DesignerRatingUpdateManyMutationInput, DesignerRatingUncheckedUpdateManyInput>
    /**
     * Filter which DesignerRatings to update
     */
    where?: DesignerRatingWhereInput
    /**
     * Limit how many DesignerRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignerRating upsert
   */
  export type DesignerRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignerRating to update in case it exists.
     */
    where: DesignerRatingWhereUniqueInput
    /**
     * In case the DesignerRating found by the `where` argument doesn't exist, create a new DesignerRating with this data.
     */
    create: XOR<DesignerRatingCreateInput, DesignerRatingUncheckedCreateInput>
    /**
     * In case the DesignerRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignerRatingUpdateInput, DesignerRatingUncheckedUpdateInput>
  }

  /**
   * DesignerRating delete
   */
  export type DesignerRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
    /**
     * Filter which DesignerRating to delete.
     */
    where: DesignerRatingWhereUniqueInput
  }

  /**
   * DesignerRating deleteMany
   */
  export type DesignerRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignerRatings to delete
     */
    where?: DesignerRatingWhereInput
    /**
     * Limit how many DesignerRatings to delete.
     */
    limit?: number
  }

  /**
   * DesignerRating without action
   */
  export type DesignerRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignerRating
     */
    select?: DesignerRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DesignerRating
     */
    omit?: DesignerRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerRatingInclude<ExtArgs> | null
  }


  /**
   * Model UserRating
   */

  export type AggregateUserRating = {
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  export type UserRatingAvgAggregateOutputType = {
    id: number | null
    hireRequestId: number | null
    designerId: number | null
    stars: number | null
  }

  export type UserRatingSumAggregateOutputType = {
    id: number | null
    hireRequestId: number | null
    designerId: number | null
    stars: number | null
  }

  export type UserRatingMinAggregateOutputType = {
    id: number | null
    hireRequestId: number | null
    designerId: number | null
    reviewerName: string | null
    stars: number | null
    review: string | null
    createdAt: Date | null
  }

  export type UserRatingMaxAggregateOutputType = {
    id: number | null
    hireRequestId: number | null
    designerId: number | null
    reviewerName: string | null
    stars: number | null
    review: string | null
    createdAt: Date | null
  }

  export type UserRatingCountAggregateOutputType = {
    id: number
    hireRequestId: number
    designerId: number
    reviewerName: number
    stars: number
    review: number
    createdAt: number
    _all: number
  }


  export type UserRatingAvgAggregateInputType = {
    id?: true
    hireRequestId?: true
    designerId?: true
    stars?: true
  }

  export type UserRatingSumAggregateInputType = {
    id?: true
    hireRequestId?: true
    designerId?: true
    stars?: true
  }

  export type UserRatingMinAggregateInputType = {
    id?: true
    hireRequestId?: true
    designerId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
  }

  export type UserRatingMaxAggregateInputType = {
    id?: true
    hireRequestId?: true
    designerId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
  }

  export type UserRatingCountAggregateInputType = {
    id?: true
    hireRequestId?: true
    designerId?: true
    reviewerName?: true
    stars?: true
    review?: true
    createdAt?: true
    _all?: true
  }

  export type UserRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRating to aggregate.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRatings
    **/
    _count?: true | UserRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRatingMaxAggregateInputType
  }

  export type GetUserRatingAggregateType<T extends UserRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRating[P]>
      : GetScalarType<T[P], AggregateUserRating[P]>
  }




  export type UserRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithAggregationInput | UserRatingOrderByWithAggregationInput[]
    by: UserRatingScalarFieldEnum[] | UserRatingScalarFieldEnum
    having?: UserRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRatingCountAggregateInputType | true
    _avg?: UserRatingAvgAggregateInputType
    _sum?: UserRatingSumAggregateInputType
    _min?: UserRatingMinAggregateInputType
    _max?: UserRatingMaxAggregateInputType
  }

  export type UserRatingGroupByOutputType = {
    id: number
    hireRequestId: number
    designerId: number | null
    reviewerName: string | null
    stars: number
    review: string | null
    createdAt: Date
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  type GetUserRatingGroupByPayload<T extends UserRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
            : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
        }
      >
    >


  export type UserRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hireRequestId?: boolean
    designerId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }, ExtArgs["result"]["userRating"]>

  export type UserRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hireRequestId?: boolean
    designerId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }, ExtArgs["result"]["userRating"]>

  export type UserRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hireRequestId?: boolean
    designerId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }, ExtArgs["result"]["userRating"]>

  export type UserRatingSelectScalar = {
    id?: boolean
    hireRequestId?: boolean
    designerId?: boolean
    reviewerName?: boolean
    stars?: boolean
    review?: boolean
    createdAt?: boolean
  }

  export type UserRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hireRequestId" | "designerId" | "reviewerName" | "stars" | "review" | "createdAt", ExtArgs["result"]["userRating"]>
  export type UserRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }
  export type UserRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }
  export type UserRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hireRequest?: boolean | DesignerHireRequestDefaultArgs<ExtArgs>
    designer?: boolean | UserRating$designerArgs<ExtArgs>
  }

  export type $UserRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRating"
    objects: {
      hireRequest: Prisma.$DesignerHireRequestPayload<ExtArgs>
      designer: Prisma.$DesignerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hireRequestId: number
      designerId: number | null
      reviewerName: string | null
      stars: number
      review: string | null
      createdAt: Date
    }, ExtArgs["result"]["userRating"]>
    composites: {}
  }

  type UserRatingGetPayload<S extends boolean | null | undefined | UserRatingDefaultArgs> = $Result.GetResult<Prisma.$UserRatingPayload, S>

  type UserRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRatingCountAggregateInputType | true
    }

  export interface UserRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRating'], meta: { name: 'UserRating' } }
    /**
     * Find zero or one UserRating that matches the filter.
     * @param {UserRatingFindUniqueArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRatingFindUniqueArgs>(args: SelectSubset<T, UserRatingFindUniqueArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRatingFindUniqueOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRatingFindFirstArgs>(args?: SelectSubset<T, UserRatingFindFirstArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRatings
     * const userRatings = await prisma.userRating.findMany()
     * 
     * // Get first 10 UserRatings
     * const userRatings = await prisma.userRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRatingWithIdOnly = await prisma.userRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRatingFindManyArgs>(args?: SelectSubset<T, UserRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRating.
     * @param {UserRatingCreateArgs} args - Arguments to create a UserRating.
     * @example
     * // Create one UserRating
     * const UserRating = await prisma.userRating.create({
     *   data: {
     *     // ... data to create a UserRating
     *   }
     * })
     * 
     */
    create<T extends UserRatingCreateArgs>(args: SelectSubset<T, UserRatingCreateArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRatings.
     * @param {UserRatingCreateManyArgs} args - Arguments to create many UserRatings.
     * @example
     * // Create many UserRatings
     * const userRating = await prisma.userRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRatingCreateManyArgs>(args?: SelectSubset<T, UserRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRatings and returns the data saved in the database.
     * @param {UserRatingCreateManyAndReturnArgs} args - Arguments to create many UserRatings.
     * @example
     * // Create many UserRatings
     * const userRating = await prisma.userRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRatings and only return the `id`
     * const userRatingWithIdOnly = await prisma.userRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRating.
     * @param {UserRatingDeleteArgs} args - Arguments to delete one UserRating.
     * @example
     * // Delete one UserRating
     * const UserRating = await prisma.userRating.delete({
     *   where: {
     *     // ... filter to delete one UserRating
     *   }
     * })
     * 
     */
    delete<T extends UserRatingDeleteArgs>(args: SelectSubset<T, UserRatingDeleteArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRating.
     * @param {UserRatingUpdateArgs} args - Arguments to update one UserRating.
     * @example
     * // Update one UserRating
     * const userRating = await prisma.userRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRatingUpdateArgs>(args: SelectSubset<T, UserRatingUpdateArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRatings.
     * @param {UserRatingDeleteManyArgs} args - Arguments to filter UserRatings to delete.
     * @example
     * // Delete a few UserRatings
     * const { count } = await prisma.userRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRatingDeleteManyArgs>(args?: SelectSubset<T, UserRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRatings
     * const userRating = await prisma.userRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRatingUpdateManyArgs>(args: SelectSubset<T, UserRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRatings and returns the data updated in the database.
     * @param {UserRatingUpdateManyAndReturnArgs} args - Arguments to update many UserRatings.
     * @example
     * // Update many UserRatings
     * const userRating = await prisma.userRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRatings and only return the `id`
     * const userRatingWithIdOnly = await prisma.userRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRating.
     * @param {UserRatingUpsertArgs} args - Arguments to update or create a UserRating.
     * @example
     * // Update or create a UserRating
     * const userRating = await prisma.userRating.upsert({
     *   create: {
     *     // ... data to create a UserRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRating we want to update
     *   }
     * })
     */
    upsert<T extends UserRatingUpsertArgs>(args: SelectSubset<T, UserRatingUpsertArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingCountArgs} args - Arguments to filter UserRatings to count.
     * @example
     * // Count the number of UserRatings
     * const count = await prisma.userRating.count({
     *   where: {
     *     // ... the filter for the UserRatings we want to count
     *   }
     * })
    **/
    count<T extends UserRatingCountArgs>(
      args?: Subset<T, UserRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRatingAggregateArgs>(args: Subset<T, UserRatingAggregateArgs>): Prisma.PrismaPromise<GetUserRatingAggregateType<T>>

    /**
     * Group by UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRatingGroupByArgs['orderBy'] }
        : { orderBy?: UserRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRating model
   */
  readonly fields: UserRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hireRequest<T extends DesignerHireRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesignerHireRequestDefaultArgs<ExtArgs>>): Prisma__DesignerHireRequestClient<$Result.GetResult<Prisma.$DesignerHireRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    designer<T extends UserRating$designerArgs<ExtArgs> = {}>(args?: Subset<T, UserRating$designerArgs<ExtArgs>>): Prisma__DesignerClient<$Result.GetResult<Prisma.$DesignerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRating model
   */
  interface UserRatingFieldRefs {
    readonly id: FieldRef<"UserRating", 'Int'>
    readonly hireRequestId: FieldRef<"UserRating", 'Int'>
    readonly designerId: FieldRef<"UserRating", 'Int'>
    readonly reviewerName: FieldRef<"UserRating", 'String'>
    readonly stars: FieldRef<"UserRating", 'Int'>
    readonly review: FieldRef<"UserRating", 'String'>
    readonly createdAt: FieldRef<"UserRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRating findUnique
   */
  export type UserRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
  }

  /**
   * UserRating findUniqueOrThrow
   */
  export type UserRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
  }

  /**
   * UserRating findFirst
   */
  export type UserRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * UserRating findFirstOrThrow
   */
  export type UserRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * UserRating findMany
   */
  export type UserRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRatings to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * UserRating create
   */
  export type UserRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRating.
     */
    data: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
  }

  /**
   * UserRating createMany
   */
  export type UserRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRatings.
     */
    data: UserRatingCreateManyInput | UserRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRating createManyAndReturn
   */
  export type UserRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * The data used to create many UserRatings.
     */
    data: UserRatingCreateManyInput | UserRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRating update
   */
  export type UserRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRating.
     */
    data: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
    /**
     * Choose, which UserRating to update.
     */
    where: UserRatingWhereUniqueInput
  }

  /**
   * UserRating updateMany
   */
  export type UserRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRatings.
     */
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyInput>
    /**
     * Filter which UserRatings to update
     */
    where?: UserRatingWhereInput
    /**
     * Limit how many UserRatings to update.
     */
    limit?: number
  }

  /**
   * UserRating updateManyAndReturn
   */
  export type UserRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * The data used to update UserRatings.
     */
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyInput>
    /**
     * Filter which UserRatings to update
     */
    where?: UserRatingWhereInput
    /**
     * Limit how many UserRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRating upsert
   */
  export type UserRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRating to update in case it exists.
     */
    where: UserRatingWhereUniqueInput
    /**
     * In case the UserRating found by the `where` argument doesn't exist, create a new UserRating with this data.
     */
    create: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
    /**
     * In case the UserRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
  }

  /**
   * UserRating delete
   */
  export type UserRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter which UserRating to delete.
     */
    where: UserRatingWhereUniqueInput
  }

  /**
   * UserRating deleteMany
   */
  export type UserRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRatings to delete
     */
    where?: UserRatingWhereInput
    /**
     * Limit how many UserRatings to delete.
     */
    limit?: number
  }

  /**
   * UserRating.designer
   */
  export type UserRating$designerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designer
     */
    select?: DesignerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designer
     */
    omit?: DesignerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignerInclude<ExtArgs> | null
    where?: DesignerWhereInput
  }

  /**
   * UserRating without action
   */
  export type UserRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRating
     */
    omit?: UserRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
  }


  /**
   * Model ReturnRequest
   */

  export type AggregateReturnRequest = {
    _count: ReturnRequestCountAggregateOutputType | null
    _avg: ReturnRequestAvgAggregateOutputType | null
    _sum: ReturnRequestSumAggregateOutputType | null
    _min: ReturnRequestMinAggregateOutputType | null
    _max: ReturnRequestMaxAggregateOutputType | null
  }

  export type ReturnRequestAvgAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    userId: number | null
    sellerId: number | null
    refundAmount: number | null
  }

  export type ReturnRequestSumAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    userId: number | null
    sellerId: number | null
    refundAmount: number | null
  }

  export type ReturnRequestMinAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    userId: number | null
    productName: string | null
    sellerId: number | null
    sellerName: string | null
    reason: string | null
    note: string | null
    requestedAt: Date | null
    sellerApprovalStatus: $Enums.ApprovalStatus | null
    adminApprovalStatus: $Enums.ApprovalStatus | null
    sellerApprovedAt: Date | null
    adminApprovedAt: Date | null
    sellerDecisionNote: string | null
    adminDecisionNote: string | null
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus | null
    refundDetails: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnRequestMaxAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    userId: number | null
    productName: string | null
    sellerId: number | null
    sellerName: string | null
    reason: string | null
    note: string | null
    requestedAt: Date | null
    sellerApprovalStatus: $Enums.ApprovalStatus | null
    adminApprovalStatus: $Enums.ApprovalStatus | null
    sellerApprovedAt: Date | null
    adminApprovedAt: Date | null
    sellerDecisionNote: string | null
    adminDecisionNote: string | null
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus | null
    refundDetails: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnRequestCountAggregateOutputType = {
    id: number
    orderItemId: number
    userId: number
    productName: number
    sellerId: number
    sellerName: number
    reason: number
    note: number
    images: number
    requestedAt: number
    sellerApprovalStatus: number
    adminApprovalStatus: number
    sellerApprovedAt: number
    adminApprovedAt: number
    sellerDecisionNote: number
    adminDecisionNote: number
    refundMethod: number
    refundAmount: number
    refundStatus: number
    refundDetails: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReturnRequestAvgAggregateInputType = {
    id?: true
    orderItemId?: true
    userId?: true
    sellerId?: true
    refundAmount?: true
  }

  export type ReturnRequestSumAggregateInputType = {
    id?: true
    orderItemId?: true
    userId?: true
    sellerId?: true
    refundAmount?: true
  }

  export type ReturnRequestMinAggregateInputType = {
    id?: true
    orderItemId?: true
    userId?: true
    productName?: true
    sellerId?: true
    sellerName?: true
    reason?: true
    note?: true
    requestedAt?: true
    sellerApprovalStatus?: true
    adminApprovalStatus?: true
    sellerApprovedAt?: true
    adminApprovedAt?: true
    sellerDecisionNote?: true
    adminDecisionNote?: true
    refundMethod?: true
    refundAmount?: true
    refundStatus?: true
    refundDetails?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnRequestMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    userId?: true
    productName?: true
    sellerId?: true
    sellerName?: true
    reason?: true
    note?: true
    requestedAt?: true
    sellerApprovalStatus?: true
    adminApprovalStatus?: true
    sellerApprovedAt?: true
    adminApprovedAt?: true
    sellerDecisionNote?: true
    adminDecisionNote?: true
    refundMethod?: true
    refundAmount?: true
    refundStatus?: true
    refundDetails?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnRequestCountAggregateInputType = {
    id?: true
    orderItemId?: true
    userId?: true
    productName?: true
    sellerId?: true
    sellerName?: true
    reason?: true
    note?: true
    images?: true
    requestedAt?: true
    sellerApprovalStatus?: true
    adminApprovalStatus?: true
    sellerApprovedAt?: true
    adminApprovedAt?: true
    sellerDecisionNote?: true
    adminDecisionNote?: true
    refundMethod?: true
    refundAmount?: true
    refundStatus?: true
    refundDetails?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReturnRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequest to aggregate.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnRequests
    **/
    _count?: true | ReturnRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnRequestMaxAggregateInputType
  }

  export type GetReturnRequestAggregateType<T extends ReturnRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnRequest[P]>
      : GetScalarType<T[P], AggregateReturnRequest[P]>
  }




  export type ReturnRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnRequestWhereInput
    orderBy?: ReturnRequestOrderByWithAggregationInput | ReturnRequestOrderByWithAggregationInput[]
    by: ReturnRequestScalarFieldEnum[] | ReturnRequestScalarFieldEnum
    having?: ReturnRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnRequestCountAggregateInputType | true
    _avg?: ReturnRequestAvgAggregateInputType
    _sum?: ReturnRequestSumAggregateInputType
    _min?: ReturnRequestMinAggregateInputType
    _max?: ReturnRequestMaxAggregateInputType
  }

  export type ReturnRequestGroupByOutputType = {
    id: number
    orderItemId: number
    userId: number
    productName: string
    sellerId: number
    sellerName: string | null
    reason: string
    note: string | null
    images: string[]
    requestedAt: Date
    sellerApprovalStatus: $Enums.ApprovalStatus
    adminApprovalStatus: $Enums.ApprovalStatus
    sellerApprovedAt: Date | null
    adminApprovedAt: Date | null
    sellerDecisionNote: string | null
    adminDecisionNote: string | null
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number | null
    refundStatus: $Enums.RefundStatus
    refundDetails: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReturnRequestCountAggregateOutputType | null
    _avg: ReturnRequestAvgAggregateOutputType | null
    _sum: ReturnRequestSumAggregateOutputType | null
    _min: ReturnRequestMinAggregateOutputType | null
    _max: ReturnRequestMaxAggregateOutputType | null
  }

  type GetReturnRequestGroupByPayload<T extends ReturnRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>
        }
      >
    >


  export type ReturnRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    userId?: boolean
    productName?: boolean
    sellerId?: boolean
    sellerName?: boolean
    reason?: boolean
    note?: boolean
    images?: boolean
    requestedAt?: boolean
    sellerApprovalStatus?: boolean
    adminApprovalStatus?: boolean
    sellerApprovedAt?: boolean
    adminApprovedAt?: boolean
    sellerDecisionNote?: boolean
    adminDecisionNote?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnRequest"]>

  export type ReturnRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    userId?: boolean
    productName?: boolean
    sellerId?: boolean
    sellerName?: boolean
    reason?: boolean
    note?: boolean
    images?: boolean
    requestedAt?: boolean
    sellerApprovalStatus?: boolean
    adminApprovalStatus?: boolean
    sellerApprovedAt?: boolean
    adminApprovedAt?: boolean
    sellerDecisionNote?: boolean
    adminDecisionNote?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnRequest"]>

  export type ReturnRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    userId?: boolean
    productName?: boolean
    sellerId?: boolean
    sellerName?: boolean
    reason?: boolean
    note?: boolean
    images?: boolean
    requestedAt?: boolean
    sellerApprovalStatus?: boolean
    adminApprovalStatus?: boolean
    sellerApprovedAt?: boolean
    adminApprovedAt?: boolean
    sellerDecisionNote?: boolean
    adminDecisionNote?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnRequest"]>

  export type ReturnRequestSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    userId?: boolean
    productName?: boolean
    sellerId?: boolean
    sellerName?: boolean
    reason?: boolean
    note?: boolean
    images?: boolean
    requestedAt?: boolean
    sellerApprovalStatus?: boolean
    adminApprovalStatus?: boolean
    sellerApprovedAt?: boolean
    adminApprovedAt?: boolean
    sellerDecisionNote?: boolean
    adminDecisionNote?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    refundDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReturnRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "userId" | "productName" | "sellerId" | "sellerName" | "reason" | "note" | "images" | "requestedAt" | "sellerApprovalStatus" | "adminApprovalStatus" | "sellerApprovedAt" | "adminApprovedAt" | "sellerDecisionNote" | "adminDecisionNote" | "refundMethod" | "refundAmount" | "refundStatus" | "refundDetails" | "createdAt" | "updatedAt", ExtArgs["result"]["returnRequest"]>
  export type ReturnRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReturnRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReturnRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReturnRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnRequest"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderItemId: number
      userId: number
      productName: string
      sellerId: number
      sellerName: string | null
      reason: string
      note: string | null
      images: string[]
      requestedAt: Date
      sellerApprovalStatus: $Enums.ApprovalStatus
      adminApprovalStatus: $Enums.ApprovalStatus
      sellerApprovedAt: Date | null
      adminApprovedAt: Date | null
      sellerDecisionNote: string | null
      adminDecisionNote: string | null
      refundMethod: $Enums.RefundMethod | null
      refundAmount: number | null
      refundStatus: $Enums.RefundStatus
      refundDetails: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["returnRequest"]>
    composites: {}
  }

  type ReturnRequestGetPayload<S extends boolean | null | undefined | ReturnRequestDefaultArgs> = $Result.GetResult<Prisma.$ReturnRequestPayload, S>

  type ReturnRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnRequestCountAggregateInputType | true
    }

  export interface ReturnRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnRequest'], meta: { name: 'ReturnRequest' } }
    /**
     * Find zero or one ReturnRequest that matches the filter.
     * @param {ReturnRequestFindUniqueArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnRequestFindUniqueArgs>(args: SelectSubset<T, ReturnRequestFindUniqueArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnRequestFindUniqueOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnRequestFindFirstArgs>(args?: SelectSubset<T, ReturnRequestFindFirstArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany()
     * 
     * // Get first 10 ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnRequestFindManyArgs>(args?: SelectSubset<T, ReturnRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnRequest.
     * @param {ReturnRequestCreateArgs} args - Arguments to create a ReturnRequest.
     * @example
     * // Create one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.create({
     *   data: {
     *     // ... data to create a ReturnRequest
     *   }
     * })
     * 
     */
    create<T extends ReturnRequestCreateArgs>(args: SelectSubset<T, ReturnRequestCreateArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnRequests.
     * @param {ReturnRequestCreateManyArgs} args - Arguments to create many ReturnRequests.
     * @example
     * // Create many ReturnRequests
     * const returnRequest = await prisma.returnRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnRequestCreateManyArgs>(args?: SelectSubset<T, ReturnRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnRequests and returns the data saved in the database.
     * @param {ReturnRequestCreateManyAndReturnArgs} args - Arguments to create many ReturnRequests.
     * @example
     * // Create many ReturnRequests
     * const returnRequest = await prisma.returnRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnRequests and only return the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReturnRequest.
     * @param {ReturnRequestDeleteArgs} args - Arguments to delete one ReturnRequest.
     * @example
     * // Delete one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.delete({
     *   where: {
     *     // ... filter to delete one ReturnRequest
     *   }
     * })
     * 
     */
    delete<T extends ReturnRequestDeleteArgs>(args: SelectSubset<T, ReturnRequestDeleteArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnRequest.
     * @param {ReturnRequestUpdateArgs} args - Arguments to update one ReturnRequest.
     * @example
     * // Update one ReturnRequest
     * const returnRequest = await prisma.returnRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnRequestUpdateArgs>(args: SelectSubset<T, ReturnRequestUpdateArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnRequests.
     * @param {ReturnRequestDeleteManyArgs} args - Arguments to filter ReturnRequests to delete.
     * @example
     * // Delete a few ReturnRequests
     * const { count } = await prisma.returnRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnRequestDeleteManyArgs>(args?: SelectSubset<T, ReturnRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnRequests
     * const returnRequest = await prisma.returnRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnRequestUpdateManyArgs>(args: SelectSubset<T, ReturnRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnRequests and returns the data updated in the database.
     * @param {ReturnRequestUpdateManyAndReturnArgs} args - Arguments to update many ReturnRequests.
     * @example
     * // Update many ReturnRequests
     * const returnRequest = await prisma.returnRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReturnRequests and only return the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReturnRequest.
     * @param {ReturnRequestUpsertArgs} args - Arguments to update or create a ReturnRequest.
     * @example
     * // Update or create a ReturnRequest
     * const returnRequest = await prisma.returnRequest.upsert({
     *   create: {
     *     // ... data to create a ReturnRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnRequest we want to update
     *   }
     * })
     */
    upsert<T extends ReturnRequestUpsertArgs>(args: SelectSubset<T, ReturnRequestUpsertArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestCountArgs} args - Arguments to filter ReturnRequests to count.
     * @example
     * // Count the number of ReturnRequests
     * const count = await prisma.returnRequest.count({
     *   where: {
     *     // ... the filter for the ReturnRequests we want to count
     *   }
     * })
    **/
    count<T extends ReturnRequestCountArgs>(
      args?: Subset<T, ReturnRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnRequestAggregateArgs>(args: Subset<T, ReturnRequestAggregateArgs>): Prisma.PrismaPromise<GetReturnRequestAggregateType<T>>

    /**
     * Group by ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnRequestGroupByArgs['orderBy'] }
        : { orderBy?: ReturnRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnRequest model
   */
  readonly fields: ReturnRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnRequest model
   */
  interface ReturnRequestFieldRefs {
    readonly id: FieldRef<"ReturnRequest", 'Int'>
    readonly orderItemId: FieldRef<"ReturnRequest", 'Int'>
    readonly userId: FieldRef<"ReturnRequest", 'Int'>
    readonly productName: FieldRef<"ReturnRequest", 'String'>
    readonly sellerId: FieldRef<"ReturnRequest", 'Int'>
    readonly sellerName: FieldRef<"ReturnRequest", 'String'>
    readonly reason: FieldRef<"ReturnRequest", 'String'>
    readonly note: FieldRef<"ReturnRequest", 'String'>
    readonly images: FieldRef<"ReturnRequest", 'String[]'>
    readonly requestedAt: FieldRef<"ReturnRequest", 'DateTime'>
    readonly sellerApprovalStatus: FieldRef<"ReturnRequest", 'ApprovalStatus'>
    readonly adminApprovalStatus: FieldRef<"ReturnRequest", 'ApprovalStatus'>
    readonly sellerApprovedAt: FieldRef<"ReturnRequest", 'DateTime'>
    readonly adminApprovedAt: FieldRef<"ReturnRequest", 'DateTime'>
    readonly sellerDecisionNote: FieldRef<"ReturnRequest", 'String'>
    readonly adminDecisionNote: FieldRef<"ReturnRequest", 'String'>
    readonly refundMethod: FieldRef<"ReturnRequest", 'RefundMethod'>
    readonly refundAmount: FieldRef<"ReturnRequest", 'Float'>
    readonly refundStatus: FieldRef<"ReturnRequest", 'RefundStatus'>
    readonly refundDetails: FieldRef<"ReturnRequest", 'String'>
    readonly createdAt: FieldRef<"ReturnRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ReturnRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnRequest findUnique
   */
  export type ReturnRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest findUniqueOrThrow
   */
  export type ReturnRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest findFirst
   */
  export type ReturnRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest findFirstOrThrow
   */
  export type ReturnRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest findMany
   */
  export type ReturnRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequests to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest create
   */
  export type ReturnRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnRequest.
     */
    data: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>
  }

  /**
   * ReturnRequest createMany
   */
  export type ReturnRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnRequests.
     */
    data: ReturnRequestCreateManyInput | ReturnRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnRequest createManyAndReturn
   */
  export type ReturnRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ReturnRequests.
     */
    data: ReturnRequestCreateManyInput | ReturnRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnRequest update
   */
  export type ReturnRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnRequest.
     */
    data: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>
    /**
     * Choose, which ReturnRequest to update.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest updateMany
   */
  export type ReturnRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnRequests.
     */
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyInput>
    /**
     * Filter which ReturnRequests to update
     */
    where?: ReturnRequestWhereInput
    /**
     * Limit how many ReturnRequests to update.
     */
    limit?: number
  }

  /**
   * ReturnRequest updateManyAndReturn
   */
  export type ReturnRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * The data used to update ReturnRequests.
     */
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyInput>
    /**
     * Filter which ReturnRequests to update
     */
    where?: ReturnRequestWhereInput
    /**
     * Limit how many ReturnRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnRequest upsert
   */
  export type ReturnRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnRequest to update in case it exists.
     */
    where: ReturnRequestWhereUniqueInput
    /**
     * In case the ReturnRequest found by the `where` argument doesn't exist, create a new ReturnRequest with this data.
     */
    create: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>
    /**
     * In case the ReturnRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>
  }

  /**
   * ReturnRequest delete
   */
  export type ReturnRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter which ReturnRequest to delete.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest deleteMany
   */
  export type ReturnRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequests to delete
     */
    where?: ReturnRequestWhereInput
    /**
     * Limit how many ReturnRequests to delete.
     */
    limit?: number
  }

  /**
   * ReturnRequest without action
   */
  export type ReturnRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
  }


  /**
   * Model ContactMessage
   */

  export type AggregateContactMessage = {
    _count: ContactMessageCountAggregateOutputType | null
    _avg: ContactMessageAvgAggregateOutputType | null
    _sum: ContactMessageSumAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  export type ContactMessageAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactMessageSumAggregateOutputType = {
    id: number | null
  }

  export type ContactMessageMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ContactMessageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ContactMessageCountAggregateOutputType = {
    id: number
    name: number
    email: number
    message: number
    createdAt: number
    _all: number
  }


  export type ContactMessageAvgAggregateInputType = {
    id?: true
  }

  export type ContactMessageSumAggregateInputType = {
    id?: true
  }

  export type ContactMessageMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
  }

  export type ContactMessageMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
  }

  export type ContactMessageCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ContactMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessage to aggregate.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactMessages
    **/
    _count?: true | ContactMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMessageMaxAggregateInputType
  }

  export type GetContactMessageAggregateType<T extends ContactMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateContactMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactMessage[P]>
      : GetScalarType<T[P], AggregateContactMessage[P]>
  }




  export type ContactMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithAggregationInput | ContactMessageOrderByWithAggregationInput[]
    by: ContactMessageScalarFieldEnum[] | ContactMessageScalarFieldEnum
    having?: ContactMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactMessageCountAggregateInputType | true
    _avg?: ContactMessageAvgAggregateInputType
    _sum?: ContactMessageSumAggregateInputType
    _min?: ContactMessageMinAggregateInputType
    _max?: ContactMessageMaxAggregateInputType
  }

  export type ContactMessageGroupByOutputType = {
    id: number
    name: string
    email: string
    message: string
    createdAt: Date
    _count: ContactMessageCountAggregateOutputType | null
    _avg: ContactMessageAvgAggregateOutputType | null
    _sum: ContactMessageSumAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  type GetContactMessageGroupByPayload<T extends ContactMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
        }
      >
    >


  export type ContactMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ContactMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "message" | "createdAt", ExtArgs["result"]["contactMessage"]>

  export type $ContactMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["contactMessage"]>
    composites: {}
  }

  type ContactMessageGetPayload<S extends boolean | null | undefined | ContactMessageDefaultArgs> = $Result.GetResult<Prisma.$ContactMessagePayload, S>

  type ContactMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactMessageCountAggregateInputType | true
    }

  export interface ContactMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactMessage'], meta: { name: 'ContactMessage' } }
    /**
     * Find zero or one ContactMessage that matches the filter.
     * @param {ContactMessageFindUniqueArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactMessageFindUniqueArgs>(args: SelectSubset<T, ContactMessageFindUniqueArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactMessageFindUniqueOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactMessageFindFirstArgs>(args?: SelectSubset<T, ContactMessageFindFirstArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany()
     * 
     * // Get first 10 ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactMessageFindManyArgs>(args?: SelectSubset<T, ContactMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactMessage.
     * @param {ContactMessageCreateArgs} args - Arguments to create a ContactMessage.
     * @example
     * // Create one ContactMessage
     * const ContactMessage = await prisma.contactMessage.create({
     *   data: {
     *     // ... data to create a ContactMessage
     *   }
     * })
     * 
     */
    create<T extends ContactMessageCreateArgs>(args: SelectSubset<T, ContactMessageCreateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactMessages.
     * @param {ContactMessageCreateManyArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactMessageCreateManyArgs>(args?: SelectSubset<T, ContactMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactMessages and returns the data saved in the database.
     * @param {ContactMessageCreateManyAndReturnArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactMessage.
     * @param {ContactMessageDeleteArgs} args - Arguments to delete one ContactMessage.
     * @example
     * // Delete one ContactMessage
     * const ContactMessage = await prisma.contactMessage.delete({
     *   where: {
     *     // ... filter to delete one ContactMessage
     *   }
     * })
     * 
     */
    delete<T extends ContactMessageDeleteArgs>(args: SelectSubset<T, ContactMessageDeleteArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactMessage.
     * @param {ContactMessageUpdateArgs} args - Arguments to update one ContactMessage.
     * @example
     * // Update one ContactMessage
     * const contactMessage = await prisma.contactMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactMessageUpdateArgs>(args: SelectSubset<T, ContactMessageUpdateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactMessages.
     * @param {ContactMessageDeleteManyArgs} args - Arguments to filter ContactMessages to delete.
     * @example
     * // Delete a few ContactMessages
     * const { count } = await prisma.contactMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactMessageDeleteManyArgs>(args?: SelectSubset<T, ContactMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactMessageUpdateManyArgs>(args: SelectSubset<T, ContactMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages and returns the data updated in the database.
     * @param {ContactMessageUpdateManyAndReturnArgs} args - Arguments to update many ContactMessages.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactMessage.
     * @param {ContactMessageUpsertArgs} args - Arguments to update or create a ContactMessage.
     * @example
     * // Update or create a ContactMessage
     * const contactMessage = await prisma.contactMessage.upsert({
     *   create: {
     *     // ... data to create a ContactMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactMessage we want to update
     *   }
     * })
     */
    upsert<T extends ContactMessageUpsertArgs>(args: SelectSubset<T, ContactMessageUpsertArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageCountArgs} args - Arguments to filter ContactMessages to count.
     * @example
     * // Count the number of ContactMessages
     * const count = await prisma.contactMessage.count({
     *   where: {
     *     // ... the filter for the ContactMessages we want to count
     *   }
     * })
    **/
    count<T extends ContactMessageCountArgs>(
      args?: Subset<T, ContactMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactMessageAggregateArgs>(args: Subset<T, ContactMessageAggregateArgs>): Prisma.PrismaPromise<GetContactMessageAggregateType<T>>

    /**
     * Group by ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactMessageGroupByArgs['orderBy'] }
        : { orderBy?: ContactMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactMessage model
   */
  readonly fields: ContactMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactMessage model
   */
  interface ContactMessageFieldRefs {
    readonly id: FieldRef<"ContactMessage", 'Int'>
    readonly name: FieldRef<"ContactMessage", 'String'>
    readonly email: FieldRef<"ContactMessage", 'String'>
    readonly message: FieldRef<"ContactMessage", 'String'>
    readonly createdAt: FieldRef<"ContactMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactMessage findUnique
   */
  export type ContactMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findUniqueOrThrow
   */
  export type ContactMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findFirst
   */
  export type ContactMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findFirstOrThrow
   */
  export type ContactMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findMany
   */
  export type ContactMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessages to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage create
   */
  export type ContactMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactMessage.
     */
    data: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
  }

  /**
   * ContactMessage createMany
   */
  export type ContactMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage createManyAndReturn
   */
  export type ContactMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage update
   */
  export type ContactMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactMessage.
     */
    data: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
    /**
     * Choose, which ContactMessage to update.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage updateMany
   */
  export type ContactMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to update.
     */
    limit?: number
  }

  /**
   * ContactMessage updateManyAndReturn
   */
  export type ContactMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to update.
     */
    limit?: number
  }

  /**
   * ContactMessage upsert
   */
  export type ContactMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactMessage to update in case it exists.
     */
    where: ContactMessageWhereUniqueInput
    /**
     * In case the ContactMessage found by the `where` argument doesn't exist, create a new ContactMessage with this data.
     */
    create: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
    /**
     * In case the ContactMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
  }

  /**
   * ContactMessage delete
   */
  export type ContactMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter which ContactMessage to delete.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage deleteMany
   */
  export type ContactMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessages to delete
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to delete.
     */
    limit?: number
  }

  /**
   * ContactMessage without action
   */
  export type ContactMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    credit: 'credit'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerOtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otpHash: 'otpHash',
    expiresAt: 'expiresAt',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type CustomerOtpScalarFieldEnum = (typeof CustomerOtpScalarFieldEnum)[keyof typeof CustomerOtpScalarFieldEnum]


  export const SellerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    phoneVerified: 'phoneVerified',
    createdAt: 'createdAt'
  };

  export type SellerScalarFieldEnum = (typeof SellerScalarFieldEnum)[keyof typeof SellerScalarFieldEnum]


  export const SellerOtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otpHash: 'otpHash',
    expiresAt: 'expiresAt',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type SellerOtpScalarFieldEnum = (typeof SellerOtpScalarFieldEnum)[keyof typeof SellerOtpScalarFieldEnum]


  export const SellerBusinessDetailsScalarFieldEnum: {
    id: 'id',
    businessName: 'businessName',
    sellerType: 'sellerType',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    gst: 'gst',
    sellerId: 'sellerId',
    createdAt: 'createdAt'
  };

  export type SellerBusinessDetailsScalarFieldEnum = (typeof SellerBusinessDetailsScalarFieldEnum)[keyof typeof SellerBusinessDetailsScalarFieldEnum]


  export const SellerDeliveryDetailsScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    deliveryResponsibility: 'deliveryResponsibility',
    deliveryCoverage: 'deliveryCoverage',
    deliveryType: 'deliveryType',
    deliveryTimeMin: 'deliveryTimeMin',
    deliveryTimeMax: 'deliveryTimeMax',
    shippingChargeType: 'shippingChargeType',
    shippingCharge: 'shippingCharge',
    internationalDelivery: 'internationalDelivery',
    installationAvailable: 'installationAvailable',
    installationCharge: 'installationCharge',
    createdAt: 'createdAt'
  };

  export type SellerDeliveryDetailsScalarFieldEnum = (typeof SellerDeliveryDetailsScalarFieldEnum)[keyof typeof SellerDeliveryDetailsScalarFieldEnum]


  export const SellerBankDetailsScalarFieldEnum: {
    id: 'id',
    accountHolder: 'accountHolder',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    ifsc: 'ifsc',
    sellerId: 'sellerId',
    createdAt: 'createdAt'
  };

  export type SellerBankDetailsScalarFieldEnum = (typeof SellerBankDetailsScalarFieldEnum)[keyof typeof SellerBankDetailsScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    productType: 'productType',
    category: 'category',
    description: 'description',
    images: 'images',
    video: 'video',
    availability: 'availability',
    sellerId: 'sellerId',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    customerEmail: 'customerEmail',
    customerName: 'customerName',
    address: 'address',
    paymentMethod: 'paymentMethod',
    subtotal: 'subtotal',
    casaCharge: 'casaCharge',
    deliveryCharge: 'deliveryCharge',
    grandTotal: 'grandTotal',
    createdAt: 'createdAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    sellerId: 'sellerId',
    materialId: 'materialId',
    materialName: 'materialName',
    supplierName: 'supplierName',
    imageUrl: 'imageUrl',
    quantity: 'quantity',
    pricePerUnit: 'pricePerUnit',
    totalAmount: 'totalAmount',
    status: 'status',
    returnStatus: 'returnStatus',
    returnReason: 'returnReason',
    returnRequestedAt: 'returnRequestedAt',
    returnResolvedAt: 'returnResolvedAt',
    refundAmount: 'refundAmount',
    refundStatus: 'refundStatus',
    refundProcessedAt: 'refundProcessedAt',
    deliveryTimeMin: 'deliveryTimeMin',
    deliveryTimeMax: 'deliveryTimeMax',
    shippingChargeType: 'shippingChargeType',
    shippingCharge: 'shippingCharge',
    installationAvailable: 'installationAvailable',
    installationCharge: 'installationCharge',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    stars: 'stars',
    comment: 'comment',
    createdAt: 'createdAt',
    userId: 'userId',
    productId: 'productId',
    orderItemId: 'orderItemId'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const DesignerScalarFieldEnum: {
    id: 'id',
    fullname: 'fullname',
    email: 'email',
    mobile: 'mobile',
    location: 'location',
    passwordHash: 'passwordHash',
    availability: 'availability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignerScalarFieldEnum = (typeof DesignerScalarFieldEnum)[keyof typeof DesignerScalarFieldEnum]


  export const DesignerOtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otpHash: 'otpHash',
    expiresAt: 'expiresAt',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type DesignerOtpScalarFieldEnum = (typeof DesignerOtpScalarFieldEnum)[keyof typeof DesignerOtpScalarFieldEnum]


  export const DesignerProfileScalarFieldEnum: {
    id: 'id',
    designerId: 'designerId',
    experience: 'experience',
    portfolio: 'portfolio',
    designerType: 'designerType',
    bio: 'bio',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignerProfileScalarFieldEnum = (typeof DesignerProfileScalarFieldEnum)[keyof typeof DesignerProfileScalarFieldEnum]


  export const DesignerWorkScalarFieldEnum: {
    id: 'id',
    designerId: 'designerId',
    image: 'image',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type DesignerWorkScalarFieldEnum = (typeof DesignerWorkScalarFieldEnum)[keyof typeof DesignerWorkScalarFieldEnum]


  export const DesignerHireRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    designerId: 'designerId',
    fullName: 'fullName',
    email: 'email',
    mobile: 'mobile',
    location: 'location',
    budget: 'budget',
    workType: 'workType',
    timelineDate: 'timelineDate',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type DesignerHireRequestScalarFieldEnum = (typeof DesignerHireRequestScalarFieldEnum)[keyof typeof DesignerHireRequestScalarFieldEnum]


  export const DesignerRatingScalarFieldEnum: {
    id: 'id',
    designerId: 'designerId',
    hireRequestId: 'hireRequestId',
    reviewerName: 'reviewerName',
    stars: 'stars',
    review: 'review',
    createdAt: 'createdAt'
  };

  export type DesignerRatingScalarFieldEnum = (typeof DesignerRatingScalarFieldEnum)[keyof typeof DesignerRatingScalarFieldEnum]


  export const UserRatingScalarFieldEnum: {
    id: 'id',
    hireRequestId: 'hireRequestId',
    designerId: 'designerId',
    reviewerName: 'reviewerName',
    stars: 'stars',
    review: 'review',
    createdAt: 'createdAt'
  };

  export type UserRatingScalarFieldEnum = (typeof UserRatingScalarFieldEnum)[keyof typeof UserRatingScalarFieldEnum]


  export const ReturnRequestScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    userId: 'userId',
    productName: 'productName',
    sellerId: 'sellerId',
    sellerName: 'sellerName',
    reason: 'reason',
    note: 'note',
    images: 'images',
    requestedAt: 'requestedAt',
    sellerApprovalStatus: 'sellerApprovalStatus',
    adminApprovalStatus: 'adminApprovalStatus',
    sellerApprovedAt: 'sellerApprovedAt',
    adminApprovedAt: 'adminApprovedAt',
    sellerDecisionNote: 'sellerDecisionNote',
    adminDecisionNote: 'adminDecisionNote',
    refundMethod: 'refundMethod',
    refundAmount: 'refundAmount',
    refundStatus: 'refundStatus',
    refundDetails: 'refundDetails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReturnRequestScalarFieldEnum = (typeof ReturnRequestScalarFieldEnum)[keyof typeof ReturnRequestScalarFieldEnum]


  export const ContactMessageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ContactMessageScalarFieldEnum = (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ReturnStatus'
   */
  export type EnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnStatus'>
    


  /**
   * Reference to a field of type 'ReturnStatus[]'
   */
  export type ListEnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnStatus[]'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'RefundMethod'
   */
  export type EnumRefundMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundMethod'>
    


  /**
   * Reference to a field of type 'RefundMethod[]'
   */
  export type ListEnumRefundMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundMethod[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    credit?: FloatFilter<"User"> | number
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
    hireRequests?: DesignerHireRequestListRelationFilter
    returnRequests?: ReturnRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    credit?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    hireRequests?: DesignerHireRequestOrderByRelationAggregateInput
    returnRequests?: ReturnRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    credit?: FloatFilter<"User"> | number
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
    hireRequests?: DesignerHireRequestListRelationFilter
    returnRequests?: ReturnRequestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    credit?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    credit?: FloatWithAggregatesFilter<"User"> | number
  }

  export type CustomerOtpWhereInput = {
    AND?: CustomerOtpWhereInput | CustomerOtpWhereInput[]
    OR?: CustomerOtpWhereInput[]
    NOT?: CustomerOtpWhereInput | CustomerOtpWhereInput[]
    id?: StringFilter<"CustomerOtp"> | string
    email?: StringFilter<"CustomerOtp"> | string
    otpHash?: StringFilter<"CustomerOtp"> | string
    expiresAt?: DateTimeFilter<"CustomerOtp"> | Date | string
    verified?: BoolFilter<"CustomerOtp"> | boolean
    createdAt?: DateTimeFilter<"CustomerOtp"> | Date | string
  }

  export type CustomerOtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerOtpWhereInput | CustomerOtpWhereInput[]
    OR?: CustomerOtpWhereInput[]
    NOT?: CustomerOtpWhereInput | CustomerOtpWhereInput[]
    email?: StringFilter<"CustomerOtp"> | string
    otpHash?: StringFilter<"CustomerOtp"> | string
    expiresAt?: DateTimeFilter<"CustomerOtp"> | Date | string
    verified?: BoolFilter<"CustomerOtp"> | boolean
    createdAt?: DateTimeFilter<"CustomerOtp"> | Date | string
  }, "id">

  export type CustomerOtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerOtpCountOrderByAggregateInput
    _max?: CustomerOtpMaxOrderByAggregateInput
    _min?: CustomerOtpMinOrderByAggregateInput
  }

  export type CustomerOtpScalarWhereWithAggregatesInput = {
    AND?: CustomerOtpScalarWhereWithAggregatesInput | CustomerOtpScalarWhereWithAggregatesInput[]
    OR?: CustomerOtpScalarWhereWithAggregatesInput[]
    NOT?: CustomerOtpScalarWhereWithAggregatesInput | CustomerOtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerOtp"> | string
    email?: StringWithAggregatesFilter<"CustomerOtp"> | string
    otpHash?: StringWithAggregatesFilter<"CustomerOtp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"CustomerOtp"> | Date | string
    verified?: BoolWithAggregatesFilter<"CustomerOtp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerOtp"> | Date | string
  }

  export type SellerWhereInput = {
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    id?: IntFilter<"Seller"> | number
    name?: StringFilter<"Seller"> | string
    email?: StringFilter<"Seller"> | string
    phone?: StringFilter<"Seller"> | string
    password?: StringFilter<"Seller"> | string
    phoneVerified?: BoolFilter<"Seller"> | boolean
    createdAt?: DateTimeFilter<"Seller"> | Date | string
    orderItems?: OrderItemListRelationFilter
    products?: ProductListRelationFilter
    business?: XOR<SellerBusinessDetailsNullableScalarRelationFilter, SellerBusinessDetailsWhereInput> | null
    delivery?: XOR<SellerDeliveryDetailsNullableScalarRelationFilter, SellerDeliveryDetailsWhereInput> | null
    bank?: XOR<SellerBankDetailsNullableScalarRelationFilter, SellerBankDetailsWhereInput> | null
  }

  export type SellerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phoneVerified?: SortOrder
    createdAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    business?: SellerBusinessDetailsOrderByWithRelationInput
    delivery?: SellerDeliveryDetailsOrderByWithRelationInput
    bank?: SellerBankDetailsOrderByWithRelationInput
  }

  export type SellerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    name?: StringFilter<"Seller"> | string
    phone?: StringFilter<"Seller"> | string
    password?: StringFilter<"Seller"> | string
    phoneVerified?: BoolFilter<"Seller"> | boolean
    createdAt?: DateTimeFilter<"Seller"> | Date | string
    orderItems?: OrderItemListRelationFilter
    products?: ProductListRelationFilter
    business?: XOR<SellerBusinessDetailsNullableScalarRelationFilter, SellerBusinessDetailsWhereInput> | null
    delivery?: XOR<SellerDeliveryDetailsNullableScalarRelationFilter, SellerDeliveryDetailsWhereInput> | null
    bank?: XOR<SellerBankDetailsNullableScalarRelationFilter, SellerBankDetailsWhereInput> | null
  }, "id" | "email">

  export type SellerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phoneVerified?: SortOrder
    createdAt?: SortOrder
    _count?: SellerCountOrderByAggregateInput
    _avg?: SellerAvgOrderByAggregateInput
    _max?: SellerMaxOrderByAggregateInput
    _min?: SellerMinOrderByAggregateInput
    _sum?: SellerSumOrderByAggregateInput
  }

  export type SellerScalarWhereWithAggregatesInput = {
    AND?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    OR?: SellerScalarWhereWithAggregatesInput[]
    NOT?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seller"> | number
    name?: StringWithAggregatesFilter<"Seller"> | string
    email?: StringWithAggregatesFilter<"Seller"> | string
    phone?: StringWithAggregatesFilter<"Seller"> | string
    password?: StringWithAggregatesFilter<"Seller"> | string
    phoneVerified?: BoolWithAggregatesFilter<"Seller"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Seller"> | Date | string
  }

  export type SellerOtpWhereInput = {
    AND?: SellerOtpWhereInput | SellerOtpWhereInput[]
    OR?: SellerOtpWhereInput[]
    NOT?: SellerOtpWhereInput | SellerOtpWhereInput[]
    id?: StringFilter<"SellerOtp"> | string
    email?: StringFilter<"SellerOtp"> | string
    otpHash?: StringFilter<"SellerOtp"> | string
    expiresAt?: DateTimeFilter<"SellerOtp"> | Date | string
    verified?: BoolFilter<"SellerOtp"> | boolean
    createdAt?: DateTimeFilter<"SellerOtp"> | Date | string
  }

  export type SellerOtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellerOtpWhereInput | SellerOtpWhereInput[]
    OR?: SellerOtpWhereInput[]
    NOT?: SellerOtpWhereInput | SellerOtpWhereInput[]
    email?: StringFilter<"SellerOtp"> | string
    otpHash?: StringFilter<"SellerOtp"> | string
    expiresAt?: DateTimeFilter<"SellerOtp"> | Date | string
    verified?: BoolFilter<"SellerOtp"> | boolean
    createdAt?: DateTimeFilter<"SellerOtp"> | Date | string
  }, "id">

  export type SellerOtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: SellerOtpCountOrderByAggregateInput
    _max?: SellerOtpMaxOrderByAggregateInput
    _min?: SellerOtpMinOrderByAggregateInput
  }

  export type SellerOtpScalarWhereWithAggregatesInput = {
    AND?: SellerOtpScalarWhereWithAggregatesInput | SellerOtpScalarWhereWithAggregatesInput[]
    OR?: SellerOtpScalarWhereWithAggregatesInput[]
    NOT?: SellerOtpScalarWhereWithAggregatesInput | SellerOtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellerOtp"> | string
    email?: StringWithAggregatesFilter<"SellerOtp"> | string
    otpHash?: StringWithAggregatesFilter<"SellerOtp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"SellerOtp"> | Date | string
    verified?: BoolWithAggregatesFilter<"SellerOtp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SellerOtp"> | Date | string
  }

  export type SellerBusinessDetailsWhereInput = {
    AND?: SellerBusinessDetailsWhereInput | SellerBusinessDetailsWhereInput[]
    OR?: SellerBusinessDetailsWhereInput[]
    NOT?: SellerBusinessDetailsWhereInput | SellerBusinessDetailsWhereInput[]
    id?: IntFilter<"SellerBusinessDetails"> | number
    businessName?: StringFilter<"SellerBusinessDetails"> | string
    sellerType?: StringFilter<"SellerBusinessDetails"> | string
    address?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    city?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    state?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    pincode?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    gst?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    sellerId?: IntFilter<"SellerBusinessDetails"> | number
    createdAt?: DateTimeFilter<"SellerBusinessDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }

  export type SellerBusinessDetailsOrderByWithRelationInput = {
    id?: SortOrder
    businessName?: SortOrder
    sellerType?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    seller?: SellerOrderByWithRelationInput
  }

  export type SellerBusinessDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sellerId?: number
    AND?: SellerBusinessDetailsWhereInput | SellerBusinessDetailsWhereInput[]
    OR?: SellerBusinessDetailsWhereInput[]
    NOT?: SellerBusinessDetailsWhereInput | SellerBusinessDetailsWhereInput[]
    businessName?: StringFilter<"SellerBusinessDetails"> | string
    sellerType?: StringFilter<"SellerBusinessDetails"> | string
    address?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    city?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    state?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    pincode?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    gst?: StringNullableFilter<"SellerBusinessDetails"> | string | null
    createdAt?: DateTimeFilter<"SellerBusinessDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }, "id" | "sellerId">

  export type SellerBusinessDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    businessName?: SortOrder
    sellerType?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    _count?: SellerBusinessDetailsCountOrderByAggregateInput
    _avg?: SellerBusinessDetailsAvgOrderByAggregateInput
    _max?: SellerBusinessDetailsMaxOrderByAggregateInput
    _min?: SellerBusinessDetailsMinOrderByAggregateInput
    _sum?: SellerBusinessDetailsSumOrderByAggregateInput
  }

  export type SellerBusinessDetailsScalarWhereWithAggregatesInput = {
    AND?: SellerBusinessDetailsScalarWhereWithAggregatesInput | SellerBusinessDetailsScalarWhereWithAggregatesInput[]
    OR?: SellerBusinessDetailsScalarWhereWithAggregatesInput[]
    NOT?: SellerBusinessDetailsScalarWhereWithAggregatesInput | SellerBusinessDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellerBusinessDetails"> | number
    businessName?: StringWithAggregatesFilter<"SellerBusinessDetails"> | string
    sellerType?: StringWithAggregatesFilter<"SellerBusinessDetails"> | string
    address?: StringNullableWithAggregatesFilter<"SellerBusinessDetails"> | string | null
    city?: StringNullableWithAggregatesFilter<"SellerBusinessDetails"> | string | null
    state?: StringNullableWithAggregatesFilter<"SellerBusinessDetails"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"SellerBusinessDetails"> | string | null
    gst?: StringNullableWithAggregatesFilter<"SellerBusinessDetails"> | string | null
    sellerId?: IntWithAggregatesFilter<"SellerBusinessDetails"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellerBusinessDetails"> | Date | string
  }

  export type SellerDeliveryDetailsWhereInput = {
    AND?: SellerDeliveryDetailsWhereInput | SellerDeliveryDetailsWhereInput[]
    OR?: SellerDeliveryDetailsWhereInput[]
    NOT?: SellerDeliveryDetailsWhereInput | SellerDeliveryDetailsWhereInput[]
    id?: IntFilter<"SellerDeliveryDetails"> | number
    sellerId?: IntFilter<"SellerDeliveryDetails"> | number
    deliveryResponsibility?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryCoverage?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryType?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryTimeMin?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    deliveryTimeMax?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    shippingChargeType?: StringFilter<"SellerDeliveryDetails"> | string
    shippingCharge?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    internationalDelivery?: BoolFilter<"SellerDeliveryDetails"> | boolean
    installationAvailable?: StringNullableFilter<"SellerDeliveryDetails"> | string | null
    installationCharge?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    createdAt?: DateTimeFilter<"SellerDeliveryDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }

  export type SellerDeliveryDetailsOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryResponsibility?: SortOrder
    deliveryCoverage?: SortOrder
    deliveryType?: SortOrder
    deliveryTimeMin?: SortOrderInput | SortOrder
    deliveryTimeMax?: SortOrderInput | SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrderInput | SortOrder
    internationalDelivery?: SortOrder
    installationAvailable?: SortOrderInput | SortOrder
    installationCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    seller?: SellerOrderByWithRelationInput
  }

  export type SellerDeliveryDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sellerId?: number
    AND?: SellerDeliveryDetailsWhereInput | SellerDeliveryDetailsWhereInput[]
    OR?: SellerDeliveryDetailsWhereInput[]
    NOT?: SellerDeliveryDetailsWhereInput | SellerDeliveryDetailsWhereInput[]
    deliveryResponsibility?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryCoverage?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryType?: StringFilter<"SellerDeliveryDetails"> | string
    deliveryTimeMin?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    deliveryTimeMax?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    shippingChargeType?: StringFilter<"SellerDeliveryDetails"> | string
    shippingCharge?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    internationalDelivery?: BoolFilter<"SellerDeliveryDetails"> | boolean
    installationAvailable?: StringNullableFilter<"SellerDeliveryDetails"> | string | null
    installationCharge?: IntNullableFilter<"SellerDeliveryDetails"> | number | null
    createdAt?: DateTimeFilter<"SellerDeliveryDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }, "id" | "sellerId">

  export type SellerDeliveryDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryResponsibility?: SortOrder
    deliveryCoverage?: SortOrder
    deliveryType?: SortOrder
    deliveryTimeMin?: SortOrderInput | SortOrder
    deliveryTimeMax?: SortOrderInput | SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrderInput | SortOrder
    internationalDelivery?: SortOrder
    installationAvailable?: SortOrderInput | SortOrder
    installationCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SellerDeliveryDetailsCountOrderByAggregateInput
    _avg?: SellerDeliveryDetailsAvgOrderByAggregateInput
    _max?: SellerDeliveryDetailsMaxOrderByAggregateInput
    _min?: SellerDeliveryDetailsMinOrderByAggregateInput
    _sum?: SellerDeliveryDetailsSumOrderByAggregateInput
  }

  export type SellerDeliveryDetailsScalarWhereWithAggregatesInput = {
    AND?: SellerDeliveryDetailsScalarWhereWithAggregatesInput | SellerDeliveryDetailsScalarWhereWithAggregatesInput[]
    OR?: SellerDeliveryDetailsScalarWhereWithAggregatesInput[]
    NOT?: SellerDeliveryDetailsScalarWhereWithAggregatesInput | SellerDeliveryDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellerDeliveryDetails"> | number
    sellerId?: IntWithAggregatesFilter<"SellerDeliveryDetails"> | number
    deliveryResponsibility?: StringWithAggregatesFilter<"SellerDeliveryDetails"> | string
    deliveryCoverage?: StringWithAggregatesFilter<"SellerDeliveryDetails"> | string
    deliveryType?: StringWithAggregatesFilter<"SellerDeliveryDetails"> | string
    deliveryTimeMin?: IntNullableWithAggregatesFilter<"SellerDeliveryDetails"> | number | null
    deliveryTimeMax?: IntNullableWithAggregatesFilter<"SellerDeliveryDetails"> | number | null
    shippingChargeType?: StringWithAggregatesFilter<"SellerDeliveryDetails"> | string
    shippingCharge?: IntNullableWithAggregatesFilter<"SellerDeliveryDetails"> | number | null
    internationalDelivery?: BoolWithAggregatesFilter<"SellerDeliveryDetails"> | boolean
    installationAvailable?: StringNullableWithAggregatesFilter<"SellerDeliveryDetails"> | string | null
    installationCharge?: IntNullableWithAggregatesFilter<"SellerDeliveryDetails"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SellerDeliveryDetails"> | Date | string
  }

  export type SellerBankDetailsWhereInput = {
    AND?: SellerBankDetailsWhereInput | SellerBankDetailsWhereInput[]
    OR?: SellerBankDetailsWhereInput[]
    NOT?: SellerBankDetailsWhereInput | SellerBankDetailsWhereInput[]
    id?: IntFilter<"SellerBankDetails"> | number
    accountHolder?: StringFilter<"SellerBankDetails"> | string
    bankName?: StringFilter<"SellerBankDetails"> | string
    accountNumber?: StringFilter<"SellerBankDetails"> | string
    ifsc?: StringFilter<"SellerBankDetails"> | string
    sellerId?: IntFilter<"SellerBankDetails"> | number
    createdAt?: DateTimeFilter<"SellerBankDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }

  export type SellerBankDetailsOrderByWithRelationInput = {
    id?: SortOrder
    accountHolder?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    seller?: SellerOrderByWithRelationInput
  }

  export type SellerBankDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sellerId?: number
    AND?: SellerBankDetailsWhereInput | SellerBankDetailsWhereInput[]
    OR?: SellerBankDetailsWhereInput[]
    NOT?: SellerBankDetailsWhereInput | SellerBankDetailsWhereInput[]
    accountHolder?: StringFilter<"SellerBankDetails"> | string
    bankName?: StringFilter<"SellerBankDetails"> | string
    accountNumber?: StringFilter<"SellerBankDetails"> | string
    ifsc?: StringFilter<"SellerBankDetails"> | string
    createdAt?: DateTimeFilter<"SellerBankDetails"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
  }, "id" | "sellerId">

  export type SellerBankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    accountHolder?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    _count?: SellerBankDetailsCountOrderByAggregateInput
    _avg?: SellerBankDetailsAvgOrderByAggregateInput
    _max?: SellerBankDetailsMaxOrderByAggregateInput
    _min?: SellerBankDetailsMinOrderByAggregateInput
    _sum?: SellerBankDetailsSumOrderByAggregateInput
  }

  export type SellerBankDetailsScalarWhereWithAggregatesInput = {
    AND?: SellerBankDetailsScalarWhereWithAggregatesInput | SellerBankDetailsScalarWhereWithAggregatesInput[]
    OR?: SellerBankDetailsScalarWhereWithAggregatesInput[]
    NOT?: SellerBankDetailsScalarWhereWithAggregatesInput | SellerBankDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellerBankDetails"> | number
    accountHolder?: StringWithAggregatesFilter<"SellerBankDetails"> | string
    bankName?: StringWithAggregatesFilter<"SellerBankDetails"> | string
    accountNumber?: StringWithAggregatesFilter<"SellerBankDetails"> | string
    ifsc?: StringWithAggregatesFilter<"SellerBankDetails"> | string
    sellerId?: IntWithAggregatesFilter<"SellerBankDetails"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellerBankDetails"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    productType?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    video?: StringNullableFilter<"Product"> | string | null
    availability?: StringFilter<"Product"> | string
    sellerId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
    ratings?: RatingListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    video?: SortOrderInput | SortOrder
    availability?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    seller?: SellerOrderByWithRelationInput
    ratings?: RatingOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    productType?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    video?: StringNullableFilter<"Product"> | string | null
    availability?: StringFilter<"Product"> | string
    sellerId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
    ratings?: RatingListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    images?: SortOrder
    video?: SortOrderInput | SortOrder
    availability?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    productType?: StringWithAggregatesFilter<"Product"> | string
    category?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    video?: StringNullableWithAggregatesFilter<"Product"> | string | null
    availability?: StringWithAggregatesFilter<"Product"> | string
    sellerId?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntFilter<"Order"> | number
    customerEmail?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    paymentMethod?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    casaCharge?: FloatFilter<"Order"> | number
    deliveryCharge?: FloatFilter<"Order"> | number
    grandTotal?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    address?: SortOrder
    paymentMethod?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: IntFilter<"Order"> | number
    customerEmail?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    paymentMethod?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    casaCharge?: FloatFilter<"Order"> | number
    deliveryCharge?: FloatFilter<"Order"> | number
    grandTotal?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    address?: SortOrder
    paymentMethod?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    userId?: IntWithAggregatesFilter<"Order"> | number
    customerEmail?: StringWithAggregatesFilter<"Order"> | string
    customerName?: StringWithAggregatesFilter<"Order"> | string
    address?: StringWithAggregatesFilter<"Order"> | string
    paymentMethod?: StringWithAggregatesFilter<"Order"> | string
    subtotal?: FloatWithAggregatesFilter<"Order"> | number
    casaCharge?: FloatWithAggregatesFilter<"Order"> | number
    deliveryCharge?: FloatWithAggregatesFilter<"Order"> | number
    grandTotal?: FloatWithAggregatesFilter<"Order"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    sellerId?: IntFilter<"OrderItem"> | number
    materialId?: IntFilter<"OrderItem"> | number
    materialName?: StringFilter<"OrderItem"> | string
    supplierName?: StringFilter<"OrderItem"> | string
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    pricePerUnit?: FloatFilter<"OrderItem"> | number
    totalAmount?: FloatFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    returnStatus?: EnumReturnStatusFilter<"OrderItem"> | $Enums.ReturnStatus
    returnReason?: StringNullableFilter<"OrderItem"> | string | null
    returnRequestedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    returnResolvedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    refundAmount?: FloatNullableFilter<"OrderItem"> | number | null
    refundStatus?: EnumRefundStatusFilter<"OrderItem"> | $Enums.RefundStatus
    refundProcessedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveryTimeMin?: IntNullableFilter<"OrderItem"> | number | null
    deliveryTimeMax?: IntNullableFilter<"OrderItem"> | number | null
    shippingChargeType?: StringNullableFilter<"OrderItem"> | string | null
    shippingCharge?: IntNullableFilter<"OrderItem"> | number | null
    installationAvailable?: StringNullableFilter<"OrderItem"> | string | null
    installationCharge?: IntNullableFilter<"OrderItem"> | number | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
    rating?: XOR<RatingNullableScalarRelationFilter, RatingWhereInput> | null
    returnRequest?: XOR<ReturnRequestNullableScalarRelationFilter, ReturnRequestWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    supplierName?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    returnStatus?: SortOrder
    returnReason?: SortOrderInput | SortOrder
    returnRequestedAt?: SortOrderInput | SortOrder
    returnResolvedAt?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    refundProcessedAt?: SortOrderInput | SortOrder
    deliveryTimeMin?: SortOrderInput | SortOrder
    deliveryTimeMax?: SortOrderInput | SortOrder
    shippingChargeType?: SortOrderInput | SortOrder
    shippingCharge?: SortOrderInput | SortOrder
    installationAvailable?: SortOrderInput | SortOrder
    installationCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    seller?: SellerOrderByWithRelationInput
    rating?: RatingOrderByWithRelationInput
    returnRequest?: ReturnRequestOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    sellerId?: IntFilter<"OrderItem"> | number
    materialId?: IntFilter<"OrderItem"> | number
    materialName?: StringFilter<"OrderItem"> | string
    supplierName?: StringFilter<"OrderItem"> | string
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    pricePerUnit?: FloatFilter<"OrderItem"> | number
    totalAmount?: FloatFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    returnStatus?: EnumReturnStatusFilter<"OrderItem"> | $Enums.ReturnStatus
    returnReason?: StringNullableFilter<"OrderItem"> | string | null
    returnRequestedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    returnResolvedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    refundAmount?: FloatNullableFilter<"OrderItem"> | number | null
    refundStatus?: EnumRefundStatusFilter<"OrderItem"> | $Enums.RefundStatus
    refundProcessedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveryTimeMin?: IntNullableFilter<"OrderItem"> | number | null
    deliveryTimeMax?: IntNullableFilter<"OrderItem"> | number | null
    shippingChargeType?: StringNullableFilter<"OrderItem"> | string | null
    shippingCharge?: IntNullableFilter<"OrderItem"> | number | null
    installationAvailable?: StringNullableFilter<"OrderItem"> | string | null
    installationCharge?: IntNullableFilter<"OrderItem"> | number | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    seller?: XOR<SellerScalarRelationFilter, SellerWhereInput>
    rating?: XOR<RatingNullableScalarRelationFilter, RatingWhereInput> | null
    returnRequest?: XOR<ReturnRequestNullableScalarRelationFilter, ReturnRequestWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    supplierName?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    returnStatus?: SortOrder
    returnReason?: SortOrderInput | SortOrder
    returnRequestedAt?: SortOrderInput | SortOrder
    returnResolvedAt?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    refundProcessedAt?: SortOrderInput | SortOrder
    deliveryTimeMin?: SortOrderInput | SortOrder
    deliveryTimeMax?: SortOrderInput | SortOrder
    shippingChargeType?: SortOrderInput | SortOrder
    shippingCharge?: SortOrderInput | SortOrder
    installationAvailable?: SortOrderInput | SortOrder
    installationCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    sellerId?: IntWithAggregatesFilter<"OrderItem"> | number
    materialId?: IntWithAggregatesFilter<"OrderItem"> | number
    materialName?: StringWithAggregatesFilter<"OrderItem"> | string
    supplierName?: StringWithAggregatesFilter<"OrderItem"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    pricePerUnit?: FloatWithAggregatesFilter<"OrderItem"> | number
    totalAmount?: FloatWithAggregatesFilter<"OrderItem"> | number
    status?: StringWithAggregatesFilter<"OrderItem"> | string
    returnStatus?: EnumReturnStatusWithAggregatesFilter<"OrderItem"> | $Enums.ReturnStatus
    returnReason?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    returnRequestedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    returnResolvedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    refundAmount?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
    refundStatus?: EnumRefundStatusWithAggregatesFilter<"OrderItem"> | $Enums.RefundStatus
    refundProcessedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    deliveryTimeMin?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    deliveryTimeMax?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    shippingChargeType?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    shippingCharge?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    installationAvailable?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    installationCharge?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: IntFilter<"Rating"> | number
    stars?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    userId?: IntFilter<"Rating"> | number
    productId?: IntFilter<"Rating"> | number
    orderItemId?: IntFilter<"Rating"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    stars?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderItemId?: number
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    stars?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    userId?: IntFilter<"Rating"> | number
    productId?: IntFilter<"Rating"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }, "id" | "orderItemId">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    stars?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rating"> | number
    stars?: IntWithAggregatesFilter<"Rating"> | number
    comment?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    userId?: IntWithAggregatesFilter<"Rating"> | number
    productId?: IntWithAggregatesFilter<"Rating"> | number
    orderItemId?: IntWithAggregatesFilter<"Rating"> | number
  }

  export type DesignerWhereInput = {
    AND?: DesignerWhereInput | DesignerWhereInput[]
    OR?: DesignerWhereInput[]
    NOT?: DesignerWhereInput | DesignerWhereInput[]
    id?: IntFilter<"Designer"> | number
    fullname?: StringFilter<"Designer"> | string
    email?: StringFilter<"Designer"> | string
    mobile?: StringFilter<"Designer"> | string
    location?: StringNullableFilter<"Designer"> | string | null
    passwordHash?: StringFilter<"Designer"> | string
    availability?: StringFilter<"Designer"> | string
    createdAt?: DateTimeFilter<"Designer"> | Date | string
    updatedAt?: DateTimeFilter<"Designer"> | Date | string
    profile?: XOR<DesignerProfileNullableScalarRelationFilter, DesignerProfileWhereInput> | null
    works?: DesignerWorkListRelationFilter
    hireRequests?: DesignerHireRequestListRelationFilter
    ratings?: DesignerRatingListRelationFilter
    userRatings?: UserRatingListRelationFilter
  }

  export type DesignerOrderByWithRelationInput = {
    id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: DesignerProfileOrderByWithRelationInput
    works?: DesignerWorkOrderByRelationAggregateInput
    hireRequests?: DesignerHireRequestOrderByRelationAggregateInput
    ratings?: DesignerRatingOrderByRelationAggregateInput
    userRatings?: UserRatingOrderByRelationAggregateInput
  }

  export type DesignerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    mobile?: string
    AND?: DesignerWhereInput | DesignerWhereInput[]
    OR?: DesignerWhereInput[]
    NOT?: DesignerWhereInput | DesignerWhereInput[]
    fullname?: StringFilter<"Designer"> | string
    location?: StringNullableFilter<"Designer"> | string | null
    passwordHash?: StringFilter<"Designer"> | string
    availability?: StringFilter<"Designer"> | string
    createdAt?: DateTimeFilter<"Designer"> | Date | string
    updatedAt?: DateTimeFilter<"Designer"> | Date | string
    profile?: XOR<DesignerProfileNullableScalarRelationFilter, DesignerProfileWhereInput> | null
    works?: DesignerWorkListRelationFilter
    hireRequests?: DesignerHireRequestListRelationFilter
    ratings?: DesignerRatingListRelationFilter
    userRatings?: UserRatingListRelationFilter
  }, "id" | "email" | "mobile">

  export type DesignerOrderByWithAggregationInput = {
    id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignerCountOrderByAggregateInput
    _avg?: DesignerAvgOrderByAggregateInput
    _max?: DesignerMaxOrderByAggregateInput
    _min?: DesignerMinOrderByAggregateInput
    _sum?: DesignerSumOrderByAggregateInput
  }

  export type DesignerScalarWhereWithAggregatesInput = {
    AND?: DesignerScalarWhereWithAggregatesInput | DesignerScalarWhereWithAggregatesInput[]
    OR?: DesignerScalarWhereWithAggregatesInput[]
    NOT?: DesignerScalarWhereWithAggregatesInput | DesignerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Designer"> | number
    fullname?: StringWithAggregatesFilter<"Designer"> | string
    email?: StringWithAggregatesFilter<"Designer"> | string
    mobile?: StringWithAggregatesFilter<"Designer"> | string
    location?: StringNullableWithAggregatesFilter<"Designer"> | string | null
    passwordHash?: StringWithAggregatesFilter<"Designer"> | string
    availability?: StringWithAggregatesFilter<"Designer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Designer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Designer"> | Date | string
  }

  export type DesignerOtpWhereInput = {
    AND?: DesignerOtpWhereInput | DesignerOtpWhereInput[]
    OR?: DesignerOtpWhereInput[]
    NOT?: DesignerOtpWhereInput | DesignerOtpWhereInput[]
    id?: StringFilter<"DesignerOtp"> | string
    email?: StringFilter<"DesignerOtp"> | string
    otpHash?: StringFilter<"DesignerOtp"> | string
    expiresAt?: DateTimeFilter<"DesignerOtp"> | Date | string
    verified?: BoolFilter<"DesignerOtp"> | boolean
    createdAt?: DateTimeFilter<"DesignerOtp"> | Date | string
  }

  export type DesignerOtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DesignerOtpWhereInput | DesignerOtpWhereInput[]
    OR?: DesignerOtpWhereInput[]
    NOT?: DesignerOtpWhereInput | DesignerOtpWhereInput[]
    email?: StringFilter<"DesignerOtp"> | string
    otpHash?: StringFilter<"DesignerOtp"> | string
    expiresAt?: DateTimeFilter<"DesignerOtp"> | Date | string
    verified?: BoolFilter<"DesignerOtp"> | boolean
    createdAt?: DateTimeFilter<"DesignerOtp"> | Date | string
  }, "id">

  export type DesignerOtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: DesignerOtpCountOrderByAggregateInput
    _max?: DesignerOtpMaxOrderByAggregateInput
    _min?: DesignerOtpMinOrderByAggregateInput
  }

  export type DesignerOtpScalarWhereWithAggregatesInput = {
    AND?: DesignerOtpScalarWhereWithAggregatesInput | DesignerOtpScalarWhereWithAggregatesInput[]
    OR?: DesignerOtpScalarWhereWithAggregatesInput[]
    NOT?: DesignerOtpScalarWhereWithAggregatesInput | DesignerOtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DesignerOtp"> | string
    email?: StringWithAggregatesFilter<"DesignerOtp"> | string
    otpHash?: StringWithAggregatesFilter<"DesignerOtp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"DesignerOtp"> | Date | string
    verified?: BoolWithAggregatesFilter<"DesignerOtp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DesignerOtp"> | Date | string
  }

  export type DesignerProfileWhereInput = {
    AND?: DesignerProfileWhereInput | DesignerProfileWhereInput[]
    OR?: DesignerProfileWhereInput[]
    NOT?: DesignerProfileWhereInput | DesignerProfileWhereInput[]
    id?: IntFilter<"DesignerProfile"> | number
    designerId?: IntFilter<"DesignerProfile"> | number
    experience?: StringNullableFilter<"DesignerProfile"> | string | null
    portfolio?: StringNullableFilter<"DesignerProfile"> | string | null
    designerType?: StringNullableFilter<"DesignerProfile"> | string | null
    bio?: StringNullableFilter<"DesignerProfile"> | string | null
    profileImage?: StringNullableFilter<"DesignerProfile"> | string | null
    createdAt?: DateTimeFilter<"DesignerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"DesignerProfile"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
  }

  export type DesignerProfileOrderByWithRelationInput = {
    id?: SortOrder
    designerId?: SortOrder
    experience?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    designerType?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    designer?: DesignerOrderByWithRelationInput
  }

  export type DesignerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    designerId?: number
    AND?: DesignerProfileWhereInput | DesignerProfileWhereInput[]
    OR?: DesignerProfileWhereInput[]
    NOT?: DesignerProfileWhereInput | DesignerProfileWhereInput[]
    experience?: StringNullableFilter<"DesignerProfile"> | string | null
    portfolio?: StringNullableFilter<"DesignerProfile"> | string | null
    designerType?: StringNullableFilter<"DesignerProfile"> | string | null
    bio?: StringNullableFilter<"DesignerProfile"> | string | null
    profileImage?: StringNullableFilter<"DesignerProfile"> | string | null
    createdAt?: DateTimeFilter<"DesignerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"DesignerProfile"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
  }, "id" | "designerId">

  export type DesignerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    designerId?: SortOrder
    experience?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    designerType?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignerProfileCountOrderByAggregateInput
    _avg?: DesignerProfileAvgOrderByAggregateInput
    _max?: DesignerProfileMaxOrderByAggregateInput
    _min?: DesignerProfileMinOrderByAggregateInput
    _sum?: DesignerProfileSumOrderByAggregateInput
  }

  export type DesignerProfileScalarWhereWithAggregatesInput = {
    AND?: DesignerProfileScalarWhereWithAggregatesInput | DesignerProfileScalarWhereWithAggregatesInput[]
    OR?: DesignerProfileScalarWhereWithAggregatesInput[]
    NOT?: DesignerProfileScalarWhereWithAggregatesInput | DesignerProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DesignerProfile"> | number
    designerId?: IntWithAggregatesFilter<"DesignerProfile"> | number
    experience?: StringNullableWithAggregatesFilter<"DesignerProfile"> | string | null
    portfolio?: StringNullableWithAggregatesFilter<"DesignerProfile"> | string | null
    designerType?: StringNullableWithAggregatesFilter<"DesignerProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"DesignerProfile"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"DesignerProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DesignerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DesignerProfile"> | Date | string
  }

  export type DesignerWorkWhereInput = {
    AND?: DesignerWorkWhereInput | DesignerWorkWhereInput[]
    OR?: DesignerWorkWhereInput[]
    NOT?: DesignerWorkWhereInput | DesignerWorkWhereInput[]
    id?: IntFilter<"DesignerWork"> | number
    designerId?: IntFilter<"DesignerWork"> | number
    image?: StringFilter<"DesignerWork"> | string
    description?: StringNullableFilter<"DesignerWork"> | string | null
    createdAt?: DateTimeFilter<"DesignerWork"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
  }

  export type DesignerWorkOrderByWithRelationInput = {
    id?: SortOrder
    designerId?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    designer?: DesignerOrderByWithRelationInput
  }

  export type DesignerWorkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DesignerWorkWhereInput | DesignerWorkWhereInput[]
    OR?: DesignerWorkWhereInput[]
    NOT?: DesignerWorkWhereInput | DesignerWorkWhereInput[]
    designerId?: IntFilter<"DesignerWork"> | number
    image?: StringFilter<"DesignerWork"> | string
    description?: StringNullableFilter<"DesignerWork"> | string | null
    createdAt?: DateTimeFilter<"DesignerWork"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
  }, "id">

  export type DesignerWorkOrderByWithAggregationInput = {
    id?: SortOrder
    designerId?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DesignerWorkCountOrderByAggregateInput
    _avg?: DesignerWorkAvgOrderByAggregateInput
    _max?: DesignerWorkMaxOrderByAggregateInput
    _min?: DesignerWorkMinOrderByAggregateInput
    _sum?: DesignerWorkSumOrderByAggregateInput
  }

  export type DesignerWorkScalarWhereWithAggregatesInput = {
    AND?: DesignerWorkScalarWhereWithAggregatesInput | DesignerWorkScalarWhereWithAggregatesInput[]
    OR?: DesignerWorkScalarWhereWithAggregatesInput[]
    NOT?: DesignerWorkScalarWhereWithAggregatesInput | DesignerWorkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DesignerWork"> | number
    designerId?: IntWithAggregatesFilter<"DesignerWork"> | number
    image?: StringWithAggregatesFilter<"DesignerWork"> | string
    description?: StringNullableWithAggregatesFilter<"DesignerWork"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DesignerWork"> | Date | string
  }

  export type DesignerHireRequestWhereInput = {
    AND?: DesignerHireRequestWhereInput | DesignerHireRequestWhereInput[]
    OR?: DesignerHireRequestWhereInput[]
    NOT?: DesignerHireRequestWhereInput | DesignerHireRequestWhereInput[]
    id?: IntFilter<"DesignerHireRequest"> | number
    userId?: IntFilter<"DesignerHireRequest"> | number
    designerId?: IntFilter<"DesignerHireRequest"> | number
    fullName?: StringFilter<"DesignerHireRequest"> | string
    email?: StringFilter<"DesignerHireRequest"> | string
    mobile?: StringFilter<"DesignerHireRequest"> | string
    location?: StringFilter<"DesignerHireRequest"> | string
    budget?: IntFilter<"DesignerHireRequest"> | number
    workType?: StringFilter<"DesignerHireRequest"> | string
    timelineDate?: DateTimeNullableFilter<"DesignerHireRequest"> | Date | string | null
    description?: StringNullableFilter<"DesignerHireRequest"> | string | null
    status?: StringFilter<"DesignerHireRequest"> | string
    createdAt?: DateTimeFilter<"DesignerHireRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
    rating?: XOR<DesignerRatingNullableScalarRelationFilter, DesignerRatingWhereInput> | null
    userRating?: XOR<UserRatingNullableScalarRelationFilter, UserRatingWhereInput> | null
  }

  export type DesignerHireRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    budget?: SortOrder
    workType?: SortOrder
    timelineDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    designer?: DesignerOrderByWithRelationInput
    rating?: DesignerRatingOrderByWithRelationInput
    userRating?: UserRatingOrderByWithRelationInput
  }

  export type DesignerHireRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DesignerHireRequestWhereInput | DesignerHireRequestWhereInput[]
    OR?: DesignerHireRequestWhereInput[]
    NOT?: DesignerHireRequestWhereInput | DesignerHireRequestWhereInput[]
    userId?: IntFilter<"DesignerHireRequest"> | number
    designerId?: IntFilter<"DesignerHireRequest"> | number
    fullName?: StringFilter<"DesignerHireRequest"> | string
    email?: StringFilter<"DesignerHireRequest"> | string
    mobile?: StringFilter<"DesignerHireRequest"> | string
    location?: StringFilter<"DesignerHireRequest"> | string
    budget?: IntFilter<"DesignerHireRequest"> | number
    workType?: StringFilter<"DesignerHireRequest"> | string
    timelineDate?: DateTimeNullableFilter<"DesignerHireRequest"> | Date | string | null
    description?: StringNullableFilter<"DesignerHireRequest"> | string | null
    status?: StringFilter<"DesignerHireRequest"> | string
    createdAt?: DateTimeFilter<"DesignerHireRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
    rating?: XOR<DesignerRatingNullableScalarRelationFilter, DesignerRatingWhereInput> | null
    userRating?: XOR<UserRatingNullableScalarRelationFilter, UserRatingWhereInput> | null
  }, "id">

  export type DesignerHireRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    budget?: SortOrder
    workType?: SortOrder
    timelineDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: DesignerHireRequestCountOrderByAggregateInput
    _avg?: DesignerHireRequestAvgOrderByAggregateInput
    _max?: DesignerHireRequestMaxOrderByAggregateInput
    _min?: DesignerHireRequestMinOrderByAggregateInput
    _sum?: DesignerHireRequestSumOrderByAggregateInput
  }

  export type DesignerHireRequestScalarWhereWithAggregatesInput = {
    AND?: DesignerHireRequestScalarWhereWithAggregatesInput | DesignerHireRequestScalarWhereWithAggregatesInput[]
    OR?: DesignerHireRequestScalarWhereWithAggregatesInput[]
    NOT?: DesignerHireRequestScalarWhereWithAggregatesInput | DesignerHireRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DesignerHireRequest"> | number
    userId?: IntWithAggregatesFilter<"DesignerHireRequest"> | number
    designerId?: IntWithAggregatesFilter<"DesignerHireRequest"> | number
    fullName?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    email?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    mobile?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    location?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    budget?: IntWithAggregatesFilter<"DesignerHireRequest"> | number
    workType?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    timelineDate?: DateTimeNullableWithAggregatesFilter<"DesignerHireRequest"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"DesignerHireRequest"> | string | null
    status?: StringWithAggregatesFilter<"DesignerHireRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DesignerHireRequest"> | Date | string
  }

  export type DesignerRatingWhereInput = {
    AND?: DesignerRatingWhereInput | DesignerRatingWhereInput[]
    OR?: DesignerRatingWhereInput[]
    NOT?: DesignerRatingWhereInput | DesignerRatingWhereInput[]
    id?: IntFilter<"DesignerRating"> | number
    designerId?: IntFilter<"DesignerRating"> | number
    hireRequestId?: IntFilter<"DesignerRating"> | number
    reviewerName?: StringNullableFilter<"DesignerRating"> | string | null
    stars?: IntFilter<"DesignerRating"> | number
    review?: StringNullableFilter<"DesignerRating"> | string | null
    createdAt?: DateTimeFilter<"DesignerRating"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
    hireRequest?: XOR<DesignerHireRequestScalarRelationFilter, DesignerHireRequestWhereInput>
  }

  export type DesignerRatingOrderByWithRelationInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    stars?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    designer?: DesignerOrderByWithRelationInput
    hireRequest?: DesignerHireRequestOrderByWithRelationInput
  }

  export type DesignerRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hireRequestId?: number
    AND?: DesignerRatingWhereInput | DesignerRatingWhereInput[]
    OR?: DesignerRatingWhereInput[]
    NOT?: DesignerRatingWhereInput | DesignerRatingWhereInput[]
    designerId?: IntFilter<"DesignerRating"> | number
    reviewerName?: StringNullableFilter<"DesignerRating"> | string | null
    stars?: IntFilter<"DesignerRating"> | number
    review?: StringNullableFilter<"DesignerRating"> | string | null
    createdAt?: DateTimeFilter<"DesignerRating"> | Date | string
    designer?: XOR<DesignerScalarRelationFilter, DesignerWhereInput>
    hireRequest?: XOR<DesignerHireRequestScalarRelationFilter, DesignerHireRequestWhereInput>
  }, "id" | "hireRequestId">

  export type DesignerRatingOrderByWithAggregationInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    stars?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DesignerRatingCountOrderByAggregateInput
    _avg?: DesignerRatingAvgOrderByAggregateInput
    _max?: DesignerRatingMaxOrderByAggregateInput
    _min?: DesignerRatingMinOrderByAggregateInput
    _sum?: DesignerRatingSumOrderByAggregateInput
  }

  export type DesignerRatingScalarWhereWithAggregatesInput = {
    AND?: DesignerRatingScalarWhereWithAggregatesInput | DesignerRatingScalarWhereWithAggregatesInput[]
    OR?: DesignerRatingScalarWhereWithAggregatesInput[]
    NOT?: DesignerRatingScalarWhereWithAggregatesInput | DesignerRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DesignerRating"> | number
    designerId?: IntWithAggregatesFilter<"DesignerRating"> | number
    hireRequestId?: IntWithAggregatesFilter<"DesignerRating"> | number
    reviewerName?: StringNullableWithAggregatesFilter<"DesignerRating"> | string | null
    stars?: IntWithAggregatesFilter<"DesignerRating"> | number
    review?: StringNullableWithAggregatesFilter<"DesignerRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DesignerRating"> | Date | string
  }

  export type UserRatingWhereInput = {
    AND?: UserRatingWhereInput | UserRatingWhereInput[]
    OR?: UserRatingWhereInput[]
    NOT?: UserRatingWhereInput | UserRatingWhereInput[]
    id?: IntFilter<"UserRating"> | number
    hireRequestId?: IntFilter<"UserRating"> | number
    designerId?: IntNullableFilter<"UserRating"> | number | null
    reviewerName?: StringNullableFilter<"UserRating"> | string | null
    stars?: IntFilter<"UserRating"> | number
    review?: StringNullableFilter<"UserRating"> | string | null
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
    hireRequest?: XOR<DesignerHireRequestScalarRelationFilter, DesignerHireRequestWhereInput>
    designer?: XOR<DesignerNullableScalarRelationFilter, DesignerWhereInput> | null
  }

  export type UserRatingOrderByWithRelationInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrderInput | SortOrder
    stars?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hireRequest?: DesignerHireRequestOrderByWithRelationInput
    designer?: DesignerOrderByWithRelationInput
  }

  export type UserRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hireRequestId?: number
    AND?: UserRatingWhereInput | UserRatingWhereInput[]
    OR?: UserRatingWhereInput[]
    NOT?: UserRatingWhereInput | UserRatingWhereInput[]
    designerId?: IntNullableFilter<"UserRating"> | number | null
    reviewerName?: StringNullableFilter<"UserRating"> | string | null
    stars?: IntFilter<"UserRating"> | number
    review?: StringNullableFilter<"UserRating"> | string | null
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
    hireRequest?: XOR<DesignerHireRequestScalarRelationFilter, DesignerHireRequestWhereInput>
    designer?: XOR<DesignerNullableScalarRelationFilter, DesignerWhereInput> | null
  }, "id" | "hireRequestId">

  export type UserRatingOrderByWithAggregationInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrderInput | SortOrder
    stars?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserRatingCountOrderByAggregateInput
    _avg?: UserRatingAvgOrderByAggregateInput
    _max?: UserRatingMaxOrderByAggregateInput
    _min?: UserRatingMinOrderByAggregateInput
    _sum?: UserRatingSumOrderByAggregateInput
  }

  export type UserRatingScalarWhereWithAggregatesInput = {
    AND?: UserRatingScalarWhereWithAggregatesInput | UserRatingScalarWhereWithAggregatesInput[]
    OR?: UserRatingScalarWhereWithAggregatesInput[]
    NOT?: UserRatingScalarWhereWithAggregatesInput | UserRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRating"> | number
    hireRequestId?: IntWithAggregatesFilter<"UserRating"> | number
    designerId?: IntNullableWithAggregatesFilter<"UserRating"> | number | null
    reviewerName?: StringNullableWithAggregatesFilter<"UserRating"> | string | null
    stars?: IntWithAggregatesFilter<"UserRating"> | number
    review?: StringNullableWithAggregatesFilter<"UserRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRating"> | Date | string
  }

  export type ReturnRequestWhereInput = {
    AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    OR?: ReturnRequestWhereInput[]
    NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    id?: IntFilter<"ReturnRequest"> | number
    orderItemId?: IntFilter<"ReturnRequest"> | number
    userId?: IntFilter<"ReturnRequest"> | number
    productName?: StringFilter<"ReturnRequest"> | string
    sellerId?: IntFilter<"ReturnRequest"> | number
    sellerName?: StringNullableFilter<"ReturnRequest"> | string | null
    reason?: StringFilter<"ReturnRequest"> | string
    note?: StringNullableFilter<"ReturnRequest"> | string | null
    images?: StringNullableListFilter<"ReturnRequest">
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    sellerApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    adminApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    sellerDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    adminDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnRequest"> | $Enums.RefundMethod | null
    refundAmount?: FloatNullableFilter<"ReturnRequest"> | number | null
    refundStatus?: EnumRefundStatusFilter<"ReturnRequest"> | $Enums.RefundStatus
    refundDetails?: StringNullableFilter<"ReturnRequest"> | string | null
    createdAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReturnRequestOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    productName?: SortOrder
    sellerId?: SortOrder
    sellerName?: SortOrderInput | SortOrder
    reason?: SortOrder
    note?: SortOrderInput | SortOrder
    images?: SortOrder
    requestedAt?: SortOrder
    sellerApprovalStatus?: SortOrder
    adminApprovalStatus?: SortOrder
    sellerApprovedAt?: SortOrderInput | SortOrder
    adminApprovedAt?: SortOrderInput | SortOrder
    sellerDecisionNote?: SortOrderInput | SortOrder
    adminDecisionNote?: SortOrderInput | SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReturnRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderItemId?: number
    AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    OR?: ReturnRequestWhereInput[]
    NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    userId?: IntFilter<"ReturnRequest"> | number
    productName?: StringFilter<"ReturnRequest"> | string
    sellerId?: IntFilter<"ReturnRequest"> | number
    sellerName?: StringNullableFilter<"ReturnRequest"> | string | null
    reason?: StringFilter<"ReturnRequest"> | string
    note?: StringNullableFilter<"ReturnRequest"> | string | null
    images?: StringNullableListFilter<"ReturnRequest">
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    sellerApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    adminApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    sellerDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    adminDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnRequest"> | $Enums.RefundMethod | null
    refundAmount?: FloatNullableFilter<"ReturnRequest"> | number | null
    refundStatus?: EnumRefundStatusFilter<"ReturnRequest"> | $Enums.RefundStatus
    refundDetails?: StringNullableFilter<"ReturnRequest"> | string | null
    createdAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderItemId">

  export type ReturnRequestOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    productName?: SortOrder
    sellerId?: SortOrder
    sellerName?: SortOrderInput | SortOrder
    reason?: SortOrder
    note?: SortOrderInput | SortOrder
    images?: SortOrder
    requestedAt?: SortOrder
    sellerApprovalStatus?: SortOrder
    adminApprovalStatus?: SortOrder
    sellerApprovedAt?: SortOrderInput | SortOrder
    adminApprovedAt?: SortOrderInput | SortOrder
    sellerDecisionNote?: SortOrderInput | SortOrder
    adminDecisionNote?: SortOrderInput | SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    refundDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReturnRequestCountOrderByAggregateInput
    _avg?: ReturnRequestAvgOrderByAggregateInput
    _max?: ReturnRequestMaxOrderByAggregateInput
    _min?: ReturnRequestMinOrderByAggregateInput
    _sum?: ReturnRequestSumOrderByAggregateInput
  }

  export type ReturnRequestScalarWhereWithAggregatesInput = {
    AND?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[]
    OR?: ReturnRequestScalarWhereWithAggregatesInput[]
    NOT?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReturnRequest"> | number
    orderItemId?: IntWithAggregatesFilter<"ReturnRequest"> | number
    userId?: IntWithAggregatesFilter<"ReturnRequest"> | number
    productName?: StringWithAggregatesFilter<"ReturnRequest"> | string
    sellerId?: IntWithAggregatesFilter<"ReturnRequest"> | number
    sellerName?: StringNullableWithAggregatesFilter<"ReturnRequest"> | string | null
    reason?: StringWithAggregatesFilter<"ReturnRequest"> | string
    note?: StringNullableWithAggregatesFilter<"ReturnRequest"> | string | null
    images?: StringNullableListFilter<"ReturnRequest">
    requestedAt?: DateTimeWithAggregatesFilter<"ReturnRequest"> | Date | string
    sellerApprovalStatus?: EnumApprovalStatusWithAggregatesFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusWithAggregatesFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    sellerApprovedAt?: DateTimeNullableWithAggregatesFilter<"ReturnRequest"> | Date | string | null
    adminApprovedAt?: DateTimeNullableWithAggregatesFilter<"ReturnRequest"> | Date | string | null
    sellerDecisionNote?: StringNullableWithAggregatesFilter<"ReturnRequest"> | string | null
    adminDecisionNote?: StringNullableWithAggregatesFilter<"ReturnRequest"> | string | null
    refundMethod?: EnumRefundMethodNullableWithAggregatesFilter<"ReturnRequest"> | $Enums.RefundMethod | null
    refundAmount?: FloatNullableWithAggregatesFilter<"ReturnRequest"> | number | null
    refundStatus?: EnumRefundStatusWithAggregatesFilter<"ReturnRequest"> | $Enums.RefundStatus
    refundDetails?: StringNullableWithAggregatesFilter<"ReturnRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReturnRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReturnRequest"> | Date | string
  }

  export type ContactMessageWhereInput = {
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    id?: IntFilter<"ContactMessage"> | number
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    message?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }

  export type ContactMessageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    message?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }, "id">

  export type ContactMessageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ContactMessageCountOrderByAggregateInput
    _avg?: ContactMessageAvgOrderByAggregateInput
    _max?: ContactMessageMaxOrderByAggregateInput
    _min?: ContactMessageMinOrderByAggregateInput
    _sum?: ContactMessageSumOrderByAggregateInput
  }

  export type ContactMessageScalarWhereWithAggregatesInput = {
    AND?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    OR?: ContactMessageScalarWhereWithAggregatesInput[]
    NOT?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactMessage"> | number
    name?: StringWithAggregatesFilter<"ContactMessage"> | string
    email?: StringWithAggregatesFilter<"ContactMessage"> | string
    message?: StringWithAggregatesFilter<"ContactMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
  }

  export type CustomerOtpCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type CustomerOtpUncheckedCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type CustomerOtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOtpCreateManyInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type CustomerOtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerOtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerCreateInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutSellerInput
    products?: ProductCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutSellerInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutSellerNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutSellerNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type SellerCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
  }

  export type SellerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerOtpCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type SellerOtpUncheckedCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type SellerOtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerOtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerOtpCreateManyInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type SellerOtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerOtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBusinessDetailsCreateInput = {
    businessName: string
    sellerType: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    gst?: string | null
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutBusinessInput
  }

  export type SellerBusinessDetailsUncheckedCreateInput = {
    id?: number
    businessName: string
    sellerType: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    gst?: string | null
    sellerId: number
    createdAt?: Date | string
  }

  export type SellerBusinessDetailsUpdateInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutBusinessNestedInput
  }

  export type SellerBusinessDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBusinessDetailsCreateManyInput = {
    id?: number
    businessName: string
    sellerType: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    gst?: string | null
    sellerId: number
    createdAt?: Date | string
  }

  export type SellerBusinessDetailsUpdateManyMutationInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBusinessDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerDeliveryDetailsCreateInput = {
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType: string
    shippingCharge?: number | null
    internationalDelivery?: boolean
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutDeliveryInput
  }

  export type SellerDeliveryDetailsUncheckedCreateInput = {
    id?: number
    sellerId: number
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType: string
    shippingCharge?: number | null
    internationalDelivery?: boolean
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type SellerDeliveryDetailsUpdateInput = {
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutDeliveryNestedInput
  }

  export type SellerDeliveryDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerDeliveryDetailsCreateManyInput = {
    id?: number
    sellerId: number
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType: string
    shippingCharge?: number | null
    internationalDelivery?: boolean
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type SellerDeliveryDetailsUpdateManyMutationInput = {
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerDeliveryDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBankDetailsCreateInput = {
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutBankInput
  }

  export type SellerBankDetailsUncheckedCreateInput = {
    id?: number
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    sellerId: number
    createdAt?: Date | string
  }

  export type SellerBankDetailsUpdateInput = {
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutBankNestedInput
  }

  export type SellerBankDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBankDetailsCreateManyInput = {
    id?: number
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    sellerId: number
    createdAt?: Date | string
  }

  export type SellerBankDetailsUpdateManyMutationInput = {
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBankDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutProductsInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    sellerId: number
    createdAt?: Date | string
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutProductsNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    sellerId: number
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    userId: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    userId: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    seller: SellerCreateNestedOneWithoutOrderItemsInput
    rating?: RatingCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    rating?: RatingUncheckedCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    seller?: SellerUpdateOneRequiredWithoutOrderItemsNestedInput
    rating?: RatingUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    stars: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
    product: ProductCreateNestedOneWithoutRatingsInput
    orderItem: OrderItemCreateNestedOneWithoutRatingInput
  }

  export type RatingUncheckedCreateInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    userId: number
    productId: number
    orderItemId: number
  }

  export type RatingUpdateInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
    product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutRatingNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RatingCreateManyInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    userId: number
    productId: number
    orderItemId: number
  }

  export type RatingUpdateManyMutationInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type DesignerCreateInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUpdateInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerCreateManyInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignerUpdateManyMutationInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerOtpCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type DesignerOtpUncheckedCreateInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type DesignerOtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerOtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerOtpCreateManyInput = {
    id?: string
    email: string
    otpHash: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type DesignerOtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerOtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otpHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerProfileCreateInput = {
    experience?: string | null
    portfolio?: string | null
    designerType?: string | null
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    designer: DesignerCreateNestedOneWithoutProfileInput
  }

  export type DesignerProfileUncheckedCreateInput = {
    id?: number
    designerId: number
    experience?: string | null
    portfolio?: string | null
    designerType?: string | null
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignerProfileUpdateInput = {
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneRequiredWithoutProfileNestedInput
  }

  export type DesignerProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerProfileCreateManyInput = {
    id?: number
    designerId: number
    experience?: string | null
    portfolio?: string | null
    designerType?: string | null
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignerProfileUpdateManyMutationInput = {
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkCreateInput = {
    image: string
    description?: string | null
    createdAt?: Date | string
    designer: DesignerCreateNestedOneWithoutWorksInput
  }

  export type DesignerWorkUncheckedCreateInput = {
    id?: number
    designerId: number
    image: string
    description?: string | null
    createdAt?: Date | string
  }

  export type DesignerWorkUpdateInput = {
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneRequiredWithoutWorksNestedInput
  }

  export type DesignerWorkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkCreateManyInput = {
    id?: number
    designerId: number
    image: string
    description?: string | null
    createdAt?: Date | string
  }

  export type DesignerWorkUpdateManyMutationInput = {
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerHireRequestCreateInput = {
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHireRequestsInput
    designer: DesignerCreateNestedOneWithoutHireRequestsInput
    rating?: DesignerRatingCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUncheckedCreateInput = {
    id?: number
    userId: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    rating?: DesignerRatingUncheckedCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingUncheckedCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHireRequestsNestedInput
    designer?: DesignerUpdateOneRequiredWithoutHireRequestsNestedInput
    rating?: DesignerRatingUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: DesignerRatingUncheckedUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUncheckedUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestCreateManyInput = {
    id?: number
    userId: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type DesignerHireRequestUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerHireRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerRatingCreateInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    designer: DesignerCreateNestedOneWithoutRatingsInput
    hireRequest: DesignerHireRequestCreateNestedOneWithoutRatingInput
  }

  export type DesignerRatingUncheckedCreateInput = {
    id?: number
    designerId: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type DesignerRatingUpdateInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneRequiredWithoutRatingsNestedInput
    hireRequest?: DesignerHireRequestUpdateOneRequiredWithoutRatingNestedInput
  }

  export type DesignerRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerRatingCreateManyInput = {
    id?: number
    designerId: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type DesignerRatingUpdateManyMutationInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingCreateInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    hireRequest: DesignerHireRequestCreateNestedOneWithoutUserRatingInput
    designer?: DesignerCreateNestedOneWithoutUserRatingsInput
  }

  export type UserRatingUncheckedCreateInput = {
    id?: number
    hireRequestId: number
    designerId?: number | null
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type UserRatingUpdateInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hireRequest?: DesignerHireRequestUpdateOneRequiredWithoutUserRatingNestedInput
    designer?: DesignerUpdateOneWithoutUserRatingsNestedInput
  }

  export type UserRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    designerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingCreateManyInput = {
    id?: number
    hireRequestId: number
    designerId?: number | null
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type UserRatingUpdateManyMutationInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    designerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnRequestCreateInput = {
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReturnRequestInput
    user: UserCreateNestedOneWithoutReturnRequestsInput
  }

  export type ReturnRequestUncheckedCreateInput = {
    id?: number
    orderItemId: number
    userId: number
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnRequestUpdateInput = {
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput
    user?: UserUpdateOneRequiredWithoutReturnRequestsNestedInput
  }

  export type ReturnRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnRequestCreateManyInput = {
    id?: number
    orderItemId: number
    userId: number
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnRequestUpdateManyMutationInput = {
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateInput = {
    name: string
    email: string
    message: string
    createdAt?: Date | string
  }

  export type ContactMessageUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    message: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateManyInput = {
    id?: number
    name: string
    email: string
    message: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type DesignerHireRequestListRelationFilter = {
    every?: DesignerHireRequestWhereInput
    some?: DesignerHireRequestWhereInput
    none?: DesignerHireRequestWhereInput
  }

  export type ReturnRequestListRelationFilter = {
    every?: ReturnRequestWhereInput
    some?: ReturnRequestWhereInput
    none?: ReturnRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignerHireRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    credit?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    credit?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    credit?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CustomerOtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerOtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SellerBusinessDetailsNullableScalarRelationFilter = {
    is?: SellerBusinessDetailsWhereInput | null
    isNot?: SellerBusinessDetailsWhereInput | null
  }

  export type SellerDeliveryDetailsNullableScalarRelationFilter = {
    is?: SellerDeliveryDetailsWhereInput | null
    isNot?: SellerDeliveryDetailsWhereInput | null
  }

  export type SellerBankDetailsNullableScalarRelationFilter = {
    is?: SellerBankDetailsWhereInput | null
    isNot?: SellerBankDetailsWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phoneVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SellerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phoneVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    phoneVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SellerOtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerOtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerScalarRelationFilter = {
    is?: SellerWhereInput
    isNot?: SellerWhereInput
  }

  export type SellerBusinessDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    sellerType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    gst?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBusinessDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
  }

  export type SellerBusinessDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    sellerType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    gst?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBusinessDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    sellerType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    gst?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBusinessDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SellerDeliveryDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryResponsibility?: SortOrder
    deliveryCoverage?: SortOrder
    deliveryType?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    internationalDelivery?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerDeliveryDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingCharge?: SortOrder
    installationCharge?: SortOrder
  }

  export type SellerDeliveryDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryResponsibility?: SortOrder
    deliveryCoverage?: SortOrder
    deliveryType?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    internationalDelivery?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerDeliveryDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryResponsibility?: SortOrder
    deliveryCoverage?: SortOrder
    deliveryType?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    internationalDelivery?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerDeliveryDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingCharge?: SortOrder
    installationCharge?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SellerBankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    accountHolder?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBankDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
  }

  export type SellerBankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountHolder?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    accountHolder?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifsc?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SellerBankDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    images?: SortOrder
    video?: SortOrder
    availability?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    video?: SortOrder
    availability?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    productType?: SortOrder
    category?: SortOrder
    description?: SortOrder
    video?: SortOrder
    availability?: SortOrder
    sellerId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    address?: SortOrder
    paymentMethod?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    address?: SortOrder
    paymentMethod?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    address?: SortOrder
    paymentMethod?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subtotal?: SortOrder
    casaCharge?: SortOrder
    deliveryCharge?: SortOrder
    grandTotal?: SortOrder
  }

  export type EnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type RatingNullableScalarRelationFilter = {
    is?: RatingWhereInput | null
    isNot?: RatingWhereInput | null
  }

  export type ReturnRequestNullableScalarRelationFilter = {
    is?: ReturnRequestWhereInput | null
    isNot?: ReturnRequestWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    supplierName?: SortOrder
    imageUrl?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    returnStatus?: SortOrder
    returnReason?: SortOrder
    returnRequestedAt?: SortOrder
    returnResolvedAt?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundProcessedAt?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    refundAmount?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingCharge?: SortOrder
    installationCharge?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    supplierName?: SortOrder
    imageUrl?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    returnStatus?: SortOrder
    returnReason?: SortOrder
    returnRequestedAt?: SortOrder
    returnResolvedAt?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundProcessedAt?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    materialName?: SortOrder
    supplierName?: SortOrder
    imageUrl?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    returnStatus?: SortOrder
    returnReason?: SortOrder
    returnRequestedAt?: SortOrder
    returnResolvedAt?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundProcessedAt?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingChargeType?: SortOrder
    shippingCharge?: SortOrder
    installationAvailable?: SortOrder
    installationCharge?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sellerId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalAmount?: SortOrder
    refundAmount?: SortOrder
    deliveryTimeMin?: SortOrder
    deliveryTimeMax?: SortOrder
    shippingCharge?: SortOrder
    installationCharge?: SortOrder
  }

  export type EnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderItemId?: SortOrder
  }

  export type DesignerProfileNullableScalarRelationFilter = {
    is?: DesignerProfileWhereInput | null
    isNot?: DesignerProfileWhereInput | null
  }

  export type DesignerWorkListRelationFilter = {
    every?: DesignerWorkWhereInput
    some?: DesignerWorkWhereInput
    none?: DesignerWorkWhereInput
  }

  export type DesignerRatingListRelationFilter = {
    every?: DesignerRatingWhereInput
    some?: DesignerRatingWhereInput
    none?: DesignerRatingWhereInput
  }

  export type UserRatingListRelationFilter = {
    every?: UserRatingWhereInput
    some?: UserRatingWhereInput
    none?: UserRatingWhereInput
  }

  export type DesignerWorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignerRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesignerCountOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    passwordHash?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DesignerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    passwordHash?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerMinOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    passwordHash?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DesignerOtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerOtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otpHash?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerScalarRelationFilter = {
    is?: DesignerWhereInput
    isNot?: DesignerWhereInput
  }

  export type DesignerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    experience?: SortOrder
    portfolio?: SortOrder
    designerType?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
  }

  export type DesignerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    experience?: SortOrder
    portfolio?: SortOrder
    designerType?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    experience?: SortOrder
    portfolio?: SortOrder
    designerType?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignerProfileSumOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
  }

  export type DesignerWorkCountOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerWorkAvgOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
  }

  export type DesignerWorkMaxOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerWorkMinOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerWorkSumOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
  }

  export type DesignerRatingNullableScalarRelationFilter = {
    is?: DesignerRatingWhereInput | null
    isNot?: DesignerRatingWhereInput | null
  }

  export type UserRatingNullableScalarRelationFilter = {
    is?: UserRatingWhereInput | null
    isNot?: UserRatingWhereInput | null
  }

  export type DesignerHireRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    budget?: SortOrder
    workType?: SortOrder
    timelineDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerHireRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    budget?: SortOrder
  }

  export type DesignerHireRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    budget?: SortOrder
    workType?: SortOrder
    timelineDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerHireRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    location?: SortOrder
    budget?: SortOrder
    workType?: SortOrder
    timelineDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerHireRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    designerId?: SortOrder
    budget?: SortOrder
  }

  export type DesignerHireRequestScalarRelationFilter = {
    is?: DesignerHireRequestWhereInput
    isNot?: DesignerHireRequestWhereInput
  }

  export type DesignerRatingCountOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    stars?: SortOrder
  }

  export type DesignerRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerRatingMinOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type DesignerRatingSumOrderByAggregateInput = {
    id?: SortOrder
    designerId?: SortOrder
    hireRequestId?: SortOrder
    stars?: SortOrder
  }

  export type DesignerNullableScalarRelationFilter = {
    is?: DesignerWhereInput | null
    isNot?: DesignerWhereInput | null
  }

  export type UserRatingCountOrderByAggregateInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrder
    stars?: SortOrder
  }

  export type UserRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRatingMinOrderByAggregateInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrder
    reviewerName?: SortOrder
    stars?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRatingSumOrderByAggregateInput = {
    id?: SortOrder
    hireRequestId?: SortOrder
    designerId?: SortOrder
    stars?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type EnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type ReturnRequestCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    productName?: SortOrder
    sellerId?: SortOrder
    sellerName?: SortOrder
    reason?: SortOrder
    note?: SortOrder
    images?: SortOrder
    requestedAt?: SortOrder
    sellerApprovalStatus?: SortOrder
    adminApprovalStatus?: SortOrder
    sellerApprovedAt?: SortOrder
    adminApprovedAt?: SortOrder
    sellerDecisionNote?: SortOrder
    adminDecisionNote?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundDetails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    refundAmount?: SortOrder
  }

  export type ReturnRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    productName?: SortOrder
    sellerId?: SortOrder
    sellerName?: SortOrder
    reason?: SortOrder
    note?: SortOrder
    requestedAt?: SortOrder
    sellerApprovalStatus?: SortOrder
    adminApprovalStatus?: SortOrder
    sellerApprovedAt?: SortOrder
    adminApprovedAt?: SortOrder
    sellerDecisionNote?: SortOrder
    adminDecisionNote?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundDetails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnRequestMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    productName?: SortOrder
    sellerId?: SortOrder
    sellerName?: SortOrder
    reason?: SortOrder
    note?: SortOrder
    requestedAt?: SortOrder
    sellerApprovalStatus?: SortOrder
    adminApprovalStatus?: SortOrder
    sellerApprovedAt?: SortOrder
    adminApprovedAt?: SortOrder
    sellerDecisionNote?: SortOrder
    adminDecisionNote?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    refundDetails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnRequestSumOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    refundAmount?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type EnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type ContactMessageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type DesignerHireRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput> | DesignerHireRequestCreateWithoutUserInput[] | DesignerHireRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserInput | DesignerHireRequestCreateOrConnectWithoutUserInput[]
    createMany?: DesignerHireRequestCreateManyUserInputEnvelope
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
  }

  export type ReturnRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput> | ReturnRequestCreateWithoutUserInput[] | ReturnRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutUserInput | ReturnRequestCreateOrConnectWithoutUserInput[]
    createMany?: ReturnRequestCreateManyUserInputEnvelope
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type DesignerHireRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput> | DesignerHireRequestCreateWithoutUserInput[] | DesignerHireRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserInput | DesignerHireRequestCreateOrConnectWithoutUserInput[]
    createMany?: DesignerHireRequestCreateManyUserInputEnvelope
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
  }

  export type ReturnRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput> | ReturnRequestCreateWithoutUserInput[] | ReturnRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutUserInput | ReturnRequestCreateOrConnectWithoutUserInput[]
    createMany?: ReturnRequestCreateManyUserInputEnvelope
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type DesignerHireRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput> | DesignerHireRequestCreateWithoutUserInput[] | DesignerHireRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserInput | DesignerHireRequestCreateOrConnectWithoutUserInput[]
    upsert?: DesignerHireRequestUpsertWithWhereUniqueWithoutUserInput | DesignerHireRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DesignerHireRequestCreateManyUserInputEnvelope
    set?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    disconnect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    delete?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    update?: DesignerHireRequestUpdateWithWhereUniqueWithoutUserInput | DesignerHireRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DesignerHireRequestUpdateManyWithWhereWithoutUserInput | DesignerHireRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
  }

  export type ReturnRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput> | ReturnRequestCreateWithoutUserInput[] | ReturnRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutUserInput | ReturnRequestCreateOrConnectWithoutUserInput[]
    upsert?: ReturnRequestUpsertWithWhereUniqueWithoutUserInput | ReturnRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReturnRequestCreateManyUserInputEnvelope
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    update?: ReturnRequestUpdateWithWhereUniqueWithoutUserInput | ReturnRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReturnRequestUpdateManyWithWhereWithoutUserInput | ReturnRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type DesignerHireRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput> | DesignerHireRequestCreateWithoutUserInput[] | DesignerHireRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserInput | DesignerHireRequestCreateOrConnectWithoutUserInput[]
    upsert?: DesignerHireRequestUpsertWithWhereUniqueWithoutUserInput | DesignerHireRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DesignerHireRequestCreateManyUserInputEnvelope
    set?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    disconnect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    delete?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    update?: DesignerHireRequestUpdateWithWhereUniqueWithoutUserInput | DesignerHireRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DesignerHireRequestUpdateManyWithWhereWithoutUserInput | DesignerHireRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
  }

  export type ReturnRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput> | ReturnRequestCreateWithoutUserInput[] | ReturnRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutUserInput | ReturnRequestCreateOrConnectWithoutUserInput[]
    upsert?: ReturnRequestUpsertWithWhereUniqueWithoutUserInput | ReturnRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReturnRequestCreateManyUserInputEnvelope
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    update?: ReturnRequestUpdateWithWhereUniqueWithoutUserInput | ReturnRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReturnRequestUpdateManyWithWhereWithoutUserInput | ReturnRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrderItemCreateNestedManyWithoutSellerInput = {
    create?: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput> | OrderItemCreateWithoutSellerInput[] | OrderItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutSellerInput | OrderItemCreateOrConnectWithoutSellerInput[]
    createMany?: OrderItemCreateManySellerInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SellerBusinessDetailsCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBusinessDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerBusinessDetailsWhereUniqueInput
  }

  export type SellerDeliveryDetailsCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerDeliveryDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerDeliveryDetailsWhereUniqueInput
  }

  export type SellerBankDetailsCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBankDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerBankDetailsWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput> | OrderItemCreateWithoutSellerInput[] | OrderItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutSellerInput | OrderItemCreateOrConnectWithoutSellerInput[]
    createMany?: OrderItemCreateManySellerInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBusinessDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerBusinessDetailsWhereUniqueInput
  }

  export type SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerDeliveryDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerDeliveryDetailsWhereUniqueInput
  }

  export type SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput = {
    create?: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBankDetailsCreateOrConnectWithoutSellerInput
    connect?: SellerBankDetailsWhereUniqueInput
  }

  export type OrderItemUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput> | OrderItemCreateWithoutSellerInput[] | OrderItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutSellerInput | OrderItemCreateOrConnectWithoutSellerInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutSellerInput | OrderItemUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OrderItemCreateManySellerInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutSellerInput | OrderItemUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutSellerInput | OrderItemUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SellerBusinessDetailsUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBusinessDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerBusinessDetailsUpsertWithoutSellerInput
    disconnect?: SellerBusinessDetailsWhereInput | boolean
    delete?: SellerBusinessDetailsWhereInput | boolean
    connect?: SellerBusinessDetailsWhereUniqueInput
    update?: XOR<XOR<SellerBusinessDetailsUpdateToOneWithWhereWithoutSellerInput, SellerBusinessDetailsUpdateWithoutSellerInput>, SellerBusinessDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerDeliveryDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerDeliveryDetailsUpsertWithoutSellerInput
    disconnect?: SellerDeliveryDetailsWhereInput | boolean
    delete?: SellerDeliveryDetailsWhereInput | boolean
    connect?: SellerDeliveryDetailsWhereUniqueInput
    update?: XOR<XOR<SellerDeliveryDetailsUpdateToOneWithWhereWithoutSellerInput, SellerDeliveryDetailsUpdateWithoutSellerInput>, SellerDeliveryDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerBankDetailsUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBankDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerBankDetailsUpsertWithoutSellerInput
    disconnect?: SellerBankDetailsWhereInput | boolean
    delete?: SellerBankDetailsWhereInput | boolean
    connect?: SellerBankDetailsWhereUniqueInput
    update?: XOR<XOR<SellerBankDetailsUpdateToOneWithWhereWithoutSellerInput, SellerBankDetailsUpdateWithoutSellerInput>, SellerBankDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput> | OrderItemCreateWithoutSellerInput[] | OrderItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutSellerInput | OrderItemCreateOrConnectWithoutSellerInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutSellerInput | OrderItemUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OrderItemCreateManySellerInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutSellerInput | OrderItemUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutSellerInput | OrderItemUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBusinessDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerBusinessDetailsUpsertWithoutSellerInput
    disconnect?: SellerBusinessDetailsWhereInput | boolean
    delete?: SellerBusinessDetailsWhereInput | boolean
    connect?: SellerBusinessDetailsWhereUniqueInput
    update?: XOR<XOR<SellerBusinessDetailsUpdateToOneWithWhereWithoutSellerInput, SellerBusinessDetailsUpdateWithoutSellerInput>, SellerBusinessDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerDeliveryDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerDeliveryDetailsUpsertWithoutSellerInput
    disconnect?: SellerDeliveryDetailsWhereInput | boolean
    delete?: SellerDeliveryDetailsWhereInput | boolean
    connect?: SellerDeliveryDetailsWhereUniqueInput
    update?: XOR<XOR<SellerDeliveryDetailsUpdateToOneWithWhereWithoutSellerInput, SellerDeliveryDetailsUpdateWithoutSellerInput>, SellerDeliveryDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput = {
    create?: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
    connectOrCreate?: SellerBankDetailsCreateOrConnectWithoutSellerInput
    upsert?: SellerBankDetailsUpsertWithoutSellerInput
    disconnect?: SellerBankDetailsWhereInput | boolean
    delete?: SellerBankDetailsWhereInput | boolean
    connect?: SellerBankDetailsWhereUniqueInput
    update?: XOR<XOR<SellerBankDetailsUpdateToOneWithWhereWithoutSellerInput, SellerBankDetailsUpdateWithoutSellerInput>, SellerBankDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerCreateNestedOneWithoutBusinessInput = {
    create?: XOR<SellerCreateWithoutBusinessInput, SellerUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: SellerCreateOrConnectWithoutBusinessInput
    connect?: SellerWhereUniqueInput
  }

  export type SellerUpdateOneRequiredWithoutBusinessNestedInput = {
    create?: XOR<SellerCreateWithoutBusinessInput, SellerUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: SellerCreateOrConnectWithoutBusinessInput
    upsert?: SellerUpsertWithoutBusinessInput
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutBusinessInput, SellerUpdateWithoutBusinessInput>, SellerUncheckedUpdateWithoutBusinessInput>
  }

  export type SellerCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<SellerCreateWithoutDeliveryInput, SellerUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: SellerCreateOrConnectWithoutDeliveryInput
    connect?: SellerWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SellerUpdateOneRequiredWithoutDeliveryNestedInput = {
    create?: XOR<SellerCreateWithoutDeliveryInput, SellerUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: SellerCreateOrConnectWithoutDeliveryInput
    upsert?: SellerUpsertWithoutDeliveryInput
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutDeliveryInput, SellerUpdateWithoutDeliveryInput>, SellerUncheckedUpdateWithoutDeliveryInput>
  }

  export type SellerCreateNestedOneWithoutBankInput = {
    create?: XOR<SellerCreateWithoutBankInput, SellerUncheckedCreateWithoutBankInput>
    connectOrCreate?: SellerCreateOrConnectWithoutBankInput
    connect?: SellerWhereUniqueInput
  }

  export type SellerUpdateOneRequiredWithoutBankNestedInput = {
    create?: XOR<SellerCreateWithoutBankInput, SellerUncheckedCreateWithoutBankInput>
    connectOrCreate?: SellerCreateOrConnectWithoutBankInput
    upsert?: SellerUpsertWithoutBankInput
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutBankInput, SellerUpdateWithoutBankInput>, SellerUncheckedUpdateWithoutBankInput>
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type SellerCreateNestedOneWithoutProductsInput = {
    create?: XOR<SellerCreateWithoutProductsInput, SellerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutProductsInput
    connect?: SellerWhereUniqueInput
  }

  export type RatingCreateNestedManyWithoutProductInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SellerUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SellerCreateWithoutProductsInput, SellerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutProductsInput
    upsert?: SellerUpsertWithoutProductsInput
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutProductsInput, SellerUpdateWithoutProductsInput>, SellerUncheckedUpdateWithoutProductsInput>
  }

  export type RatingUpdateManyWithoutProductNestedInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutProductInput | RatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutProductInput | RatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutProductInput | RatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutProductInput | RatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutProductInput | RatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutProductInput | RatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type SellerCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<SellerCreateWithoutOrderItemsInput, SellerUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutOrderItemsInput
    connect?: SellerWhereUniqueInput
  }

  export type RatingCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: RatingCreateOrConnectWithoutOrderItemInput
    connect?: RatingWhereUniqueInput
  }

  export type ReturnRequestCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput
    connect?: ReturnRequestWhereUniqueInput
  }

  export type RatingUncheckedCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: RatingCreateOrConnectWithoutOrderItemInput
    connect?: RatingWhereUniqueInput
  }

  export type ReturnRequestUncheckedCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput
    connect?: ReturnRequestWhereUniqueInput
  }

  export type EnumReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type SellerUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<SellerCreateWithoutOrderItemsInput, SellerUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutOrderItemsInput
    upsert?: SellerUpsertWithoutOrderItemsInput
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutOrderItemsInput, SellerUpdateWithoutOrderItemsInput>, SellerUncheckedUpdateWithoutOrderItemsInput>
  }

  export type RatingUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: RatingCreateOrConnectWithoutOrderItemInput
    upsert?: RatingUpsertWithoutOrderItemInput
    disconnect?: RatingWhereInput | boolean
    delete?: RatingWhereInput | boolean
    connect?: RatingWhereUniqueInput
    update?: XOR<XOR<RatingUpdateToOneWithWhereWithoutOrderItemInput, RatingUpdateWithoutOrderItemInput>, RatingUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReturnRequestUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput
    upsert?: ReturnRequestUpsertWithoutOrderItemInput
    disconnect?: ReturnRequestWhereInput | boolean
    delete?: ReturnRequestWhereInput | boolean
    connect?: ReturnRequestWhereUniqueInput
    update?: XOR<XOR<ReturnRequestUpdateToOneWithWhereWithoutOrderItemInput, ReturnRequestUpdateWithoutOrderItemInput>, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
  }

  export type RatingUncheckedUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: RatingCreateOrConnectWithoutOrderItemInput
    upsert?: RatingUpsertWithoutOrderItemInput
    disconnect?: RatingWhereInput | boolean
    delete?: RatingWhereInput | boolean
    connect?: RatingWhereUniqueInput
    update?: XOR<XOR<RatingUpdateToOneWithWhereWithoutOrderItemInput, RatingUpdateWithoutOrderItemInput>, RatingUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReturnRequestUncheckedUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput
    upsert?: ReturnRequestUpsertWithoutOrderItemInput
    disconnect?: ReturnRequestWhereInput | boolean
    delete?: ReturnRequestWhereInput | boolean
    connect?: ReturnRequestWhereUniqueInput
    update?: XOR<XOR<ReturnRequestUpdateToOneWithWhereWithoutOrderItemInput, ReturnRequestUpdateWithoutOrderItemInput>, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutRatingInput = {
    create?: XOR<OrderItemCreateWithoutRatingInput, OrderItemUncheckedCreateWithoutRatingInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutRatingInput
    connect?: OrderItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    upsert?: ProductUpsertWithoutRatingsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRatingsInput, ProductUpdateWithoutRatingsInput>, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type OrderItemUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<OrderItemCreateWithoutRatingInput, OrderItemUncheckedCreateWithoutRatingInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutRatingInput
    upsert?: OrderItemUpsertWithoutRatingInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutRatingInput, OrderItemUpdateWithoutRatingInput>, OrderItemUncheckedUpdateWithoutRatingInput>
  }

  export type DesignerProfileCreateNestedOneWithoutDesignerInput = {
    create?: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
    connectOrCreate?: DesignerProfileCreateOrConnectWithoutDesignerInput
    connect?: DesignerProfileWhereUniqueInput
  }

  export type DesignerWorkCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput> | DesignerWorkCreateWithoutDesignerInput[] | DesignerWorkUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerWorkCreateOrConnectWithoutDesignerInput | DesignerWorkCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerWorkCreateManyDesignerInputEnvelope
    connect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
  }

  export type DesignerHireRequestCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput> | DesignerHireRequestCreateWithoutDesignerInput[] | DesignerHireRequestUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutDesignerInput | DesignerHireRequestCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerHireRequestCreateManyDesignerInputEnvelope
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
  }

  export type DesignerRatingCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput> | DesignerRatingCreateWithoutDesignerInput[] | DesignerRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutDesignerInput | DesignerRatingCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerRatingCreateManyDesignerInputEnvelope
    connect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
  }

  export type UserRatingCreateNestedManyWithoutDesignerInput = {
    create?: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput> | UserRatingCreateWithoutDesignerInput[] | UserRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutDesignerInput | UserRatingCreateOrConnectWithoutDesignerInput[]
    createMany?: UserRatingCreateManyDesignerInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput = {
    create?: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
    connectOrCreate?: DesignerProfileCreateOrConnectWithoutDesignerInput
    connect?: DesignerProfileWhereUniqueInput
  }

  export type DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput> | DesignerWorkCreateWithoutDesignerInput[] | DesignerWorkUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerWorkCreateOrConnectWithoutDesignerInput | DesignerWorkCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerWorkCreateManyDesignerInputEnvelope
    connect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
  }

  export type DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput> | DesignerHireRequestCreateWithoutDesignerInput[] | DesignerHireRequestUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutDesignerInput | DesignerHireRequestCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerHireRequestCreateManyDesignerInputEnvelope
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
  }

  export type DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput> | DesignerRatingCreateWithoutDesignerInput[] | DesignerRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutDesignerInput | DesignerRatingCreateOrConnectWithoutDesignerInput[]
    createMany?: DesignerRatingCreateManyDesignerInputEnvelope
    connect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
  }

  export type UserRatingUncheckedCreateNestedManyWithoutDesignerInput = {
    create?: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput> | UserRatingCreateWithoutDesignerInput[] | UserRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutDesignerInput | UserRatingCreateOrConnectWithoutDesignerInput[]
    createMany?: UserRatingCreateManyDesignerInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type DesignerProfileUpdateOneWithoutDesignerNestedInput = {
    create?: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
    connectOrCreate?: DesignerProfileCreateOrConnectWithoutDesignerInput
    upsert?: DesignerProfileUpsertWithoutDesignerInput
    disconnect?: DesignerProfileWhereInput | boolean
    delete?: DesignerProfileWhereInput | boolean
    connect?: DesignerProfileWhereUniqueInput
    update?: XOR<XOR<DesignerProfileUpdateToOneWithWhereWithoutDesignerInput, DesignerProfileUpdateWithoutDesignerInput>, DesignerProfileUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerWorkUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput> | DesignerWorkCreateWithoutDesignerInput[] | DesignerWorkUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerWorkCreateOrConnectWithoutDesignerInput | DesignerWorkCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerWorkUpsertWithWhereUniqueWithoutDesignerInput | DesignerWorkUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerWorkCreateManyDesignerInputEnvelope
    set?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    disconnect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    delete?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    connect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    update?: DesignerWorkUpdateWithWhereUniqueWithoutDesignerInput | DesignerWorkUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerWorkUpdateManyWithWhereWithoutDesignerInput | DesignerWorkUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerWorkScalarWhereInput | DesignerWorkScalarWhereInput[]
  }

  export type DesignerHireRequestUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput> | DesignerHireRequestCreateWithoutDesignerInput[] | DesignerHireRequestUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutDesignerInput | DesignerHireRequestCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerHireRequestUpsertWithWhereUniqueWithoutDesignerInput | DesignerHireRequestUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerHireRequestCreateManyDesignerInputEnvelope
    set?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    disconnect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    delete?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    update?: DesignerHireRequestUpdateWithWhereUniqueWithoutDesignerInput | DesignerHireRequestUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerHireRequestUpdateManyWithWhereWithoutDesignerInput | DesignerHireRequestUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
  }

  export type DesignerRatingUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput> | DesignerRatingCreateWithoutDesignerInput[] | DesignerRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutDesignerInput | DesignerRatingCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerRatingUpsertWithWhereUniqueWithoutDesignerInput | DesignerRatingUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerRatingCreateManyDesignerInputEnvelope
    set?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    disconnect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    delete?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    connect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    update?: DesignerRatingUpdateWithWhereUniqueWithoutDesignerInput | DesignerRatingUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerRatingUpdateManyWithWhereWithoutDesignerInput | DesignerRatingUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerRatingScalarWhereInput | DesignerRatingScalarWhereInput[]
  }

  export type UserRatingUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput> | UserRatingCreateWithoutDesignerInput[] | UserRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutDesignerInput | UserRatingCreateOrConnectWithoutDesignerInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutDesignerInput | UserRatingUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: UserRatingCreateManyDesignerInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutDesignerInput | UserRatingUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutDesignerInput | UserRatingUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput = {
    create?: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
    connectOrCreate?: DesignerProfileCreateOrConnectWithoutDesignerInput
    upsert?: DesignerProfileUpsertWithoutDesignerInput
    disconnect?: DesignerProfileWhereInput | boolean
    delete?: DesignerProfileWhereInput | boolean
    connect?: DesignerProfileWhereUniqueInput
    update?: XOR<XOR<DesignerProfileUpdateToOneWithWhereWithoutDesignerInput, DesignerProfileUpdateWithoutDesignerInput>, DesignerProfileUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput> | DesignerWorkCreateWithoutDesignerInput[] | DesignerWorkUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerWorkCreateOrConnectWithoutDesignerInput | DesignerWorkCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerWorkUpsertWithWhereUniqueWithoutDesignerInput | DesignerWorkUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerWorkCreateManyDesignerInputEnvelope
    set?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    disconnect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    delete?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    connect?: DesignerWorkWhereUniqueInput | DesignerWorkWhereUniqueInput[]
    update?: DesignerWorkUpdateWithWhereUniqueWithoutDesignerInput | DesignerWorkUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerWorkUpdateManyWithWhereWithoutDesignerInput | DesignerWorkUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerWorkScalarWhereInput | DesignerWorkScalarWhereInput[]
  }

  export type DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput> | DesignerHireRequestCreateWithoutDesignerInput[] | DesignerHireRequestUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutDesignerInput | DesignerHireRequestCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerHireRequestUpsertWithWhereUniqueWithoutDesignerInput | DesignerHireRequestUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerHireRequestCreateManyDesignerInputEnvelope
    set?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    disconnect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    delete?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    connect?: DesignerHireRequestWhereUniqueInput | DesignerHireRequestWhereUniqueInput[]
    update?: DesignerHireRequestUpdateWithWhereUniqueWithoutDesignerInput | DesignerHireRequestUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerHireRequestUpdateManyWithWhereWithoutDesignerInput | DesignerHireRequestUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
  }

  export type DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput> | DesignerRatingCreateWithoutDesignerInput[] | DesignerRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutDesignerInput | DesignerRatingCreateOrConnectWithoutDesignerInput[]
    upsert?: DesignerRatingUpsertWithWhereUniqueWithoutDesignerInput | DesignerRatingUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: DesignerRatingCreateManyDesignerInputEnvelope
    set?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    disconnect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    delete?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    connect?: DesignerRatingWhereUniqueInput | DesignerRatingWhereUniqueInput[]
    update?: DesignerRatingUpdateWithWhereUniqueWithoutDesignerInput | DesignerRatingUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: DesignerRatingUpdateManyWithWhereWithoutDesignerInput | DesignerRatingUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: DesignerRatingScalarWhereInput | DesignerRatingScalarWhereInput[]
  }

  export type UserRatingUncheckedUpdateManyWithoutDesignerNestedInput = {
    create?: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput> | UserRatingCreateWithoutDesignerInput[] | UserRatingUncheckedCreateWithoutDesignerInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutDesignerInput | UserRatingCreateOrConnectWithoutDesignerInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutDesignerInput | UserRatingUpsertWithWhereUniqueWithoutDesignerInput[]
    createMany?: UserRatingCreateManyDesignerInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutDesignerInput | UserRatingUpdateWithWhereUniqueWithoutDesignerInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutDesignerInput | UserRatingUpdateManyWithWhereWithoutDesignerInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type DesignerCreateNestedOneWithoutProfileInput = {
    create?: XOR<DesignerCreateWithoutProfileInput, DesignerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutProfileInput
    connect?: DesignerWhereUniqueInput
  }

  export type DesignerUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<DesignerCreateWithoutProfileInput, DesignerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutProfileInput
    upsert?: DesignerUpsertWithoutProfileInput
    connect?: DesignerWhereUniqueInput
    update?: XOR<XOR<DesignerUpdateToOneWithWhereWithoutProfileInput, DesignerUpdateWithoutProfileInput>, DesignerUncheckedUpdateWithoutProfileInput>
  }

  export type DesignerCreateNestedOneWithoutWorksInput = {
    create?: XOR<DesignerCreateWithoutWorksInput, DesignerUncheckedCreateWithoutWorksInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutWorksInput
    connect?: DesignerWhereUniqueInput
  }

  export type DesignerUpdateOneRequiredWithoutWorksNestedInput = {
    create?: XOR<DesignerCreateWithoutWorksInput, DesignerUncheckedCreateWithoutWorksInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutWorksInput
    upsert?: DesignerUpsertWithoutWorksInput
    connect?: DesignerWhereUniqueInput
    update?: XOR<XOR<DesignerUpdateToOneWithWhereWithoutWorksInput, DesignerUpdateWithoutWorksInput>, DesignerUncheckedUpdateWithoutWorksInput>
  }

  export type UserCreateNestedOneWithoutHireRequestsInput = {
    create?: XOR<UserCreateWithoutHireRequestsInput, UserUncheckedCreateWithoutHireRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHireRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type DesignerCreateNestedOneWithoutHireRequestsInput = {
    create?: XOR<DesignerCreateWithoutHireRequestsInput, DesignerUncheckedCreateWithoutHireRequestsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutHireRequestsInput
    connect?: DesignerWhereUniqueInput
  }

  export type DesignerRatingCreateNestedOneWithoutHireRequestInput = {
    create?: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutHireRequestInput
    connect?: DesignerRatingWhereUniqueInput
  }

  export type UserRatingCreateNestedOneWithoutHireRequestInput = {
    create?: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: UserRatingCreateOrConnectWithoutHireRequestInput
    connect?: UserRatingWhereUniqueInput
  }

  export type DesignerRatingUncheckedCreateNestedOneWithoutHireRequestInput = {
    create?: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutHireRequestInput
    connect?: DesignerRatingWhereUniqueInput
  }

  export type UserRatingUncheckedCreateNestedOneWithoutHireRequestInput = {
    create?: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: UserRatingCreateOrConnectWithoutHireRequestInput
    connect?: UserRatingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHireRequestsNestedInput = {
    create?: XOR<UserCreateWithoutHireRequestsInput, UserUncheckedCreateWithoutHireRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHireRequestsInput
    upsert?: UserUpsertWithoutHireRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHireRequestsInput, UserUpdateWithoutHireRequestsInput>, UserUncheckedUpdateWithoutHireRequestsInput>
  }

  export type DesignerUpdateOneRequiredWithoutHireRequestsNestedInput = {
    create?: XOR<DesignerCreateWithoutHireRequestsInput, DesignerUncheckedCreateWithoutHireRequestsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutHireRequestsInput
    upsert?: DesignerUpsertWithoutHireRequestsInput
    connect?: DesignerWhereUniqueInput
    update?: XOR<XOR<DesignerUpdateToOneWithWhereWithoutHireRequestsInput, DesignerUpdateWithoutHireRequestsInput>, DesignerUncheckedUpdateWithoutHireRequestsInput>
  }

  export type DesignerRatingUpdateOneWithoutHireRequestNestedInput = {
    create?: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutHireRequestInput
    upsert?: DesignerRatingUpsertWithoutHireRequestInput
    disconnect?: DesignerRatingWhereInput | boolean
    delete?: DesignerRatingWhereInput | boolean
    connect?: DesignerRatingWhereUniqueInput
    update?: XOR<XOR<DesignerRatingUpdateToOneWithWhereWithoutHireRequestInput, DesignerRatingUpdateWithoutHireRequestInput>, DesignerRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type UserRatingUpdateOneWithoutHireRequestNestedInput = {
    create?: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: UserRatingCreateOrConnectWithoutHireRequestInput
    upsert?: UserRatingUpsertWithoutHireRequestInput
    disconnect?: UserRatingWhereInput | boolean
    delete?: UserRatingWhereInput | boolean
    connect?: UserRatingWhereUniqueInput
    update?: XOR<XOR<UserRatingUpdateToOneWithWhereWithoutHireRequestInput, UserRatingUpdateWithoutHireRequestInput>, UserRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type DesignerRatingUncheckedUpdateOneWithoutHireRequestNestedInput = {
    create?: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: DesignerRatingCreateOrConnectWithoutHireRequestInput
    upsert?: DesignerRatingUpsertWithoutHireRequestInput
    disconnect?: DesignerRatingWhereInput | boolean
    delete?: DesignerRatingWhereInput | boolean
    connect?: DesignerRatingWhereUniqueInput
    update?: XOR<XOR<DesignerRatingUpdateToOneWithWhereWithoutHireRequestInput, DesignerRatingUpdateWithoutHireRequestInput>, DesignerRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type UserRatingUncheckedUpdateOneWithoutHireRequestNestedInput = {
    create?: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
    connectOrCreate?: UserRatingCreateOrConnectWithoutHireRequestInput
    upsert?: UserRatingUpsertWithoutHireRequestInput
    disconnect?: UserRatingWhereInput | boolean
    delete?: UserRatingWhereInput | boolean
    connect?: UserRatingWhereUniqueInput
    update?: XOR<XOR<UserRatingUpdateToOneWithWhereWithoutHireRequestInput, UserRatingUpdateWithoutHireRequestInput>, UserRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type DesignerCreateNestedOneWithoutRatingsInput = {
    create?: XOR<DesignerCreateWithoutRatingsInput, DesignerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutRatingsInput
    connect?: DesignerWhereUniqueInput
  }

  export type DesignerHireRequestCreateNestedOneWithoutRatingInput = {
    create?: XOR<DesignerHireRequestCreateWithoutRatingInput, DesignerHireRequestUncheckedCreateWithoutRatingInput>
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutRatingInput
    connect?: DesignerHireRequestWhereUniqueInput
  }

  export type DesignerUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<DesignerCreateWithoutRatingsInput, DesignerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutRatingsInput
    upsert?: DesignerUpsertWithoutRatingsInput
    connect?: DesignerWhereUniqueInput
    update?: XOR<XOR<DesignerUpdateToOneWithWhereWithoutRatingsInput, DesignerUpdateWithoutRatingsInput>, DesignerUncheckedUpdateWithoutRatingsInput>
  }

  export type DesignerHireRequestUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutRatingInput, DesignerHireRequestUncheckedCreateWithoutRatingInput>
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutRatingInput
    upsert?: DesignerHireRequestUpsertWithoutRatingInput
    connect?: DesignerHireRequestWhereUniqueInput
    update?: XOR<XOR<DesignerHireRequestUpdateToOneWithWhereWithoutRatingInput, DesignerHireRequestUpdateWithoutRatingInput>, DesignerHireRequestUncheckedUpdateWithoutRatingInput>
  }

  export type DesignerHireRequestCreateNestedOneWithoutUserRatingInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserRatingInput, DesignerHireRequestUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserRatingInput
    connect?: DesignerHireRequestWhereUniqueInput
  }

  export type DesignerCreateNestedOneWithoutUserRatingsInput = {
    create?: XOR<DesignerCreateWithoutUserRatingsInput, DesignerUncheckedCreateWithoutUserRatingsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutUserRatingsInput
    connect?: DesignerWhereUniqueInput
  }

  export type DesignerHireRequestUpdateOneRequiredWithoutUserRatingNestedInput = {
    create?: XOR<DesignerHireRequestCreateWithoutUserRatingInput, DesignerHireRequestUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: DesignerHireRequestCreateOrConnectWithoutUserRatingInput
    upsert?: DesignerHireRequestUpsertWithoutUserRatingInput
    connect?: DesignerHireRequestWhereUniqueInput
    update?: XOR<XOR<DesignerHireRequestUpdateToOneWithWhereWithoutUserRatingInput, DesignerHireRequestUpdateWithoutUserRatingInput>, DesignerHireRequestUncheckedUpdateWithoutUserRatingInput>
  }

  export type DesignerUpdateOneWithoutUserRatingsNestedInput = {
    create?: XOR<DesignerCreateWithoutUserRatingsInput, DesignerUncheckedCreateWithoutUserRatingsInput>
    connectOrCreate?: DesignerCreateOrConnectWithoutUserRatingsInput
    upsert?: DesignerUpsertWithoutUserRatingsInput
    disconnect?: DesignerWhereInput | boolean
    delete?: DesignerWhereInput | boolean
    connect?: DesignerWhereUniqueInput
    update?: XOR<XOR<DesignerUpdateToOneWithWhereWithoutUserRatingsInput, DesignerUpdateWithoutUserRatingsInput>, DesignerUncheckedUpdateWithoutUserRatingsInput>
  }

  export type ReturnRequestCreateimagesInput = {
    set: string[]
  }

  export type OrderItemCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput
    connect?: OrderItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReturnRequestsInput = {
    create?: XOR<UserCreateWithoutReturnRequestsInput, UserUncheckedCreateWithoutReturnRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type ReturnRequestUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type NullableEnumRefundMethodFieldUpdateOperationsInput = {
    set?: $Enums.RefundMethod | null
  }

  export type OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput
    upsert?: OrderItemUpsertWithoutReturnRequestInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutReturnRequestInput, OrderItemUpdateWithoutReturnRequestInput>, OrderItemUncheckedUpdateWithoutReturnRequestInput>
  }

  export type UserUpdateOneRequiredWithoutReturnRequestsNestedInput = {
    create?: XOR<UserCreateWithoutReturnRequestsInput, UserUncheckedCreateWithoutReturnRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReturnRequestsInput
    upsert?: UserUpsertWithoutReturnRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReturnRequestsInput, UserUpdateWithoutReturnRequestsInput>, UserUncheckedUpdateWithoutReturnRequestsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type OrderCreateWithoutUserInput = {
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutUserInput = {
    stars: number
    comment?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutRatingsInput
    orderItem: OrderItemCreateNestedOneWithoutRatingInput
  }

  export type RatingUncheckedCreateWithoutUserInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    productId: number
    orderItemId: number
  }

  export type RatingCreateOrConnectWithoutUserInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingCreateManyUserInputEnvelope = {
    data: RatingCreateManyUserInput | RatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DesignerHireRequestCreateWithoutUserInput = {
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    designer: DesignerCreateNestedOneWithoutHireRequestsInput
    rating?: DesignerRatingCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUncheckedCreateWithoutUserInput = {
    id?: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    rating?: DesignerRatingUncheckedCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingUncheckedCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestCreateOrConnectWithoutUserInput = {
    where: DesignerHireRequestWhereUniqueInput
    create: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput>
  }

  export type DesignerHireRequestCreateManyUserInputEnvelope = {
    data: DesignerHireRequestCreateManyUserInput | DesignerHireRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReturnRequestCreateWithoutUserInput = {
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReturnRequestInput
  }

  export type ReturnRequestUncheckedCreateWithoutUserInput = {
    id?: number
    orderItemId: number
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnRequestCreateOrConnectWithoutUserInput = {
    where: ReturnRequestWhereUniqueInput
    create: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput>
  }

  export type ReturnRequestCreateManyUserInputEnvelope = {
    data: ReturnRequestCreateManyUserInput | ReturnRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntFilter<"Order"> | number
    customerEmail?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    paymentMethod?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    casaCharge?: FloatFilter<"Order"> | number
    deliveryCharge?: FloatFilter<"Order"> | number
    grandTotal?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
  }

  export type RatingUpdateManyWithWhereWithoutUserInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutUserInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: IntFilter<"Rating"> | number
    stars?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    userId?: IntFilter<"Rating"> | number
    productId?: IntFilter<"Rating"> | number
    orderItemId?: IntFilter<"Rating"> | number
  }

  export type DesignerHireRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DesignerHireRequestWhereUniqueInput
    update: XOR<DesignerHireRequestUpdateWithoutUserInput, DesignerHireRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DesignerHireRequestCreateWithoutUserInput, DesignerHireRequestUncheckedCreateWithoutUserInput>
  }

  export type DesignerHireRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DesignerHireRequestWhereUniqueInput
    data: XOR<DesignerHireRequestUpdateWithoutUserInput, DesignerHireRequestUncheckedUpdateWithoutUserInput>
  }

  export type DesignerHireRequestUpdateManyWithWhereWithoutUserInput = {
    where: DesignerHireRequestScalarWhereInput
    data: XOR<DesignerHireRequestUpdateManyMutationInput, DesignerHireRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DesignerHireRequestScalarWhereInput = {
    AND?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
    OR?: DesignerHireRequestScalarWhereInput[]
    NOT?: DesignerHireRequestScalarWhereInput | DesignerHireRequestScalarWhereInput[]
    id?: IntFilter<"DesignerHireRequest"> | number
    userId?: IntFilter<"DesignerHireRequest"> | number
    designerId?: IntFilter<"DesignerHireRequest"> | number
    fullName?: StringFilter<"DesignerHireRequest"> | string
    email?: StringFilter<"DesignerHireRequest"> | string
    mobile?: StringFilter<"DesignerHireRequest"> | string
    location?: StringFilter<"DesignerHireRequest"> | string
    budget?: IntFilter<"DesignerHireRequest"> | number
    workType?: StringFilter<"DesignerHireRequest"> | string
    timelineDate?: DateTimeNullableFilter<"DesignerHireRequest"> | Date | string | null
    description?: StringNullableFilter<"DesignerHireRequest"> | string | null
    status?: StringFilter<"DesignerHireRequest"> | string
    createdAt?: DateTimeFilter<"DesignerHireRequest"> | Date | string
  }

  export type ReturnRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ReturnRequestWhereUniqueInput
    update: XOR<ReturnRequestUpdateWithoutUserInput, ReturnRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ReturnRequestCreateWithoutUserInput, ReturnRequestUncheckedCreateWithoutUserInput>
  }

  export type ReturnRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ReturnRequestWhereUniqueInput
    data: XOR<ReturnRequestUpdateWithoutUserInput, ReturnRequestUncheckedUpdateWithoutUserInput>
  }

  export type ReturnRequestUpdateManyWithWhereWithoutUserInput = {
    where: ReturnRequestScalarWhereInput
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ReturnRequestScalarWhereInput = {
    AND?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
    OR?: ReturnRequestScalarWhereInput[]
    NOT?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
    id?: IntFilter<"ReturnRequest"> | number
    orderItemId?: IntFilter<"ReturnRequest"> | number
    userId?: IntFilter<"ReturnRequest"> | number
    productName?: StringFilter<"ReturnRequest"> | string
    sellerId?: IntFilter<"ReturnRequest"> | number
    sellerName?: StringNullableFilter<"ReturnRequest"> | string | null
    reason?: StringFilter<"ReturnRequest"> | string
    note?: StringNullableFilter<"ReturnRequest"> | string | null
    images?: StringNullableListFilter<"ReturnRequest">
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFilter<"ReturnRequest"> | $Enums.ApprovalStatus
    sellerApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    adminApprovedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    sellerDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    adminDecisionNote?: StringNullableFilter<"ReturnRequest"> | string | null
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnRequest"> | $Enums.RefundMethod | null
    refundAmount?: FloatNullableFilter<"ReturnRequest"> | number | null
    refundStatus?: EnumRefundStatusFilter<"ReturnRequest"> | $Enums.RefundStatus
    refundDetails?: StringNullableFilter<"ReturnRequest"> | string | null
    createdAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
  }

  export type OrderItemCreateWithoutSellerInput = {
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    rating?: RatingCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutSellerInput = {
    id?: number
    orderId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    rating?: RatingUncheckedCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutSellerInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput>
  }

  export type OrderItemCreateManySellerInputEnvelope = {
    data: OrderItemCreateManySellerInput | OrderItemCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSellerInput = {
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    createdAt?: Date | string
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSellerInput = {
    id?: number
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    createdAt?: Date | string
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSellerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductCreateManySellerInputEnvelope = {
    data: ProductCreateManySellerInput | ProductCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type SellerBusinessDetailsCreateWithoutSellerInput = {
    businessName: string
    sellerType: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    gst?: string | null
    createdAt?: Date | string
  }

  export type SellerBusinessDetailsUncheckedCreateWithoutSellerInput = {
    id?: number
    businessName: string
    sellerType: string
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    gst?: string | null
    createdAt?: Date | string
  }

  export type SellerBusinessDetailsCreateOrConnectWithoutSellerInput = {
    where: SellerBusinessDetailsWhereUniqueInput
    create: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
  }

  export type SellerDeliveryDetailsCreateWithoutSellerInput = {
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType: string
    shippingCharge?: number | null
    internationalDelivery?: boolean
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type SellerDeliveryDetailsUncheckedCreateWithoutSellerInput = {
    id?: number
    deliveryResponsibility: string
    deliveryCoverage: string
    deliveryType: string
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType: string
    shippingCharge?: number | null
    internationalDelivery?: boolean
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type SellerDeliveryDetailsCreateOrConnectWithoutSellerInput = {
    where: SellerDeliveryDetailsWhereUniqueInput
    create: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
  }

  export type SellerBankDetailsCreateWithoutSellerInput = {
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    createdAt?: Date | string
  }

  export type SellerBankDetailsUncheckedCreateWithoutSellerInput = {
    id?: number
    accountHolder: string
    bankName: string
    accountNumber: string
    ifsc: string
    createdAt?: Date | string
  }

  export type SellerBankDetailsCreateOrConnectWithoutSellerInput = {
    where: SellerBankDetailsWhereUniqueInput
    create: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutSellerInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutSellerInput, OrderItemUncheckedUpdateWithoutSellerInput>
    create: XOR<OrderItemCreateWithoutSellerInput, OrderItemUncheckedCreateWithoutSellerInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutSellerInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutSellerInput, OrderItemUncheckedUpdateWithoutSellerInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutSellerInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutSellerInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    sellerId?: IntFilter<"OrderItem"> | number
    materialId?: IntFilter<"OrderItem"> | number
    materialName?: StringFilter<"OrderItem"> | string
    supplierName?: StringFilter<"OrderItem"> | string
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    pricePerUnit?: FloatFilter<"OrderItem"> | number
    totalAmount?: FloatFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    returnStatus?: EnumReturnStatusFilter<"OrderItem"> | $Enums.ReturnStatus
    returnReason?: StringNullableFilter<"OrderItem"> | string | null
    returnRequestedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    returnResolvedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    refundAmount?: FloatNullableFilter<"OrderItem"> | number | null
    refundStatus?: EnumRefundStatusFilter<"OrderItem"> | $Enums.RefundStatus
    refundProcessedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveryTimeMin?: IntNullableFilter<"OrderItem"> | number | null
    deliveryTimeMax?: IntNullableFilter<"OrderItem"> | number | null
    shippingChargeType?: StringNullableFilter<"OrderItem"> | string | null
    shippingCharge?: IntNullableFilter<"OrderItem"> | number | null
    installationAvailable?: StringNullableFilter<"OrderItem"> | string | null
    installationCharge?: IntNullableFilter<"OrderItem"> | number | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
  }

  export type ProductUpdateManyWithWhereWithoutSellerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSellerInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    productType?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    video?: StringNullableFilter<"Product"> | string | null
    availability?: StringFilter<"Product"> | string
    sellerId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SellerBusinessDetailsUpsertWithoutSellerInput = {
    update: XOR<SellerBusinessDetailsUpdateWithoutSellerInput, SellerBusinessDetailsUncheckedUpdateWithoutSellerInput>
    create: XOR<SellerBusinessDetailsCreateWithoutSellerInput, SellerBusinessDetailsUncheckedCreateWithoutSellerInput>
    where?: SellerBusinessDetailsWhereInput
  }

  export type SellerBusinessDetailsUpdateToOneWithWhereWithoutSellerInput = {
    where?: SellerBusinessDetailsWhereInput
    data: XOR<SellerBusinessDetailsUpdateWithoutSellerInput, SellerBusinessDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerBusinessDetailsUpdateWithoutSellerInput = {
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBusinessDetailsUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessName?: StringFieldUpdateOperationsInput | string
    sellerType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerDeliveryDetailsUpsertWithoutSellerInput = {
    update: XOR<SellerDeliveryDetailsUpdateWithoutSellerInput, SellerDeliveryDetailsUncheckedUpdateWithoutSellerInput>
    create: XOR<SellerDeliveryDetailsCreateWithoutSellerInput, SellerDeliveryDetailsUncheckedCreateWithoutSellerInput>
    where?: SellerDeliveryDetailsWhereInput
  }

  export type SellerDeliveryDetailsUpdateToOneWithWhereWithoutSellerInput = {
    where?: SellerDeliveryDetailsWhereInput
    data: XOR<SellerDeliveryDetailsUpdateWithoutSellerInput, SellerDeliveryDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerDeliveryDetailsUpdateWithoutSellerInput = {
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerDeliveryDetailsUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryResponsibility?: StringFieldUpdateOperationsInput | string
    deliveryCoverage?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: StringFieldUpdateOperationsInput | string
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    internationalDelivery?: BoolFieldUpdateOperationsInput | boolean
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBankDetailsUpsertWithoutSellerInput = {
    update: XOR<SellerBankDetailsUpdateWithoutSellerInput, SellerBankDetailsUncheckedUpdateWithoutSellerInput>
    create: XOR<SellerBankDetailsCreateWithoutSellerInput, SellerBankDetailsUncheckedCreateWithoutSellerInput>
    where?: SellerBankDetailsWhereInput
  }

  export type SellerBankDetailsUpdateToOneWithWhereWithoutSellerInput = {
    where?: SellerBankDetailsWhereInput
    data: XOR<SellerBankDetailsUpdateWithoutSellerInput, SellerBankDetailsUncheckedUpdateWithoutSellerInput>
  }

  export type SellerBankDetailsUpdateWithoutSellerInput = {
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerBankDetailsUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountHolder?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    ifsc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerCreateWithoutBusinessInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutSellerInput
    products?: ProductCreateNestedManyWithoutSellerInput
    delivery?: SellerDeliveryDetailsCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutBusinessInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutSellerInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    delivery?: SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutBusinessInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutBusinessInput, SellerUncheckedCreateWithoutBusinessInput>
  }

  export type SellerUpsertWithoutBusinessInput = {
    update: XOR<SellerUpdateWithoutBusinessInput, SellerUncheckedUpdateWithoutBusinessInput>
    create: XOR<SellerCreateWithoutBusinessInput, SellerUncheckedCreateWithoutBusinessInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutBusinessInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutBusinessInput, SellerUncheckedUpdateWithoutBusinessInput>
  }

  export type SellerUpdateWithoutBusinessInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutSellerNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateWithoutBusinessInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutSellerNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type SellerCreateWithoutDeliveryInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutSellerInput
    products?: ProductCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutDeliveryInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutSellerInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutDeliveryInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutDeliveryInput, SellerUncheckedCreateWithoutDeliveryInput>
  }

  export type SellerUpsertWithoutDeliveryInput = {
    update: XOR<SellerUpdateWithoutDeliveryInput, SellerUncheckedUpdateWithoutDeliveryInput>
    create: XOR<SellerCreateWithoutDeliveryInput, SellerUncheckedCreateWithoutDeliveryInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutDeliveryInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutDeliveryInput, SellerUncheckedUpdateWithoutDeliveryInput>
  }

  export type SellerUpdateWithoutDeliveryInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutSellerNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutSellerNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type SellerCreateWithoutBankInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutSellerInput
    products?: ProductCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutBankInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutSellerInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutBankInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutBankInput, SellerUncheckedCreateWithoutBankInput>
  }

  export type SellerUpsertWithoutBankInput = {
    update: XOR<SellerUpdateWithoutBankInput, SellerUncheckedUpdateWithoutBankInput>
    create: XOR<SellerCreateWithoutBankInput, SellerUncheckedCreateWithoutBankInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutBankInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutBankInput, SellerUncheckedUpdateWithoutBankInput>
  }

  export type SellerUpdateWithoutBankInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutSellerNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateWithoutBankInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutSellerNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type SellerCreateWithoutProductsInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutProductsInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutProductsInput, SellerUncheckedCreateWithoutProductsInput>
  }

  export type RatingCreateWithoutProductInput = {
    stars: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
    orderItem: OrderItemCreateNestedOneWithoutRatingInput
  }

  export type RatingUncheckedCreateWithoutProductInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    userId: number
    orderItemId: number
  }

  export type RatingCreateOrConnectWithoutProductInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput>
  }

  export type RatingCreateManyProductInputEnvelope = {
    data: RatingCreateManyProductInput | RatingCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SellerUpsertWithoutProductsInput = {
    update: XOR<SellerUpdateWithoutProductsInput, SellerUncheckedUpdateWithoutProductsInput>
    create: XOR<SellerCreateWithoutProductsInput, SellerUncheckedCreateWithoutProductsInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutProductsInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutProductsInput, SellerUncheckedUpdateWithoutProductsInput>
  }

  export type SellerUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type RatingUpsertWithWhereUniqueWithoutProductInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutProductInput, RatingUncheckedUpdateWithoutProductInput>
    create: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutProductInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutProductInput, RatingUncheckedUpdateWithoutProductInput>
  }

  export type RatingUpdateManyWithWhereWithoutProductInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutOrdersInput = {
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    ratings?: RatingCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutOrderItemsInput
    rating?: RatingCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    rating?: RatingUncheckedCreateNestedOneWithoutOrderItemInput
    returnRequest?: ReturnRequestUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    ratings?: RatingUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    userId: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type SellerCreateWithoutOrderItemsInput = {
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsCreateNestedOneWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    email: string
    phone: string
    password: string
    phoneVerified?: boolean
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    business?: SellerBusinessDetailsUncheckedCreateNestedOneWithoutSellerInput
    delivery?: SellerDeliveryDetailsUncheckedCreateNestedOneWithoutSellerInput
    bank?: SellerBankDetailsUncheckedCreateNestedOneWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutOrderItemsInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutOrderItemsInput, SellerUncheckedCreateWithoutOrderItemsInput>
  }

  export type RatingCreateWithoutOrderItemInput = {
    stars: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
    product: ProductCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutOrderItemInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    userId: number
    productId: number
  }

  export type RatingCreateOrConnectWithoutOrderItemInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
  }

  export type ReturnRequestCreateWithoutOrderItemInput = {
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReturnRequestsInput
  }

  export type ReturnRequestUncheckedCreateWithoutOrderItemInput = {
    id?: number
    userId: number
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnRequestCreateOrConnectWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerUpsertWithoutOrderItemsInput = {
    update: XOR<SellerUpdateWithoutOrderItemsInput, SellerUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<SellerCreateWithoutOrderItemsInput, SellerUncheckedCreateWithoutOrderItemsInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutOrderItemsInput, SellerUncheckedUpdateWithoutOrderItemsInput>
  }

  export type SellerUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUpdateOneWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    business?: SellerBusinessDetailsUncheckedUpdateOneWithoutSellerNestedInput
    delivery?: SellerDeliveryDetailsUncheckedUpdateOneWithoutSellerNestedInput
    bank?: SellerBankDetailsUncheckedUpdateOneWithoutSellerNestedInput
  }

  export type RatingUpsertWithoutOrderItemInput = {
    update: XOR<RatingUpdateWithoutOrderItemInput, RatingUncheckedUpdateWithoutOrderItemInput>
    create: XOR<RatingCreateWithoutOrderItemInput, RatingUncheckedCreateWithoutOrderItemInput>
    where?: RatingWhereInput
  }

  export type RatingUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: RatingWhereInput
    data: XOR<RatingUpdateWithoutOrderItemInput, RatingUncheckedUpdateWithoutOrderItemInput>
  }

  export type RatingUpdateWithoutOrderItemInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
    product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ReturnRequestUpsertWithoutOrderItemInput = {
    update: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
    where?: ReturnRequestWhereInput
  }

  export type ReturnRequestUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ReturnRequestWhereInput
    data: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReturnRequestUpdateWithoutOrderItemInput = {
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReturnRequestsNestedInput
  }

  export type ReturnRequestUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRatingsInput = {
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type ProductCreateWithoutRatingsInput = {
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    createdAt?: Date | string
    seller: SellerCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutRatingsInput = {
    id?: number
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    sellerId: number
    createdAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutRatingsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
  }

  export type OrderItemCreateWithoutRatingInput = {
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    seller: SellerCreateNestedOneWithoutOrderItemsInput
    returnRequest?: ReturnRequestCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutRatingInput = {
    id?: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    returnRequest?: ReturnRequestUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutRatingInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutRatingInput, OrderItemUncheckedCreateWithoutRatingInput>
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutRatingsInput = {
    update: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateWithoutRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithoutRatingInput = {
    update: XOR<OrderItemUpdateWithoutRatingInput, OrderItemUncheckedUpdateWithoutRatingInput>
    create: XOR<OrderItemCreateWithoutRatingInput, OrderItemUncheckedCreateWithoutRatingInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutRatingInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutRatingInput, OrderItemUncheckedUpdateWithoutRatingInput>
  }

  export type OrderItemUpdateWithoutRatingInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    seller?: SellerUpdateOneRequiredWithoutOrderItemsNestedInput
    returnRequest?: ReturnRequestUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnRequest?: ReturnRequestUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type DesignerProfileCreateWithoutDesignerInput = {
    experience?: string | null
    portfolio?: string | null
    designerType?: string | null
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignerProfileUncheckedCreateWithoutDesignerInput = {
    id?: number
    experience?: string | null
    portfolio?: string | null
    designerType?: string | null
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignerProfileCreateOrConnectWithoutDesignerInput = {
    where: DesignerProfileWhereUniqueInput
    create: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerWorkCreateWithoutDesignerInput = {
    image: string
    description?: string | null
    createdAt?: Date | string
  }

  export type DesignerWorkUncheckedCreateWithoutDesignerInput = {
    id?: number
    image: string
    description?: string | null
    createdAt?: Date | string
  }

  export type DesignerWorkCreateOrConnectWithoutDesignerInput = {
    where: DesignerWorkWhereUniqueInput
    create: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerWorkCreateManyDesignerInputEnvelope = {
    data: DesignerWorkCreateManyDesignerInput | DesignerWorkCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type DesignerHireRequestCreateWithoutDesignerInput = {
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHireRequestsInput
    rating?: DesignerRatingCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUncheckedCreateWithoutDesignerInput = {
    id?: number
    userId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    rating?: DesignerRatingUncheckedCreateNestedOneWithoutHireRequestInput
    userRating?: UserRatingUncheckedCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestCreateOrConnectWithoutDesignerInput = {
    where: DesignerHireRequestWhereUniqueInput
    create: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerHireRequestCreateManyDesignerInputEnvelope = {
    data: DesignerHireRequestCreateManyDesignerInput | DesignerHireRequestCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type DesignerRatingCreateWithoutDesignerInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    hireRequest: DesignerHireRequestCreateNestedOneWithoutRatingInput
  }

  export type DesignerRatingUncheckedCreateWithoutDesignerInput = {
    id?: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type DesignerRatingCreateOrConnectWithoutDesignerInput = {
    where: DesignerRatingWhereUniqueInput
    create: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerRatingCreateManyDesignerInputEnvelope = {
    data: DesignerRatingCreateManyDesignerInput | DesignerRatingCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type UserRatingCreateWithoutDesignerInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    hireRequest: DesignerHireRequestCreateNestedOneWithoutUserRatingInput
  }

  export type UserRatingUncheckedCreateWithoutDesignerInput = {
    id?: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type UserRatingCreateOrConnectWithoutDesignerInput = {
    where: UserRatingWhereUniqueInput
    create: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput>
  }

  export type UserRatingCreateManyDesignerInputEnvelope = {
    data: UserRatingCreateManyDesignerInput | UserRatingCreateManyDesignerInput[]
    skipDuplicates?: boolean
  }

  export type DesignerProfileUpsertWithoutDesignerInput = {
    update: XOR<DesignerProfileUpdateWithoutDesignerInput, DesignerProfileUncheckedUpdateWithoutDesignerInput>
    create: XOR<DesignerProfileCreateWithoutDesignerInput, DesignerProfileUncheckedCreateWithoutDesignerInput>
    where?: DesignerProfileWhereInput
  }

  export type DesignerProfileUpdateToOneWithWhereWithoutDesignerInput = {
    where?: DesignerProfileWhereInput
    data: XOR<DesignerProfileUpdateWithoutDesignerInput, DesignerProfileUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerProfileUpdateWithoutDesignerInput = {
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerProfileUncheckedUpdateWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    designerType?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkUpsertWithWhereUniqueWithoutDesignerInput = {
    where: DesignerWorkWhereUniqueInput
    update: XOR<DesignerWorkUpdateWithoutDesignerInput, DesignerWorkUncheckedUpdateWithoutDesignerInput>
    create: XOR<DesignerWorkCreateWithoutDesignerInput, DesignerWorkUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerWorkUpdateWithWhereUniqueWithoutDesignerInput = {
    where: DesignerWorkWhereUniqueInput
    data: XOR<DesignerWorkUpdateWithoutDesignerInput, DesignerWorkUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerWorkUpdateManyWithWhereWithoutDesignerInput = {
    where: DesignerWorkScalarWhereInput
    data: XOR<DesignerWorkUpdateManyMutationInput, DesignerWorkUncheckedUpdateManyWithoutDesignerInput>
  }

  export type DesignerWorkScalarWhereInput = {
    AND?: DesignerWorkScalarWhereInput | DesignerWorkScalarWhereInput[]
    OR?: DesignerWorkScalarWhereInput[]
    NOT?: DesignerWorkScalarWhereInput | DesignerWorkScalarWhereInput[]
    id?: IntFilter<"DesignerWork"> | number
    designerId?: IntFilter<"DesignerWork"> | number
    image?: StringFilter<"DesignerWork"> | string
    description?: StringNullableFilter<"DesignerWork"> | string | null
    createdAt?: DateTimeFilter<"DesignerWork"> | Date | string
  }

  export type DesignerHireRequestUpsertWithWhereUniqueWithoutDesignerInput = {
    where: DesignerHireRequestWhereUniqueInput
    update: XOR<DesignerHireRequestUpdateWithoutDesignerInput, DesignerHireRequestUncheckedUpdateWithoutDesignerInput>
    create: XOR<DesignerHireRequestCreateWithoutDesignerInput, DesignerHireRequestUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerHireRequestUpdateWithWhereUniqueWithoutDesignerInput = {
    where: DesignerHireRequestWhereUniqueInput
    data: XOR<DesignerHireRequestUpdateWithoutDesignerInput, DesignerHireRequestUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerHireRequestUpdateManyWithWhereWithoutDesignerInput = {
    where: DesignerHireRequestScalarWhereInput
    data: XOR<DesignerHireRequestUpdateManyMutationInput, DesignerHireRequestUncheckedUpdateManyWithoutDesignerInput>
  }

  export type DesignerRatingUpsertWithWhereUniqueWithoutDesignerInput = {
    where: DesignerRatingWhereUniqueInput
    update: XOR<DesignerRatingUpdateWithoutDesignerInput, DesignerRatingUncheckedUpdateWithoutDesignerInput>
    create: XOR<DesignerRatingCreateWithoutDesignerInput, DesignerRatingUncheckedCreateWithoutDesignerInput>
  }

  export type DesignerRatingUpdateWithWhereUniqueWithoutDesignerInput = {
    where: DesignerRatingWhereUniqueInput
    data: XOR<DesignerRatingUpdateWithoutDesignerInput, DesignerRatingUncheckedUpdateWithoutDesignerInput>
  }

  export type DesignerRatingUpdateManyWithWhereWithoutDesignerInput = {
    where: DesignerRatingScalarWhereInput
    data: XOR<DesignerRatingUpdateManyMutationInput, DesignerRatingUncheckedUpdateManyWithoutDesignerInput>
  }

  export type DesignerRatingScalarWhereInput = {
    AND?: DesignerRatingScalarWhereInput | DesignerRatingScalarWhereInput[]
    OR?: DesignerRatingScalarWhereInput[]
    NOT?: DesignerRatingScalarWhereInput | DesignerRatingScalarWhereInput[]
    id?: IntFilter<"DesignerRating"> | number
    designerId?: IntFilter<"DesignerRating"> | number
    hireRequestId?: IntFilter<"DesignerRating"> | number
    reviewerName?: StringNullableFilter<"DesignerRating"> | string | null
    stars?: IntFilter<"DesignerRating"> | number
    review?: StringNullableFilter<"DesignerRating"> | string | null
    createdAt?: DateTimeFilter<"DesignerRating"> | Date | string
  }

  export type UserRatingUpsertWithWhereUniqueWithoutDesignerInput = {
    where: UserRatingWhereUniqueInput
    update: XOR<UserRatingUpdateWithoutDesignerInput, UserRatingUncheckedUpdateWithoutDesignerInput>
    create: XOR<UserRatingCreateWithoutDesignerInput, UserRatingUncheckedCreateWithoutDesignerInput>
  }

  export type UserRatingUpdateWithWhereUniqueWithoutDesignerInput = {
    where: UserRatingWhereUniqueInput
    data: XOR<UserRatingUpdateWithoutDesignerInput, UserRatingUncheckedUpdateWithoutDesignerInput>
  }

  export type UserRatingUpdateManyWithWhereWithoutDesignerInput = {
    where: UserRatingScalarWhereInput
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyWithoutDesignerInput>
  }

  export type UserRatingScalarWhereInput = {
    AND?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
    OR?: UserRatingScalarWhereInput[]
    NOT?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
    id?: IntFilter<"UserRating"> | number
    hireRequestId?: IntFilter<"UserRating"> | number
    designerId?: IntNullableFilter<"UserRating"> | number | null
    reviewerName?: StringNullableFilter<"UserRating"> | string | null
    stars?: IntFilter<"UserRating"> | number
    review?: StringNullableFilter<"UserRating"> | string | null
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
  }

  export type DesignerCreateWithoutProfileInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: DesignerWorkCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateWithoutProfileInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    works?: DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerCreateOrConnectWithoutProfileInput = {
    where: DesignerWhereUniqueInput
    create: XOR<DesignerCreateWithoutProfileInput, DesignerUncheckedCreateWithoutProfileInput>
  }

  export type DesignerUpsertWithoutProfileInput = {
    update: XOR<DesignerUpdateWithoutProfileInput, DesignerUncheckedUpdateWithoutProfileInput>
    create: XOR<DesignerCreateWithoutProfileInput, DesignerUncheckedCreateWithoutProfileInput>
    where?: DesignerWhereInput
  }

  export type DesignerUpdateToOneWithWhereWithoutProfileInput = {
    where?: DesignerWhereInput
    data: XOR<DesignerUpdateWithoutProfileInput, DesignerUncheckedUpdateWithoutProfileInput>
  }

  export type DesignerUpdateWithoutProfileInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: DesignerWorkUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    works?: DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerCreateWithoutWorksInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileCreateNestedOneWithoutDesignerInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateWithoutWorksInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerCreateOrConnectWithoutWorksInput = {
    where: DesignerWhereUniqueInput
    create: XOR<DesignerCreateWithoutWorksInput, DesignerUncheckedCreateWithoutWorksInput>
  }

  export type DesignerUpsertWithoutWorksInput = {
    update: XOR<DesignerUpdateWithoutWorksInput, DesignerUncheckedUpdateWithoutWorksInput>
    create: XOR<DesignerCreateWithoutWorksInput, DesignerUncheckedCreateWithoutWorksInput>
    where?: DesignerWhereInput
  }

  export type DesignerUpdateToOneWithWhereWithoutWorksInput = {
    where?: DesignerWhereInput
    data: XOR<DesignerUpdateWithoutWorksInput, DesignerUncheckedUpdateWithoutWorksInput>
  }

  export type DesignerUpdateWithoutWorksInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUpdateOneWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateWithoutWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type UserCreateWithoutHireRequestsInput = {
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHireRequestsInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    returnRequests?: ReturnRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHireRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHireRequestsInput, UserUncheckedCreateWithoutHireRequestsInput>
  }

  export type DesignerCreateWithoutHireRequestsInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateWithoutHireRequestsInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerCreateOrConnectWithoutHireRequestsInput = {
    where: DesignerWhereUniqueInput
    create: XOR<DesignerCreateWithoutHireRequestsInput, DesignerUncheckedCreateWithoutHireRequestsInput>
  }

  export type DesignerRatingCreateWithoutHireRequestInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    designer: DesignerCreateNestedOneWithoutRatingsInput
  }

  export type DesignerRatingUncheckedCreateWithoutHireRequestInput = {
    id?: number
    designerId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type DesignerRatingCreateOrConnectWithoutHireRequestInput = {
    where: DesignerRatingWhereUniqueInput
    create: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
  }

  export type UserRatingCreateWithoutHireRequestInput = {
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
    designer?: DesignerCreateNestedOneWithoutUserRatingsInput
  }

  export type UserRatingUncheckedCreateWithoutHireRequestInput = {
    id?: number
    designerId?: number | null
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type UserRatingCreateOrConnectWithoutHireRequestInput = {
    where: UserRatingWhereUniqueInput
    create: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
  }

  export type UserUpsertWithoutHireRequestsInput = {
    update: XOR<UserUpdateWithoutHireRequestsInput, UserUncheckedUpdateWithoutHireRequestsInput>
    create: XOR<UserCreateWithoutHireRequestsInput, UserUncheckedCreateWithoutHireRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHireRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHireRequestsInput, UserUncheckedUpdateWithoutHireRequestsInput>
  }

  export type UserUpdateWithoutHireRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHireRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    returnRequests?: ReturnRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DesignerUpsertWithoutHireRequestsInput = {
    update: XOR<DesignerUpdateWithoutHireRequestsInput, DesignerUncheckedUpdateWithoutHireRequestsInput>
    create: XOR<DesignerCreateWithoutHireRequestsInput, DesignerUncheckedCreateWithoutHireRequestsInput>
    where?: DesignerWhereInput
  }

  export type DesignerUpdateToOneWithWhereWithoutHireRequestsInput = {
    where?: DesignerWhereInput
    data: XOR<DesignerUpdateWithoutHireRequestsInput, DesignerUncheckedUpdateWithoutHireRequestsInput>
  }

  export type DesignerUpdateWithoutHireRequestsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateWithoutHireRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerRatingUpsertWithoutHireRequestInput = {
    update: XOR<DesignerRatingUpdateWithoutHireRequestInput, DesignerRatingUncheckedUpdateWithoutHireRequestInput>
    create: XOR<DesignerRatingCreateWithoutHireRequestInput, DesignerRatingUncheckedCreateWithoutHireRequestInput>
    where?: DesignerRatingWhereInput
  }

  export type DesignerRatingUpdateToOneWithWhereWithoutHireRequestInput = {
    where?: DesignerRatingWhereInput
    data: XOR<DesignerRatingUpdateWithoutHireRequestInput, DesignerRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type DesignerRatingUpdateWithoutHireRequestInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type DesignerRatingUncheckedUpdateWithoutHireRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUpsertWithoutHireRequestInput = {
    update: XOR<UserRatingUpdateWithoutHireRequestInput, UserRatingUncheckedUpdateWithoutHireRequestInput>
    create: XOR<UserRatingCreateWithoutHireRequestInput, UserRatingUncheckedCreateWithoutHireRequestInput>
    where?: UserRatingWhereInput
  }

  export type UserRatingUpdateToOneWithWhereWithoutHireRequestInput = {
    where?: UserRatingWhereInput
    data: XOR<UserRatingUpdateWithoutHireRequestInput, UserRatingUncheckedUpdateWithoutHireRequestInput>
  }

  export type UserRatingUpdateWithoutHireRequestInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneWithoutUserRatingsNestedInput
  }

  export type UserRatingUncheckedUpdateWithoutHireRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerCreateWithoutRatingsInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateWithoutRatingsInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerCreateOrConnectWithoutRatingsInput = {
    where: DesignerWhereUniqueInput
    create: XOR<DesignerCreateWithoutRatingsInput, DesignerUncheckedCreateWithoutRatingsInput>
  }

  export type DesignerHireRequestCreateWithoutRatingInput = {
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHireRequestsInput
    designer: DesignerCreateNestedOneWithoutHireRequestsInput
    userRating?: UserRatingCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUncheckedCreateWithoutRatingInput = {
    id?: number
    userId: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    userRating?: UserRatingUncheckedCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestCreateOrConnectWithoutRatingInput = {
    where: DesignerHireRequestWhereUniqueInput
    create: XOR<DesignerHireRequestCreateWithoutRatingInput, DesignerHireRequestUncheckedCreateWithoutRatingInput>
  }

  export type DesignerUpsertWithoutRatingsInput = {
    update: XOR<DesignerUpdateWithoutRatingsInput, DesignerUncheckedUpdateWithoutRatingsInput>
    create: XOR<DesignerCreateWithoutRatingsInput, DesignerUncheckedCreateWithoutRatingsInput>
    where?: DesignerWhereInput
  }

  export type DesignerUpdateToOneWithWhereWithoutRatingsInput = {
    where?: DesignerWhereInput
    data: XOR<DesignerUpdateWithoutRatingsInput, DesignerUncheckedUpdateWithoutRatingsInput>
  }

  export type DesignerUpdateWithoutRatingsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerHireRequestUpsertWithoutRatingInput = {
    update: XOR<DesignerHireRequestUpdateWithoutRatingInput, DesignerHireRequestUncheckedUpdateWithoutRatingInput>
    create: XOR<DesignerHireRequestCreateWithoutRatingInput, DesignerHireRequestUncheckedCreateWithoutRatingInput>
    where?: DesignerHireRequestWhereInput
  }

  export type DesignerHireRequestUpdateToOneWithWhereWithoutRatingInput = {
    where?: DesignerHireRequestWhereInput
    data: XOR<DesignerHireRequestUpdateWithoutRatingInput, DesignerHireRequestUncheckedUpdateWithoutRatingInput>
  }

  export type DesignerHireRequestUpdateWithoutRatingInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHireRequestsNestedInput
    designer?: DesignerUpdateOneRequiredWithoutHireRequestsNestedInput
    userRating?: UserRatingUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRating?: UserRatingUncheckedUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestCreateWithoutUserRatingInput = {
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHireRequestsInput
    designer: DesignerCreateNestedOneWithoutHireRequestsInput
    rating?: DesignerRatingCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestUncheckedCreateWithoutUserRatingInput = {
    id?: number
    userId: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    rating?: DesignerRatingUncheckedCreateNestedOneWithoutHireRequestInput
  }

  export type DesignerHireRequestCreateOrConnectWithoutUserRatingInput = {
    where: DesignerHireRequestWhereUniqueInput
    create: XOR<DesignerHireRequestCreateWithoutUserRatingInput, DesignerHireRequestUncheckedCreateWithoutUserRatingInput>
  }

  export type DesignerCreateWithoutUserRatingsInput = {
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingCreateNestedManyWithoutDesignerInput
  }

  export type DesignerUncheckedCreateWithoutUserRatingsInput = {
    id?: number
    fullname: string
    email: string
    mobile: string
    location?: string | null
    passwordHash: string
    availability?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: DesignerProfileUncheckedCreateNestedOneWithoutDesignerInput
    works?: DesignerWorkUncheckedCreateNestedManyWithoutDesignerInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutDesignerInput
    ratings?: DesignerRatingUncheckedCreateNestedManyWithoutDesignerInput
  }

  export type DesignerCreateOrConnectWithoutUserRatingsInput = {
    where: DesignerWhereUniqueInput
    create: XOR<DesignerCreateWithoutUserRatingsInput, DesignerUncheckedCreateWithoutUserRatingsInput>
  }

  export type DesignerHireRequestUpsertWithoutUserRatingInput = {
    update: XOR<DesignerHireRequestUpdateWithoutUserRatingInput, DesignerHireRequestUncheckedUpdateWithoutUserRatingInput>
    create: XOR<DesignerHireRequestCreateWithoutUserRatingInput, DesignerHireRequestUncheckedCreateWithoutUserRatingInput>
    where?: DesignerHireRequestWhereInput
  }

  export type DesignerHireRequestUpdateToOneWithWhereWithoutUserRatingInput = {
    where?: DesignerHireRequestWhereInput
    data: XOR<DesignerHireRequestUpdateWithoutUserRatingInput, DesignerHireRequestUncheckedUpdateWithoutUserRatingInput>
  }

  export type DesignerHireRequestUpdateWithoutUserRatingInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHireRequestsNestedInput
    designer?: DesignerUpdateOneRequiredWithoutHireRequestsNestedInput
    rating?: DesignerRatingUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateWithoutUserRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: DesignerRatingUncheckedUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerUpsertWithoutUserRatingsInput = {
    update: XOR<DesignerUpdateWithoutUserRatingsInput, DesignerUncheckedUpdateWithoutUserRatingsInput>
    create: XOR<DesignerCreateWithoutUserRatingsInput, DesignerUncheckedCreateWithoutUserRatingsInput>
    where?: DesignerWhereInput
  }

  export type DesignerUpdateToOneWithWhereWithoutUserRatingsInput = {
    where?: DesignerWhereInput
    data: XOR<DesignerUpdateWithoutUserRatingsInput, DesignerUncheckedUpdateWithoutUserRatingsInput>
  }

  export type DesignerUpdateWithoutUserRatingsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUpdateManyWithoutDesignerNestedInput
  }

  export type DesignerUncheckedUpdateWithoutUserRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: DesignerProfileUncheckedUpdateOneWithoutDesignerNestedInput
    works?: DesignerWorkUncheckedUpdateManyWithoutDesignerNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutDesignerNestedInput
    ratings?: DesignerRatingUncheckedUpdateManyWithoutDesignerNestedInput
  }

  export type OrderItemCreateWithoutReturnRequestInput = {
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    seller: SellerCreateNestedOneWithoutOrderItemsInput
    rating?: RatingCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutReturnRequestInput = {
    id?: number
    orderId: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
    rating?: RatingUncheckedCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutReturnRequestInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
  }

  export type UserCreateWithoutReturnRequestsInput = {
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReturnRequestsInput = {
    id?: number
    name: string
    email: string
    password: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    credit?: number
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    hireRequests?: DesignerHireRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReturnRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReturnRequestsInput, UserUncheckedCreateWithoutReturnRequestsInput>
  }

  export type OrderItemUpsertWithoutReturnRequestInput = {
    update: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutReturnRequestInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>
  }

  export type OrderItemUpdateWithoutReturnRequestInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    seller?: SellerUpdateOneRequiredWithoutOrderItemsNestedInput
    rating?: RatingUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutReturnRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type UserUpsertWithoutReturnRequestsInput = {
    update: XOR<UserUpdateWithoutReturnRequestsInput, UserUncheckedUpdateWithoutReturnRequestsInput>
    create: XOR<UserCreateWithoutReturnRequestsInput, UserUncheckedCreateWithoutReturnRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReturnRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReturnRequestsInput, UserUncheckedUpdateWithoutReturnRequestsInput>
  }

  export type UserUpdateWithoutReturnRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReturnRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credit?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    hireRequests?: DesignerHireRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: number
    customerEmail: string
    customerName: string
    address: string
    paymentMethod: string
    subtotal: number
    casaCharge: number
    deliveryCharge: number
    grandTotal: number
    createdAt?: Date | string
  }

  export type RatingCreateManyUserInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    productId: number
    orderItemId: number
  }

  export type DesignerHireRequestCreateManyUserInput = {
    id?: number
    designerId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ReturnRequestCreateManyUserInput = {
    id?: number
    orderItemId: number
    productName: string
    sellerId: number
    sellerName?: string | null
    reason: string
    note?: string | null
    images?: ReturnRequestCreateimagesInput | string[]
    requestedAt?: Date | string
    sellerApprovalStatus?: $Enums.ApprovalStatus
    adminApprovalStatus?: $Enums.ApprovalStatus
    sellerApprovedAt?: Date | string | null
    adminApprovedAt?: Date | string | null
    sellerDecisionNote?: string | null
    adminDecisionNote?: string | null
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    casaCharge?: FloatFieldUpdateOperationsInput | number
    deliveryCharge?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutUserInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutRatingNestedInput
  }

  export type RatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type DesignerHireRequestUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designer?: DesignerUpdateOneRequiredWithoutHireRequestsNestedInput
    rating?: DesignerRatingUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: DesignerRatingUncheckedUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUncheckedUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    designerId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnRequestUpdateWithoutUserInput = {
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput
  }

  export type ReturnRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    sellerId?: IntFieldUpdateOperationsInput | number
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ReturnRequestUpdateimagesInput | string[]
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellerApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    adminApprovalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    sellerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellerDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    adminDecisionNote?: NullableStringFieldUpdateOperationsInput | string | null
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManySellerInput = {
    id?: number
    orderId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type ProductCreateManySellerInput = {
    id?: number
    name: string
    price: number
    productType: string
    category: string
    description?: string | null
    images?: ProductCreateimagesInput | string[]
    video?: string | null
    availability?: string
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutSellerInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    rating?: RatingUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutSellerInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    video?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyProductInput = {
    id?: number
    stars: number
    comment?: string | null
    createdAt?: Date | string
    userId: number
    orderItemId: number
  }

  export type RatingUpdateWithoutProductInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutRatingNestedInput
  }

  export type RatingUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RatingUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    sellerId: number
    materialId: number
    materialName: string
    supplierName: string
    imageUrl?: string | null
    quantity: number
    pricePerUnit: number
    totalAmount: number
    status?: string
    returnStatus?: $Enums.ReturnStatus
    returnReason?: string | null
    returnRequestedAt?: Date | string | null
    returnResolvedAt?: Date | string | null
    refundAmount?: number | null
    refundStatus?: $Enums.RefundStatus
    refundProcessedAt?: Date | string | null
    deliveryTimeMin?: number | null
    deliveryTimeMax?: number | null
    shippingChargeType?: string | null
    shippingCharge?: number | null
    installationAvailable?: string | null
    installationCharge?: number | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: SellerUpdateOneRequiredWithoutOrderItemsNestedInput
    rating?: RatingUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateOneWithoutOrderItemNestedInput
    returnRequest?: ReturnRequestUncheckedUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    returnStatus?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    returnReason?: NullableStringFieldUpdateOperationsInput | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnResolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    refundProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryTimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    shippingChargeType?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCharge?: NullableIntFieldUpdateOperationsInput | number | null
    installationAvailable?: NullableStringFieldUpdateOperationsInput | string | null
    installationCharge?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkCreateManyDesignerInput = {
    id?: number
    image: string
    description?: string | null
    createdAt?: Date | string
  }

  export type DesignerHireRequestCreateManyDesignerInput = {
    id?: number
    userId: number
    fullName: string
    email: string
    mobile: string
    location: string
    budget: number
    workType: string
    timelineDate?: Date | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type DesignerRatingCreateManyDesignerInput = {
    id?: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type UserRatingCreateManyDesignerInput = {
    id?: number
    hireRequestId: number
    reviewerName?: string | null
    stars: number
    review?: string | null
    createdAt?: Date | string
  }

  export type DesignerWorkUpdateWithoutDesignerInput = {
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkUncheckedUpdateWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerWorkUncheckedUpdateManyWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerHireRequestUpdateWithoutDesignerInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHireRequestsNestedInput
    rating?: DesignerRatingUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: DesignerRatingUncheckedUpdateOneWithoutHireRequestNestedInput
    userRating?: UserRatingUncheckedUpdateOneWithoutHireRequestNestedInput
  }

  export type DesignerHireRequestUncheckedUpdateManyWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    budget?: IntFieldUpdateOperationsInput | number
    workType?: StringFieldUpdateOperationsInput | string
    timelineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerRatingUpdateWithoutDesignerInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hireRequest?: DesignerHireRequestUpdateOneRequiredWithoutRatingNestedInput
  }

  export type DesignerRatingUncheckedUpdateWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignerRatingUncheckedUpdateManyWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUpdateWithoutDesignerInput = {
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hireRequest?: DesignerHireRequestUpdateOneRequiredWithoutUserRatingNestedInput
  }

  export type UserRatingUncheckedUpdateWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyWithoutDesignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    hireRequestId?: IntFieldUpdateOperationsInput | number
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}